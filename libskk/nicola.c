/* nicola.c generated by valac 0.14.1, the Vala compiler
 * generated from nicola.vala, do not modify */

/*
 * Copyright (C) 2011-2012 Daiki Ueno <ueno@unixuser.org>
 * Copyright (C) 2011-2012 Red Hat, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <gobject/gvaluecollector.h>


#define SKK_TYPE_KEY_EVENT_FILTER (skk_key_event_filter_get_type ())
#define SKK_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_KEY_EVENT_FILTER, SkkKeyEventFilter))
#define SKK_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_KEY_EVENT_FILTER, SkkKeyEventFilterClass))
#define SKK_IS_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_KEY_EVENT_FILTER))
#define SKK_IS_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_KEY_EVENT_FILTER))
#define SKK_KEY_EVENT_FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_KEY_EVENT_FILTER, SkkKeyEventFilterClass))

typedef struct _SkkKeyEventFilter SkkKeyEventFilter;
typedef struct _SkkKeyEventFilterClass SkkKeyEventFilterClass;
typedef struct _SkkKeyEventFilterPrivate SkkKeyEventFilterPrivate;

#define SKK_TYPE_KEY_EVENT (skk_key_event_get_type ())
#define SKK_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_KEY_EVENT, SkkKeyEvent))
#define SKK_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_KEY_EVENT, SkkKeyEventClass))
#define SKK_IS_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_KEY_EVENT))
#define SKK_IS_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_KEY_EVENT))
#define SKK_KEY_EVENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_KEY_EVENT, SkkKeyEventClass))

typedef struct _SkkKeyEvent SkkKeyEvent;
typedef struct _SkkKeyEventClass SkkKeyEventClass;

#define SKK_TYPE_NICOLA_KEY_EVENT_FILTER (skk_nicola_key_event_filter_get_type ())
#define SKK_NICOLA_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_NICOLA_KEY_EVENT_FILTER, SkkNicolaKeyEventFilter))
#define SKK_NICOLA_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_NICOLA_KEY_EVENT_FILTER, SkkNicolaKeyEventFilterClass))
#define SKK_IS_NICOLA_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_NICOLA_KEY_EVENT_FILTER))
#define SKK_IS_NICOLA_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_NICOLA_KEY_EVENT_FILTER))
#define SKK_NICOLA_KEY_EVENT_FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_NICOLA_KEY_EVENT_FILTER, SkkNicolaKeyEventFilterClass))

typedef struct _SkkNicolaKeyEventFilter SkkNicolaKeyEventFilter;
typedef struct _SkkNicolaKeyEventFilterClass SkkNicolaKeyEventFilterClass;
typedef struct _SkkNicolaKeyEventFilterPrivate SkkNicolaKeyEventFilterPrivate;

#define SKK_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY (skk_nicola_key_event_filter_timed_entry_get_type ())
#define SKK_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY, SkkNicolaKeyEventFilterTimedEntry))
#define SKK_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY, SkkNicolaKeyEventFilterTimedEntryClass))
#define SKK_NICOLA_KEY_EVENT_FILTER_IS_TIMED_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY))
#define SKK_NICOLA_KEY_EVENT_FILTER_IS_TIMED_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY))
#define SKK_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY, SkkNicolaKeyEventFilterTimedEntryClass))

typedef struct _SkkNicolaKeyEventFilterTimedEntry SkkNicolaKeyEventFilterTimedEntry;
typedef struct _SkkNicolaKeyEventFilterTimedEntryClass SkkNicolaKeyEventFilterTimedEntryClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define SKK_TYPE_MODIFIER_TYPE (skk_modifier_type_get_type ())
typedef struct _SkkNicolaKeyEventFilterTimedEntryPrivate SkkNicolaKeyEventFilterTimedEntryPrivate;
#define _skk_nicola_key_event_filter_timed_entry_unref0(var) ((var == NULL) ? NULL : (var = (skk_nicola_key_event_filter_timed_entry_unref (var), NULL)))
#define _t_destroy_func0(var) (((var == NULL) || (t_destroy_func == NULL)) ? NULL : (var = (t_destroy_func (var), NULL)))
typedef struct _SkkNicolaKeyEventFilterParamSpecTimedEntry SkkNicolaKeyEventFilterParamSpecTimedEntry;

typedef gint64 (*SkkGetTime) (void* user_data);
struct _SkkKeyEventFilter {
	GObject parent_instance;
	SkkKeyEventFilterPrivate * priv;
};

struct _SkkKeyEventFilterClass {
	GObjectClass parent_class;
	SkkKeyEvent* (*filter_key_event) (SkkKeyEventFilter* self, SkkKeyEvent* key);
	void (*reset) (SkkKeyEventFilter* self);
};

struct _SkkNicolaKeyEventFilter {
	SkkKeyEventFilter parent_instance;
	SkkNicolaKeyEventFilterPrivate * priv;
	SkkGetTime get_time_func;
	gpointer get_time_func_target;
	GDestroyNotify get_time_func_target_destroy_notify;
	gint64 timeout;
	gint64 overlap;
	gint64 maxwait;
	gchar** special_doubles;
	gint special_doubles_length1;
};

struct _SkkNicolaKeyEventFilterClass {
	SkkKeyEventFilterClass parent_class;
};

struct _SkkNicolaKeyEventFilterPrivate {
	GeeLinkedList* pending;
	guint timeout_id;
};

typedef enum  {
	SKK_MODIFIER_TYPE_NONE = 0,
	SKK_MODIFIER_TYPE_SHIFT_MASK = 1 << 0,
	SKK_MODIFIER_TYPE_LOCK_MASK = 1 << 1,
	SKK_MODIFIER_TYPE_CONTROL_MASK = 1 << 2,
	SKK_MODIFIER_TYPE_MOD1_MASK = 1 << 3,
	SKK_MODIFIER_TYPE_MOD2_MASK = 1 << 4,
	SKK_MODIFIER_TYPE_MOD3_MASK = 1 << 5,
	SKK_MODIFIER_TYPE_MOD4_MASK = 1 << 6,
	SKK_MODIFIER_TYPE_MOD5_MASK = 1 << 7,
	SKK_MODIFIER_TYPE_LSHIFT_MASK = 1 << 22,
	SKK_MODIFIER_TYPE_RSHIFT_MASK = 1 << 23,
	SKK_MODIFIER_TYPE_USLEEP_MASK = 1 << 24,
	SKK_MODIFIER_TYPE_SUPER_MASK = 1 << 26,
	SKK_MODIFIER_TYPE_HYPER_MASK = 1 << 27,
	SKK_MODIFIER_TYPE_META_MASK = 1 << 28,
	SKK_MODIFIER_TYPE_RELEASE_MASK = 1 << 30
} SkkModifierType;

struct _SkkNicolaKeyEventFilterTimedEntry {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SkkNicolaKeyEventFilterTimedEntryPrivate * priv;
	gpointer data;
	gint64 time;
};

struct _SkkNicolaKeyEventFilterTimedEntryClass {
	GTypeClass parent_class;
	void (*finalize) (SkkNicolaKeyEventFilterTimedEntry *self);
};

struct _SkkNicolaKeyEventFilterTimedEntryPrivate {
	GType t_type;
	GBoxedCopyFunc t_dup_func;
	GDestroyNotify t_destroy_func;
};

struct _SkkNicolaKeyEventFilterParamSpecTimedEntry {
	GParamSpec parent_instance;
};


static gpointer skk_nicola_key_event_filter_parent_class = NULL;
static gpointer skk_nicola_key_event_filter_timed_entry_parent_class = NULL;

GType skk_key_event_filter_get_type (void) G_GNUC_CONST;
GType skk_key_event_get_type (void) G_GNUC_CONST;
GType skk_nicola_key_event_filter_get_type (void) G_GNUC_CONST;
static gpointer skk_nicola_key_event_filter_timed_entry_ref (gpointer instance);
static void skk_nicola_key_event_filter_timed_entry_unref (gpointer instance);
static GParamSpec* skk_nicola_key_event_filter_param_spec_timed_entry (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void skk_nicola_key_event_filter_value_set_timed_entry (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void skk_nicola_key_event_filter_value_take_timed_entry (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer skk_nicola_key_event_filter_value_get_timed_entry (const GValue* value) G_GNUC_UNUSED;
static GType skk_nicola_key_event_filter_timed_entry_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define SKK_NICOLA_KEY_EVENT_FILTER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SKK_TYPE_NICOLA_KEY_EVENT_FILTER, SkkNicolaKeyEventFilterPrivate))
enum  {
	SKK_NICOLA_KEY_EVENT_FILTER_DUMMY_PROPERTY
};
static gint64 skk_nicola_key_event_filter_get_time (void);
static gint64 _skk_nicola_key_event_filter_get_time_skk_get_time (gpointer self);
static gboolean skk_nicola_key_event_filter_is_char (SkkKeyEvent* key);
gunichar skk_key_event_get_code (SkkKeyEvent* self);
static gboolean skk_nicola_key_event_filter_is_lshift (SkkKeyEvent* key);
const gchar* skk_key_event_get_name (SkkKeyEvent* self);
static gboolean skk_nicola_key_event_filter_is_rshift (SkkKeyEvent* key);
static gboolean skk_nicola_key_event_filter_is_shift (SkkKeyEvent* key);
static gchar* skk_nicola_key_event_filter_get_special_double_name (SkkKeyEvent* a, SkkKeyEvent* b);
static SkkKeyEvent* skk_nicola_key_event_filter_queue (SkkNicolaKeyEventFilter* self, SkkKeyEvent* key, gint64 time, gint64* wait);
GType skk_modifier_type_get_type (void) G_GNUC_CONST;
SkkModifierType skk_key_event_get_modifiers (SkkKeyEvent* self);
gboolean skk_key_event_base_equal (SkkKeyEvent* self, SkkKeyEvent* key);
static gint64 skk_nicola_key_event_filter_get_next_wait (SkkNicolaKeyEventFilter* self, SkkKeyEvent* key, gint64 time);
static SkkNicolaKeyEventFilterTimedEntry* skk_nicola_key_event_filter_timed_entry_new (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer data, gint64 time);
static SkkNicolaKeyEventFilterTimedEntry* skk_nicola_key_event_filter_timed_entry_construct (GType object_type, GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer data, gint64 time);
static SkkKeyEvent* skk_nicola_key_event_filter_dispatch_single (SkkNicolaKeyEventFilter* self, gint64 time);
static void skk_nicola_key_event_filter_apply_shift (SkkNicolaKeyEventFilter* self, SkkKeyEvent* s, SkkKeyEvent* c);
void skk_key_event_set_modifiers (SkkKeyEvent* self, SkkModifierType value);
static SkkKeyEvent* skk_nicola_key_event_filter_dispatch (SkkNicolaKeyEventFilter* self, gint64 time);
static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle);
SkkKeyEvent* skk_key_event_new (const gchar* name, gunichar code, SkkModifierType modifiers);
SkkKeyEvent* skk_key_event_construct (GType object_type, const gchar* name, gunichar code, SkkModifierType modifiers);
static gboolean skk_nicola_key_event_filter_timeout_func (SkkNicolaKeyEventFilter* self);
static SkkKeyEvent* skk_nicola_key_event_filter_real_filter_key_event (SkkKeyEventFilter* base, SkkKeyEvent* key);
static gboolean _skk_nicola_key_event_filter_timeout_func_gsource_func (gpointer self);
static void skk_nicola_key_event_filter_real_reset (SkkKeyEventFilter* base);
SkkNicolaKeyEventFilter* skk_nicola_key_event_filter_new (void);
SkkNicolaKeyEventFilter* skk_nicola_key_event_filter_construct (GType object_type);
SkkKeyEventFilter* skk_key_event_filter_construct (GType object_type);
static GObject * skk_nicola_key_event_filter_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static gchar** _vala_array_dup5 (gchar** self, int length);
#define SKK_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SKK_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY, SkkNicolaKeyEventFilterTimedEntryPrivate))
enum  {
	SKK_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY_DUMMY_PROPERTY
};
static void skk_nicola_key_event_filter_timed_entry_finalize (SkkNicolaKeyEventFilterTimedEntry* obj);
static void skk_nicola_key_event_filter_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

static const gchar* SKK_NICOLA_KEY_EVENT_FILTER_SPECIAL_DOUBLES[4] = {"[fj]", "[gh]", "[dk]", "[LR]"};

static gint64 _skk_nicola_key_event_filter_get_time_skk_get_time (gpointer self) {
	gint64 result;
	result = skk_nicola_key_event_filter_get_time ();
	return result;
}


static gint64 skk_nicola_key_event_filter_get_time (void) {
	gint64 result = 0LL;
	GTimeVal tv = {0};
	GTimeVal _tmp0_;
	glong _tmp1_;
	GTimeVal _tmp2_;
	glong _tmp3_;
	g_get_current_time (&tv);
	_tmp0_ = tv;
	_tmp1_ = _tmp0_.tv_sec;
	_tmp2_ = tv;
	_tmp3_ = _tmp2_.tv_usec;
	result = (((gint64) _tmp1_) * 1000000) + _tmp3_;
	return result;
}


static gboolean skk_nicola_key_event_filter_is_char (SkkKeyEvent* key) {
	gboolean result = FALSE;
	SkkKeyEvent* _tmp0_;
	gunichar _tmp1_;
	gunichar _tmp2_;
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = key;
	_tmp1_ = skk_key_event_get_code (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_ != ((gunichar) 0);
	return result;
}


static gboolean skk_nicola_key_event_filter_is_lshift (SkkKeyEvent* key) {
	gboolean result = FALSE;
	SkkKeyEvent* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = key;
	_tmp1_ = skk_key_event_get_name (_tmp0_);
	_tmp2_ = _tmp1_;
	result = g_strcmp0 (_tmp2_, "lshift") == 0;
	return result;
}


static gboolean skk_nicola_key_event_filter_is_rshift (SkkKeyEvent* key) {
	gboolean result = FALSE;
	SkkKeyEvent* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = key;
	_tmp1_ = skk_key_event_get_name (_tmp0_);
	_tmp2_ = _tmp1_;
	result = g_strcmp0 (_tmp2_, "rshift") == 0;
	return result;
}


static gboolean skk_nicola_key_event_filter_is_shift (SkkKeyEvent* key) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	SkkKeyEvent* _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp5_;
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp1_ = key;
	_tmp2_ = skk_nicola_key_event_filter_is_lshift (_tmp1_);
	if (_tmp2_) {
		_tmp0_ = TRUE;
	} else {
		SkkKeyEvent* _tmp3_;
		gboolean _tmp4_ = FALSE;
		_tmp3_ = key;
		_tmp4_ = skk_nicola_key_event_filter_is_rshift (_tmp3_);
		_tmp0_ = _tmp4_;
	}
	_tmp5_ = _tmp0_;
	result = _tmp5_;
	return result;
}


static gchar* g_unichar_to_string (gunichar self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* str;
	const gchar* _tmp1_;
	_tmp0_ = g_new0 (gchar, 7);
	str = (gchar*) _tmp0_;
	_tmp1_ = str;
	g_unichar_to_utf8 (self, _tmp1_);
	result = str;
	return result;
}


static gchar* skk_nicola_key_event_filter_get_special_double_name (SkkKeyEvent* a, SkkKeyEvent* b) {
	gchar* result = NULL;
	gboolean _tmp0_ = FALSE;
	SkkKeyEvent* _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp5_;
	g_return_val_if_fail (a != NULL, NULL);
	g_return_val_if_fail (b != NULL, NULL);
	_tmp1_ = a;
	_tmp2_ = skk_nicola_key_event_filter_is_shift (_tmp1_);
	if (_tmp2_) {
		SkkKeyEvent* _tmp3_;
		gboolean _tmp4_ = FALSE;
		_tmp3_ = b;
		_tmp4_ = skk_nicola_key_event_filter_is_shift (_tmp3_);
		_tmp0_ = _tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp5_ = _tmp0_;
	if (_tmp5_) {
		gchar* _tmp6_;
		_tmp6_ = g_strdup ("[LR]");
		result = _tmp6_;
		return result;
	} else {
		gboolean _tmp7_ = FALSE;
		SkkKeyEvent* _tmp8_;
		gboolean _tmp9_ = FALSE;
		gboolean _tmp12_;
		_tmp8_ = a;
		_tmp9_ = skk_nicola_key_event_filter_is_char (_tmp8_);
		if (_tmp9_) {
			SkkKeyEvent* _tmp10_;
			gboolean _tmp11_ = FALSE;
			_tmp10_ = b;
			_tmp11_ = skk_nicola_key_event_filter_is_char (_tmp10_);
			_tmp7_ = _tmp11_;
		} else {
			_tmp7_ = FALSE;
		}
		_tmp12_ = _tmp7_;
		if (_tmp12_) {
			gunichar ac = 0U;
			gunichar bc = 0U;
			SkkKeyEvent* _tmp13_;
			gunichar _tmp14_;
			gunichar _tmp15_;
			SkkKeyEvent* _tmp16_;
			gunichar _tmp17_;
			gunichar _tmp18_;
			gunichar _tmp31_;
			gchar* _tmp32_ = NULL;
			gchar* _tmp33_;
			gunichar _tmp34_;
			gchar* _tmp35_ = NULL;
			gchar* _tmp36_;
			gchar* _tmp37_ = NULL;
			gchar* _tmp38_;
			_tmp13_ = a;
			_tmp14_ = skk_key_event_get_code (_tmp13_);
			_tmp15_ = _tmp14_;
			_tmp16_ = b;
			_tmp17_ = skk_key_event_get_code (_tmp16_);
			_tmp18_ = _tmp17_;
			if (_tmp15_ < _tmp18_) {
				SkkKeyEvent* _tmp19_;
				gunichar _tmp20_;
				gunichar _tmp21_;
				SkkKeyEvent* _tmp22_;
				gunichar _tmp23_;
				gunichar _tmp24_;
				_tmp19_ = a;
				_tmp20_ = skk_key_event_get_code (_tmp19_);
				_tmp21_ = _tmp20_;
				ac = _tmp21_;
				_tmp22_ = b;
				_tmp23_ = skk_key_event_get_code (_tmp22_);
				_tmp24_ = _tmp23_;
				bc = _tmp24_;
			} else {
				SkkKeyEvent* _tmp25_;
				gunichar _tmp26_;
				gunichar _tmp27_;
				SkkKeyEvent* _tmp28_;
				gunichar _tmp29_;
				gunichar _tmp30_;
				_tmp25_ = b;
				_tmp26_ = skk_key_event_get_code (_tmp25_);
				_tmp27_ = _tmp26_;
				ac = _tmp27_;
				_tmp28_ = a;
				_tmp29_ = skk_key_event_get_code (_tmp28_);
				_tmp30_ = _tmp29_;
				bc = _tmp30_;
			}
			_tmp31_ = ac;
			_tmp32_ = g_unichar_to_string (_tmp31_);
			_tmp33_ = _tmp32_;
			_tmp34_ = bc;
			_tmp35_ = g_unichar_to_string (_tmp34_);
			_tmp36_ = _tmp35_;
			_tmp37_ = g_strconcat ("[", _tmp33_, _tmp36_, "]", NULL);
			_tmp38_ = _tmp37_;
			_g_free0 (_tmp36_);
			_g_free0 (_tmp33_);
			result = _tmp38_;
			return result;
		} else {
			g_return_val_if_reached (NULL);
		}
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static SkkKeyEvent* skk_nicola_key_event_filter_queue (SkkNicolaKeyEventFilter* self, SkkKeyEvent* key, gint64 time, gint64* wait) {
	gint64 _vala_wait = 0LL;
	SkkKeyEvent* result = NULL;
	SkkKeyEvent* _tmp0_;
	SkkModifierType _tmp1_;
	SkkModifierType _tmp2_;
	gint64 _tmp64_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = key;
	_tmp1_ = skk_key_event_get_modifiers (_tmp0_);
	_tmp2_ = _tmp1_;
	if ((_tmp2_ & SKK_MODIFIER_TYPE_RELEASE_MASK) != 0) {
		gboolean _tmp3_ = FALSE;
		GeeLinkedList* _tmp4_;
		gint _tmp5_;
		gint _tmp6_;
		gboolean _tmp13_;
		_tmp4_ = self->priv->pending;
		_tmp5_ = gee_collection_get_size ((GeeCollection*) _tmp4_);
		_tmp6_ = _tmp5_;
		if (_tmp6_ > 0) {
			GeeLinkedList* _tmp7_;
			gpointer _tmp8_ = NULL;
			SkkNicolaKeyEventFilterTimedEntry* _tmp9_;
			gconstpointer _tmp10_;
			SkkKeyEvent* _tmp11_;
			gboolean _tmp12_ = FALSE;
			_tmp7_ = self->priv->pending;
			_tmp8_ = gee_abstract_list_get ((GeeAbstractList*) _tmp7_, 0);
			_tmp9_ = (SkkNicolaKeyEventFilterTimedEntry*) _tmp8_;
			_tmp10_ = _tmp9_->data;
			_tmp11_ = key;
			_tmp12_ = skk_key_event_base_equal ((SkkKeyEvent*) _tmp10_, _tmp11_);
			_tmp3_ = _tmp12_;
			_skk_nicola_key_event_filter_timed_entry_unref0 (_tmp9_);
		} else {
			_tmp3_ = FALSE;
		}
		_tmp13_ = _tmp3_;
		if (_tmp13_) {
			GeeLinkedList* _tmp14_;
			gpointer _tmp15_ = NULL;
			SkkNicolaKeyEventFilterTimedEntry* entry;
			SkkKeyEvent* _tmp16_;
			gint64 _tmp17_;
			gint64 _tmp18_ = 0LL;
			GeeLinkedList* _tmp19_;
			SkkNicolaKeyEventFilterTimedEntry* _tmp20_;
			gconstpointer _tmp21_;
			SkkKeyEvent* _tmp22_;
			_tmp14_ = self->priv->pending;
			_tmp15_ = gee_abstract_list_get ((GeeAbstractList*) _tmp14_, 0);
			entry = (SkkNicolaKeyEventFilterTimedEntry*) _tmp15_;
			_tmp16_ = key;
			_tmp17_ = time;
			_tmp18_ = skk_nicola_key_event_filter_get_next_wait (self, _tmp16_, _tmp17_);
			_vala_wait = _tmp18_;
			_tmp19_ = self->priv->pending;
			gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp19_);
			_tmp20_ = entry;
			_tmp21_ = _tmp20_->data;
			_tmp22_ = _g_object_ref0 ((SkkKeyEvent*) _tmp21_);
			result = _tmp22_;
			_skk_nicola_key_event_filter_timed_entry_unref0 (entry);
			if (wait) {
				*wait = _vala_wait;
			}
			return result;
		}
	} else {
		gboolean _tmp23_ = FALSE;
		GeeLinkedList* _tmp24_;
		gint _tmp25_;
		gint _tmp26_;
		gboolean _tmp33_;
		_tmp24_ = self->priv->pending;
		_tmp25_ = gee_collection_get_size ((GeeCollection*) _tmp24_);
		_tmp26_ = _tmp25_;
		if (_tmp26_ > 0) {
			GeeLinkedList* _tmp27_;
			gpointer _tmp28_ = NULL;
			SkkNicolaKeyEventFilterTimedEntry* _tmp29_;
			gconstpointer _tmp30_;
			SkkKeyEvent* _tmp31_;
			gboolean _tmp32_ = FALSE;
			_tmp27_ = self->priv->pending;
			_tmp28_ = gee_abstract_list_get ((GeeAbstractList*) _tmp27_, 0);
			_tmp29_ = (SkkNicolaKeyEventFilterTimedEntry*) _tmp28_;
			_tmp30_ = _tmp29_->data;
			_tmp31_ = key;
			_tmp32_ = skk_key_event_base_equal ((SkkKeyEvent*) _tmp30_, _tmp31_);
			_tmp23_ = _tmp32_;
			_skk_nicola_key_event_filter_timed_entry_unref0 (_tmp29_);
		} else {
			_tmp23_ = FALSE;
		}
		_tmp33_ = _tmp23_;
		if (_tmp33_) {
			GeeLinkedList* _tmp34_;
			gpointer _tmp35_ = NULL;
			SkkNicolaKeyEventFilterTimedEntry* _tmp36_;
			gint64 _tmp37_;
			SkkKeyEvent* _tmp38_;
			gint64 _tmp39_;
			gint64 _tmp40_ = 0LL;
			SkkKeyEvent* _tmp41_;
			SkkKeyEvent* _tmp42_;
			_tmp34_ = self->priv->pending;
			_tmp35_ = gee_abstract_list_get ((GeeAbstractList*) _tmp34_, 0);
			_tmp36_ = (SkkNicolaKeyEventFilterTimedEntry*) _tmp35_;
			_tmp37_ = time;
			_tmp36_->time = _tmp37_;
			_skk_nicola_key_event_filter_timed_entry_unref0 (_tmp36_);
			_tmp38_ = key;
			_tmp39_ = time;
			_tmp40_ = skk_nicola_key_event_filter_get_next_wait (self, _tmp38_, _tmp39_);
			_vala_wait = _tmp40_;
			_tmp41_ = key;
			_tmp42_ = _g_object_ref0 (_tmp41_);
			result = _tmp42_;
			if (wait) {
				*wait = _vala_wait;
			}
			return result;
		} else {
			GeeLinkedList* _tmp43_;
			gint _tmp44_;
			gint _tmp45_;
			GeeLinkedList* _tmp59_;
			SkkKeyEvent* _tmp60_;
			gint64 _tmp61_;
			SkkNicolaKeyEventFilterTimedEntry* _tmp62_;
			SkkNicolaKeyEventFilterTimedEntry* _tmp63_;
			_tmp43_ = self->priv->pending;
			_tmp44_ = gee_collection_get_size ((GeeCollection*) _tmp43_);
			_tmp45_ = _tmp44_;
			if (_tmp45_ > 2) {
				GeeLinkedList* _tmp46_;
				GeeListIterator* _tmp47_ = NULL;
				GeeListIterator* iter;
				GeeListIterator* _tmp48_;
				_tmp46_ = self->priv->pending;
				_tmp47_ = gee_abstract_list_list_iterator ((GeeAbstractList*) _tmp46_);
				iter = _tmp47_;
				_tmp48_ = iter;
				gee_bidir_iterator_last ((GeeBidirIterator*) _tmp48_);
				{
					gboolean _tmp49_;
					_tmp49_ = TRUE;
					while (TRUE) {
						gboolean _tmp50_;
						GeeListIterator* _tmp58_;
						_tmp50_ = _tmp49_;
						if (!_tmp50_) {
							gboolean _tmp51_ = FALSE;
							GeeLinkedList* _tmp52_;
							gint _tmp53_;
							gint _tmp54_;
							gboolean _tmp57_;
							_tmp52_ = self->priv->pending;
							_tmp53_ = gee_collection_get_size ((GeeCollection*) _tmp52_);
							_tmp54_ = _tmp53_;
							if (_tmp54_ > 2) {
								GeeListIterator* _tmp55_;
								gboolean _tmp56_ = FALSE;
								_tmp55_ = iter;
								_tmp56_ = gee_bidir_iterator_previous ((GeeBidirIterator*) _tmp55_);
								_tmp51_ = _tmp56_;
							} else {
								_tmp51_ = FALSE;
							}
							_tmp57_ = _tmp51_;
							if (!_tmp57_) {
								break;
							}
						}
						_tmp49_ = FALSE;
						_tmp58_ = iter;
						gee_iterator_remove ((GeeIterator*) _tmp58_);
					}
				}
				_g_object_unref0 (iter);
			}
			_tmp59_ = self->priv->pending;
			_tmp60_ = key;
			_tmp61_ = time;
			_tmp62_ = skk_nicola_key_event_filter_timed_entry_new (SKK_TYPE_KEY_EVENT, (GBoxedCopyFunc) g_object_ref, g_object_unref, _tmp60_, _tmp61_);
			_tmp63_ = _tmp62_;
			gee_abstract_list_insert ((GeeAbstractList*) _tmp59_, 0, _tmp63_);
			_skk_nicola_key_event_filter_timed_entry_unref0 (_tmp63_);
		}
	}
	_tmp64_ = self->maxwait;
	_vala_wait = _tmp64_;
	result = NULL;
	if (wait) {
		*wait = _vala_wait;
	}
	return result;
}


static gint64 skk_nicola_key_event_filter_get_next_wait (SkkNicolaKeyEventFilter* self, SkkKeyEvent* key, gint64 time) {
	gint64 result = 0LL;
	GeeLinkedList* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	GeeLinkedList* _tmp17_;
	gint _tmp18_;
	gint _tmp19_;
	g_return_val_if_fail (self != NULL, 0LL);
	g_return_val_if_fail (key != NULL, 0LL);
	_tmp0_ = self->priv->pending;
	_tmp1_ = gee_collection_get_size ((GeeCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ > 0) {
		GeeLinkedList* _tmp3_;
		GeeListIterator* _tmp4_ = NULL;
		GeeListIterator* iter;
		GeeListIterator* _tmp5_;
		_tmp3_ = self->priv->pending;
		_tmp4_ = gee_abstract_list_list_iterator ((GeeAbstractList*) _tmp3_);
		iter = _tmp4_;
		_tmp5_ = iter;
		gee_bidir_iterator_last ((GeeBidirIterator*) _tmp5_);
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				gboolean _tmp7_;
				GeeListIterator* _tmp10_;
				gpointer _tmp11_ = NULL;
				SkkNicolaKeyEventFilterTimedEntry* entry;
				gint64 _tmp12_;
				SkkNicolaKeyEventFilterTimedEntry* _tmp13_;
				gint64 _tmp14_;
				gint64 _tmp15_;
				_tmp7_ = _tmp6_;
				if (!_tmp7_) {
					GeeListIterator* _tmp8_;
					gboolean _tmp9_ = FALSE;
					_tmp8_ = iter;
					_tmp9_ = gee_bidir_iterator_previous ((GeeBidirIterator*) _tmp8_);
					if (!_tmp9_) {
						break;
					}
				}
				_tmp6_ = FALSE;
				_tmp10_ = iter;
				_tmp11_ = gee_iterator_get ((GeeIterator*) _tmp10_);
				entry = (SkkNicolaKeyEventFilterTimedEntry*) _tmp11_;
				_tmp12_ = time;
				_tmp13_ = entry;
				_tmp14_ = _tmp13_->time;
				_tmp15_ = self->timeout;
				if ((_tmp12_ - _tmp14_) > _tmp15_) {
					GeeListIterator* _tmp16_;
					_tmp16_ = iter;
					gee_iterator_remove ((GeeIterator*) _tmp16_);
				}
				_skk_nicola_key_event_filter_timed_entry_unref0 (entry);
			}
		}
		_g_object_unref0 (iter);
	}
	_tmp17_ = self->priv->pending;
	_tmp18_ = gee_collection_get_size ((GeeCollection*) _tmp17_);
	_tmp19_ = _tmp18_;
	if (_tmp19_ > 0) {
		gint64 _tmp20_;
		gint64 _tmp21_;
		GeeLinkedList* _tmp22_;
		gpointer _tmp23_ = NULL;
		SkkNicolaKeyEventFilterTimedEntry* _tmp24_;
		gint64 _tmp25_;
		gint64 _tmp26_;
		_tmp20_ = self->timeout;
		_tmp21_ = time;
		_tmp22_ = self->priv->pending;
		_tmp23_ = gee_abstract_list_last ((GeeAbstractList*) _tmp22_);
		_tmp24_ = (SkkNicolaKeyEventFilterTimedEntry*) _tmp23_;
		_tmp25_ = _tmp24_->time;
		_tmp26_ = _tmp20_ - (_tmp21_ - _tmp25_);
		_skk_nicola_key_event_filter_timed_entry_unref0 (_tmp24_);
		result = _tmp26_;
		return result;
	} else {
		gint64 _tmp27_;
		_tmp27_ = self->maxwait;
		result = _tmp27_;
		return result;
	}
}


static SkkKeyEvent* skk_nicola_key_event_filter_dispatch_single (SkkNicolaKeyEventFilter* self, gint64 time) {
	SkkKeyEvent* result = NULL;
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	SkkNicolaKeyEventFilterTimedEntry* entry;
	gint64 _tmp2_;
	SkkNicolaKeyEventFilterTimedEntry* _tmp3_;
	gint64 _tmp4_;
	gint64 _tmp5_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->pending;
	_tmp1_ = gee_queue_peek ((GeeQueue*) _tmp0_);
	entry = (SkkNicolaKeyEventFilterTimedEntry*) _tmp1_;
	_tmp2_ = time;
	_tmp3_ = entry;
	_tmp4_ = _tmp3_->time;
	_tmp5_ = self->timeout;
	if ((_tmp2_ - _tmp4_) > _tmp5_) {
		GeeLinkedList* _tmp6_;
		SkkNicolaKeyEventFilterTimedEntry* _tmp7_;
		gconstpointer _tmp8_;
		SkkKeyEvent* _tmp9_;
		_tmp6_ = self->priv->pending;
		gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp6_);
		_tmp7_ = entry;
		_tmp8_ = _tmp7_->data;
		_tmp9_ = _g_object_ref0 ((SkkKeyEvent*) _tmp8_);
		result = _tmp9_;
		_skk_nicola_key_event_filter_timed_entry_unref0 (entry);
		return result;
	}
	result = NULL;
	_skk_nicola_key_event_filter_timed_entry_unref0 (entry);
	return result;
}


static void skk_nicola_key_event_filter_apply_shift (SkkNicolaKeyEventFilter* self, SkkKeyEvent* s, SkkKeyEvent* c) {
	SkkKeyEvent* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (s != NULL);
	g_return_if_fail (c != NULL);
	_tmp0_ = s;
	_tmp1_ = skk_key_event_get_name (_tmp0_);
	_tmp2_ = _tmp1_;
	if (g_strcmp0 (_tmp2_, "lshift") == 0) {
		SkkKeyEvent* _tmp3_;
		SkkKeyEvent* _tmp4_;
		SkkModifierType _tmp5_;
		SkkModifierType _tmp6_;
		_tmp3_ = c;
		_tmp4_ = c;
		_tmp5_ = skk_key_event_get_modifiers (_tmp4_);
		_tmp6_ = _tmp5_;
		skk_key_event_set_modifiers (_tmp4_, _tmp6_ | SKK_MODIFIER_TYPE_LSHIFT_MASK);
	} else {
		SkkKeyEvent* _tmp7_;
		const gchar* _tmp8_;
		const gchar* _tmp9_;
		_tmp7_ = s;
		_tmp8_ = skk_key_event_get_name (_tmp7_);
		_tmp9_ = _tmp8_;
		if (g_strcmp0 (_tmp9_, "rshift") == 0) {
			SkkKeyEvent* _tmp10_;
			SkkKeyEvent* _tmp11_;
			SkkModifierType _tmp12_;
			SkkModifierType _tmp13_;
			_tmp10_ = c;
			_tmp11_ = c;
			_tmp12_ = skk_key_event_get_modifiers (_tmp11_);
			_tmp13_ = _tmp12_;
			skk_key_event_set_modifiers (_tmp11_, _tmp13_ | SKK_MODIFIER_TYPE_RSHIFT_MASK);
		}
	}
}


static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle) {
	int i;
	for (i = 0; i < stack_length; i++) {
		if (g_strcmp0 (stack[i], needle) == 0) {
			return TRUE;
		}
	}
	return FALSE;
}


static SkkKeyEvent* skk_nicola_key_event_filter_dispatch (SkkNicolaKeyEventFilter* self, gint64 time) {
	SkkKeyEvent* result = NULL;
	GeeLinkedList* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->pending;
	_tmp1_ = gee_collection_get_size ((GeeCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == 3) {
		GeeLinkedList* _tmp3_;
		gpointer _tmp4_ = NULL;
		SkkNicolaKeyEventFilterTimedEntry* b;
		GeeLinkedList* _tmp5_;
		gpointer _tmp6_ = NULL;
		SkkNicolaKeyEventFilterTimedEntry* s;
		GeeLinkedList* _tmp7_;
		gpointer _tmp8_ = NULL;
		SkkNicolaKeyEventFilterTimedEntry* a;
		SkkNicolaKeyEventFilterTimedEntry* _tmp9_;
		gint64 _tmp10_;
		SkkNicolaKeyEventFilterTimedEntry* _tmp11_;
		gint64 _tmp12_;
		gint64 t1;
		SkkNicolaKeyEventFilterTimedEntry* _tmp13_;
		gint64 _tmp14_;
		SkkNicolaKeyEventFilterTimedEntry* _tmp15_;
		gint64 _tmp16_;
		gint64 t2;
		gint64 _tmp17_;
		gint64 _tmp18_;
		_tmp3_ = self->priv->pending;
		_tmp4_ = gee_abstract_list_get ((GeeAbstractList*) _tmp3_, 0);
		b = (SkkNicolaKeyEventFilterTimedEntry*) _tmp4_;
		_tmp5_ = self->priv->pending;
		_tmp6_ = gee_abstract_list_get ((GeeAbstractList*) _tmp5_, 1);
		s = (SkkNicolaKeyEventFilterTimedEntry*) _tmp6_;
		_tmp7_ = self->priv->pending;
		_tmp8_ = gee_abstract_list_get ((GeeAbstractList*) _tmp7_, 2);
		a = (SkkNicolaKeyEventFilterTimedEntry*) _tmp8_;
		_tmp9_ = s;
		_tmp10_ = _tmp9_->time;
		_tmp11_ = a;
		_tmp12_ = _tmp11_->time;
		t1 = _tmp10_ - _tmp12_;
		_tmp13_ = b;
		_tmp14_ = _tmp13_->time;
		_tmp15_ = s;
		_tmp16_ = _tmp15_->time;
		t2 = _tmp14_ - _tmp16_;
		_tmp17_ = t1;
		_tmp18_ = t2;
		if (_tmp17_ <= _tmp18_) {
			GeeLinkedList* _tmp19_;
			GeeLinkedList* _tmp20_;
			SkkNicolaKeyEventFilterTimedEntry* _tmp21_;
			gint64 _tmp22_;
			SkkKeyEvent* _tmp23_ = NULL;
			SkkKeyEvent* r;
			SkkNicolaKeyEventFilterTimedEntry* _tmp24_;
			gconstpointer _tmp25_;
			SkkNicolaKeyEventFilterTimedEntry* _tmp26_;
			gconstpointer _tmp27_;
			SkkNicolaKeyEventFilterTimedEntry* _tmp28_;
			gconstpointer _tmp29_;
			_tmp19_ = self->priv->pending;
			gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp19_);
			_tmp20_ = self->priv->pending;
			_tmp21_ = b;
			gee_deque_offer_head ((GeeDeque*) _tmp20_, _tmp21_);
			_tmp22_ = time;
			_tmp23_ = skk_nicola_key_event_filter_dispatch_single (self, _tmp22_);
			r = _tmp23_;
			_tmp24_ = s;
			_tmp25_ = _tmp24_->data;
			_tmp26_ = a;
			_tmp27_ = _tmp26_->data;
			skk_nicola_key_event_filter_apply_shift (self, (SkkKeyEvent*) _tmp25_, (SkkKeyEvent*) _tmp27_);
			_tmp28_ = a;
			_tmp29_ = _tmp28_->data;
			g_signal_emit_by_name ((SkkKeyEventFilter*) self, "forwarded", (SkkKeyEvent*) _tmp29_);
			result = r;
			_skk_nicola_key_event_filter_timed_entry_unref0 (a);
			_skk_nicola_key_event_filter_timed_entry_unref0 (s);
			_skk_nicola_key_event_filter_timed_entry_unref0 (b);
			return result;
		} else {
			GeeLinkedList* _tmp30_;
			SkkNicolaKeyEventFilterTimedEntry* _tmp31_;
			gconstpointer _tmp32_;
			SkkNicolaKeyEventFilterTimedEntry* _tmp33_;
			gconstpointer _tmp34_;
			SkkNicolaKeyEventFilterTimedEntry* _tmp35_;
			gconstpointer _tmp36_;
			SkkNicolaKeyEventFilterTimedEntry* _tmp37_;
			gconstpointer _tmp38_;
			SkkKeyEvent* _tmp39_;
			_tmp30_ = self->priv->pending;
			gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp30_);
			_tmp31_ = s;
			_tmp32_ = _tmp31_->data;
			_tmp33_ = b;
			_tmp34_ = _tmp33_->data;
			skk_nicola_key_event_filter_apply_shift (self, (SkkKeyEvent*) _tmp32_, (SkkKeyEvent*) _tmp34_);
			_tmp35_ = a;
			_tmp36_ = _tmp35_->data;
			g_signal_emit_by_name ((SkkKeyEventFilter*) self, "forwarded", (SkkKeyEvent*) _tmp36_);
			_tmp37_ = b;
			_tmp38_ = _tmp37_->data;
			_tmp39_ = _g_object_ref0 ((SkkKeyEvent*) _tmp38_);
			result = _tmp39_;
			_skk_nicola_key_event_filter_timed_entry_unref0 (a);
			_skk_nicola_key_event_filter_timed_entry_unref0 (s);
			_skk_nicola_key_event_filter_timed_entry_unref0 (b);
			return result;
		}
		_skk_nicola_key_event_filter_timed_entry_unref0 (a);
		_skk_nicola_key_event_filter_timed_entry_unref0 (s);
		_skk_nicola_key_event_filter_timed_entry_unref0 (b);
	} else {
		GeeLinkedList* _tmp40_;
		gint _tmp41_;
		gint _tmp42_;
		_tmp40_ = self->priv->pending;
		_tmp41_ = gee_collection_get_size ((GeeCollection*) _tmp40_);
		_tmp42_ = _tmp41_;
		if (_tmp42_ == 2) {
			GeeLinkedList* _tmp43_;
			gpointer _tmp44_ = NULL;
			SkkNicolaKeyEventFilterTimedEntry* b;
			GeeLinkedList* _tmp45_;
			gpointer _tmp46_ = NULL;
			SkkNicolaKeyEventFilterTimedEntry* a;
			SkkNicolaKeyEventFilterTimedEntry* _tmp47_;
			gint64 _tmp48_;
			SkkNicolaKeyEventFilterTimedEntry* _tmp49_;
			gint64 _tmp50_;
			gint64 _tmp51_;
			_tmp43_ = self->priv->pending;
			_tmp44_ = gee_abstract_list_get ((GeeAbstractList*) _tmp43_, 0);
			b = (SkkNicolaKeyEventFilterTimedEntry*) _tmp44_;
			_tmp45_ = self->priv->pending;
			_tmp46_ = gee_abstract_list_get ((GeeAbstractList*) _tmp45_, 1);
			a = (SkkNicolaKeyEventFilterTimedEntry*) _tmp46_;
			_tmp47_ = b;
			_tmp48_ = _tmp47_->time;
			_tmp49_ = a;
			_tmp50_ = _tmp49_->time;
			_tmp51_ = self->overlap;
			if ((_tmp48_ - _tmp50_) > _tmp51_) {
				GeeLinkedList* _tmp52_;
				GeeLinkedList* _tmp53_;
				SkkNicolaKeyEventFilterTimedEntry* _tmp54_;
				gint64 _tmp55_;
				SkkKeyEvent* _tmp56_ = NULL;
				SkkKeyEvent* r;
				SkkNicolaKeyEventFilterTimedEntry* _tmp57_;
				gconstpointer _tmp58_;
				_tmp52_ = self->priv->pending;
				gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp52_);
				_tmp53_ = self->priv->pending;
				_tmp54_ = b;
				gee_deque_offer_head ((GeeDeque*) _tmp53_, _tmp54_);
				_tmp55_ = time;
				_tmp56_ = skk_nicola_key_event_filter_dispatch_single (self, _tmp55_);
				r = _tmp56_;
				_tmp57_ = a;
				_tmp58_ = _tmp57_->data;
				g_signal_emit_by_name ((SkkKeyEventFilter*) self, "forwarded", (SkkKeyEvent*) _tmp58_);
				result = r;
				_skk_nicola_key_event_filter_timed_entry_unref0 (a);
				_skk_nicola_key_event_filter_timed_entry_unref0 (b);
				return result;
			} else {
				gboolean _tmp59_ = FALSE;
				gboolean _tmp60_ = FALSE;
				SkkNicolaKeyEventFilterTimedEntry* _tmp61_;
				gconstpointer _tmp62_;
				gboolean _tmp63_ = FALSE;
				gboolean _tmp67_;
				gboolean _tmp76_;
				_tmp61_ = a;
				_tmp62_ = _tmp61_->data;
				_tmp63_ = skk_nicola_key_event_filter_is_char ((SkkKeyEvent*) _tmp62_);
				if (_tmp63_) {
					SkkNicolaKeyEventFilterTimedEntry* _tmp64_;
					gconstpointer _tmp65_;
					gboolean _tmp66_ = FALSE;
					_tmp64_ = b;
					_tmp65_ = _tmp64_->data;
					_tmp66_ = skk_nicola_key_event_filter_is_char ((SkkKeyEvent*) _tmp65_);
					_tmp60_ = _tmp66_;
				} else {
					_tmp60_ = FALSE;
				}
				_tmp67_ = _tmp60_;
				if (_tmp67_) {
					_tmp59_ = TRUE;
				} else {
					gboolean _tmp68_ = FALSE;
					SkkNicolaKeyEventFilterTimedEntry* _tmp69_;
					gconstpointer _tmp70_;
					gboolean _tmp71_ = FALSE;
					gboolean _tmp75_;
					_tmp69_ = a;
					_tmp70_ = _tmp69_->data;
					_tmp71_ = skk_nicola_key_event_filter_is_shift ((SkkKeyEvent*) _tmp70_);
					if (_tmp71_) {
						SkkNicolaKeyEventFilterTimedEntry* _tmp72_;
						gconstpointer _tmp73_;
						gboolean _tmp74_ = FALSE;
						_tmp72_ = b;
						_tmp73_ = _tmp72_->data;
						_tmp74_ = skk_nicola_key_event_filter_is_shift ((SkkKeyEvent*) _tmp73_);
						_tmp68_ = _tmp74_;
					} else {
						_tmp68_ = FALSE;
					}
					_tmp75_ = _tmp68_;
					_tmp59_ = _tmp75_;
				}
				_tmp76_ = _tmp59_;
				if (_tmp76_) {
					SkkNicolaKeyEventFilterTimedEntry* _tmp77_;
					gconstpointer _tmp78_;
					SkkNicolaKeyEventFilterTimedEntry* _tmp79_;
					gconstpointer _tmp80_;
					gchar* _tmp81_ = NULL;
					gchar* name;
					const gchar* _tmp82_;
					gchar** _tmp83_;
					gint _tmp83__length1;
					_tmp77_ = b;
					_tmp78_ = _tmp77_->data;
					_tmp79_ = a;
					_tmp80_ = _tmp79_->data;
					_tmp81_ = skk_nicola_key_event_filter_get_special_double_name ((SkkKeyEvent*) _tmp78_, (SkkKeyEvent*) _tmp80_);
					name = _tmp81_;
					_tmp82_ = name;
					_tmp83_ = self->special_doubles;
					_tmp83__length1 = self->special_doubles_length1;
					if (_vala_string_array_contains (_tmp83_, _tmp83__length1, _tmp82_)) {
						GeeLinkedList* _tmp84_;
						const gchar* _tmp85_;
						SkkKeyEvent* _tmp86_;
						_tmp84_ = self->priv->pending;
						gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp84_);
						_tmp85_ = name;
						_tmp86_ = skk_key_event_new (_tmp85_, (gunichar) 0, SKK_MODIFIER_TYPE_NONE);
						result = _tmp86_;
						_g_free0 (name);
						_skk_nicola_key_event_filter_timed_entry_unref0 (a);
						_skk_nicola_key_event_filter_timed_entry_unref0 (b);
						return result;
					} else {
						GeeLinkedList* _tmp87_;
						GeeLinkedList* _tmp88_;
						SkkNicolaKeyEventFilterTimedEntry* _tmp89_;
						gint64 _tmp90_;
						SkkKeyEvent* _tmp91_ = NULL;
						SkkKeyEvent* r;
						SkkNicolaKeyEventFilterTimedEntry* _tmp92_;
						gconstpointer _tmp93_;
						_tmp87_ = self->priv->pending;
						gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp87_);
						_tmp88_ = self->priv->pending;
						_tmp89_ = b;
						gee_deque_offer_head ((GeeDeque*) _tmp88_, _tmp89_);
						_tmp90_ = time;
						_tmp91_ = skk_nicola_key_event_filter_dispatch_single (self, _tmp90_);
						r = _tmp91_;
						_tmp92_ = a;
						_tmp93_ = _tmp92_->data;
						g_signal_emit_by_name ((SkkKeyEventFilter*) self, "forwarded", (SkkKeyEvent*) _tmp93_);
						result = r;
						_g_free0 (name);
						_skk_nicola_key_event_filter_timed_entry_unref0 (a);
						_skk_nicola_key_event_filter_timed_entry_unref0 (b);
						return result;
					}
					_g_free0 (name);
				} else {
					gint64 _tmp94_;
					SkkNicolaKeyEventFilterTimedEntry* _tmp95_;
					gint64 _tmp96_;
					gint64 _tmp97_;
					_tmp94_ = time;
					_tmp95_ = a;
					_tmp96_ = _tmp95_->time;
					_tmp97_ = self->timeout;
					if ((_tmp94_ - _tmp96_) > _tmp97_) {
						GeeLinkedList* _tmp98_;
						SkkNicolaKeyEventFilterTimedEntry* _tmp99_;
						gconstpointer _tmp100_;
						gboolean _tmp101_ = FALSE;
						_tmp98_ = self->priv->pending;
						gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp98_);
						_tmp99_ = b;
						_tmp100_ = _tmp99_->data;
						_tmp101_ = skk_nicola_key_event_filter_is_shift ((SkkKeyEvent*) _tmp100_);
						if (_tmp101_) {
							SkkNicolaKeyEventFilterTimedEntry* _tmp102_;
							gconstpointer _tmp103_;
							SkkNicolaKeyEventFilterTimedEntry* _tmp104_;
							gconstpointer _tmp105_;
							SkkNicolaKeyEventFilterTimedEntry* _tmp106_;
							gconstpointer _tmp107_;
							SkkKeyEvent* _tmp108_;
							_tmp102_ = b;
							_tmp103_ = _tmp102_->data;
							_tmp104_ = a;
							_tmp105_ = _tmp104_->data;
							skk_nicola_key_event_filter_apply_shift (self, (SkkKeyEvent*) _tmp103_, (SkkKeyEvent*) _tmp105_);
							_tmp106_ = a;
							_tmp107_ = _tmp106_->data;
							_tmp108_ = _g_object_ref0 ((SkkKeyEvent*) _tmp107_);
							result = _tmp108_;
							_skk_nicola_key_event_filter_timed_entry_unref0 (a);
							_skk_nicola_key_event_filter_timed_entry_unref0 (b);
							return result;
						} else {
							SkkNicolaKeyEventFilterTimedEntry* _tmp109_;
							gconstpointer _tmp110_;
							SkkNicolaKeyEventFilterTimedEntry* _tmp111_;
							gconstpointer _tmp112_;
							SkkNicolaKeyEventFilterTimedEntry* _tmp113_;
							gconstpointer _tmp114_;
							SkkKeyEvent* _tmp115_;
							_tmp109_ = a;
							_tmp110_ = _tmp109_->data;
							_tmp111_ = b;
							_tmp112_ = _tmp111_->data;
							skk_nicola_key_event_filter_apply_shift (self, (SkkKeyEvent*) _tmp110_, (SkkKeyEvent*) _tmp112_);
							_tmp113_ = b;
							_tmp114_ = _tmp113_->data;
							_tmp115_ = _g_object_ref0 ((SkkKeyEvent*) _tmp114_);
							result = _tmp115_;
							_skk_nicola_key_event_filter_timed_entry_unref0 (a);
							_skk_nicola_key_event_filter_timed_entry_unref0 (b);
							return result;
						}
					}
				}
			}
			_skk_nicola_key_event_filter_timed_entry_unref0 (a);
			_skk_nicola_key_event_filter_timed_entry_unref0 (b);
		} else {
			GeeLinkedList* _tmp116_;
			gint _tmp117_;
			gint _tmp118_;
			_tmp116_ = self->priv->pending;
			_tmp117_ = gee_collection_get_size ((GeeCollection*) _tmp116_);
			_tmp118_ = _tmp117_;
			if (_tmp118_ == 1) {
				gint64 _tmp119_;
				SkkKeyEvent* _tmp120_ = NULL;
				_tmp119_ = time;
				_tmp120_ = skk_nicola_key_event_filter_dispatch_single (self, _tmp119_);
				result = _tmp120_;
				return result;
			}
		}
	}
	result = NULL;
	return result;
}


static gboolean skk_nicola_key_event_filter_timeout_func (SkkNicolaKeyEventFilter* self) {
	gboolean result = FALSE;
	SkkGetTime _tmp0_;
	void* _tmp0__target;
	gint64 _tmp1_ = 0LL;
	gint64 time;
	gint64 _tmp2_;
	SkkKeyEvent* _tmp3_ = NULL;
	SkkKeyEvent* r;
	SkkKeyEvent* _tmp4_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->get_time_func;
	_tmp0__target = self->get_time_func_target;
	_tmp1_ = _tmp0_ (_tmp0__target);
	time = _tmp1_;
	_tmp2_ = time;
	_tmp3_ = skk_nicola_key_event_filter_dispatch (self, _tmp2_);
	r = _tmp3_;
	_tmp4_ = r;
	if (_tmp4_ != NULL) {
		SkkKeyEvent* _tmp5_;
		_tmp5_ = r;
		g_signal_emit_by_name ((SkkKeyEventFilter*) self, "forwarded", _tmp5_);
	}
	result = FALSE;
	_g_object_unref0 (r);
	return result;
}


/**
         * {@inheritDoc}
         */
static gboolean _skk_nicola_key_event_filter_timeout_func_gsource_func (gpointer self) {
	gboolean result;
	result = skk_nicola_key_event_filter_timeout_func (self);
	return result;
}


static SkkKeyEvent* skk_nicola_key_event_filter_real_filter_key_event (SkkKeyEventFilter* base, SkkKeyEvent* key) {
	SkkNicolaKeyEventFilter * self;
	SkkKeyEvent* result = NULL;
	SkkKeyEvent* _tmp0_;
	SkkKeyEvent* _tmp1_;
	SkkModifierType _tmp2_;
	SkkModifierType _tmp3_;
	SkkKeyEvent* output;
	gint64 time = 0LL;
	SkkKeyEvent* _tmp4_;
	SkkModifierType _tmp5_;
	SkkModifierType _tmp6_;
	SkkKeyEvent* _tmp46_;
	self = (SkkNicolaKeyEventFilter*) base;
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = key;
	_tmp1_ = key;
	_tmp2_ = skk_key_event_get_modifiers (_tmp1_);
	_tmp3_ = _tmp2_;
	skk_key_event_set_modifiers (_tmp1_, _tmp3_ & (~SKK_MODIFIER_TYPE_SHIFT_MASK));
	output = NULL;
	_tmp4_ = key;
	_tmp5_ = skk_key_event_get_modifiers (_tmp4_);
	_tmp6_ = _tmp5_;
	if ((_tmp6_ & SKK_MODIFIER_TYPE_USLEEP_MASK) != 0) {
		SkkKeyEvent* _tmp7_;
		const gchar* _tmp8_;
		const gchar* _tmp9_;
		gint _tmp10_ = 0;
		SkkGetTime _tmp11_;
		void* _tmp11__target;
		gint64 _tmp12_ = 0LL;
		_tmp7_ = key;
		_tmp8_ = skk_key_event_get_name (_tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = atoi (_tmp9_);
		g_usleep ((gulong) ((glong) _tmp10_));
		_tmp11_ = self->get_time_func;
		_tmp11__target = self->get_time_func_target;
		_tmp12_ = _tmp11_ (_tmp11__target);
		time = _tmp12_;
	} else {
		gboolean _tmp13_ = FALSE;
		SkkKeyEvent* _tmp14_;
		SkkModifierType _tmp15_;
		SkkModifierType _tmp16_;
		gboolean _tmp29_;
		_tmp14_ = key;
		_tmp15_ = skk_key_event_get_modifiers (_tmp14_);
		_tmp16_ = _tmp15_;
		if ((_tmp16_ & (~SKK_MODIFIER_TYPE_RELEASE_MASK)) == 0) {
			gboolean _tmp17_ = FALSE;
			SkkKeyEvent* _tmp18_;
			gboolean _tmp19_ = FALSE;
			gboolean _tmp28_;
			_tmp18_ = key;
			_tmp19_ = skk_nicola_key_event_filter_is_shift (_tmp18_);
			if (_tmp19_) {
				_tmp17_ = TRUE;
			} else {
				gboolean _tmp20_ = FALSE;
				SkkKeyEvent* _tmp21_;
				gunichar _tmp22_;
				gunichar _tmp23_;
				gboolean _tmp27_;
				_tmp21_ = key;
				_tmp22_ = skk_key_event_get_code (_tmp21_);
				_tmp23_ = _tmp22_;
				if (((gunichar) 0x20) <= _tmp23_) {
					SkkKeyEvent* _tmp24_;
					gunichar _tmp25_;
					gunichar _tmp26_;
					_tmp24_ = key;
					_tmp25_ = skk_key_event_get_code (_tmp24_);
					_tmp26_ = _tmp25_;
					_tmp20_ = _tmp26_ <= ((gunichar) 0x7E);
				} else {
					_tmp20_ = FALSE;
				}
				_tmp27_ = _tmp20_;
				_tmp17_ = _tmp27_;
			}
			_tmp28_ = _tmp17_;
			_tmp13_ = _tmp28_;
		} else {
			_tmp13_ = FALSE;
		}
		_tmp29_ = _tmp13_;
		if (_tmp29_) {
			SkkGetTime _tmp30_;
			void* _tmp30__target;
			gint64 _tmp31_ = 0LL;
			gint64 wait = 0LL;
			SkkKeyEvent* _tmp32_;
			gint64 _tmp33_;
			gint64 _tmp34_ = 0LL;
			SkkKeyEvent* _tmp35_ = NULL;
			gint64 _tmp36_;
			_tmp30_ = self->get_time_func;
			_tmp30__target = self->get_time_func_target;
			_tmp31_ = _tmp30_ (_tmp30__target);
			time = _tmp31_;
			_tmp32_ = key;
			_tmp33_ = time;
			_tmp35_ = skk_nicola_key_event_filter_queue (self, _tmp32_, _tmp33_, &_tmp34_);
			wait = _tmp34_;
			_g_object_unref0 (output);
			output = _tmp35_;
			_tmp36_ = wait;
			if (_tmp36_ > ((gint64) 0)) {
				guint _tmp37_;
				gint64 _tmp39_;
				guint _tmp40_ = 0U;
				_tmp37_ = self->priv->timeout_id;
				if (_tmp37_ > ((guint) 0)) {
					guint _tmp38_;
					_tmp38_ = self->priv->timeout_id;
					g_source_remove (_tmp38_);
				}
				_tmp39_ = wait;
				_tmp40_ = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) _tmp39_, _skk_nicola_key_event_filter_timeout_func_gsource_func, g_object_ref (self), g_object_unref);
				self->priv->timeout_id = _tmp40_;
			}
		} else {
			SkkKeyEvent* _tmp41_;
			SkkModifierType _tmp42_;
			SkkModifierType _tmp43_;
			_tmp41_ = key;
			_tmp42_ = skk_key_event_get_modifiers (_tmp41_);
			_tmp43_ = _tmp42_;
			if ((_tmp43_ & SKK_MODIFIER_TYPE_RELEASE_MASK) == 0) {
				SkkKeyEvent* _tmp44_;
				SkkKeyEvent* _tmp45_;
				_tmp44_ = key;
				_tmp45_ = _g_object_ref0 (_tmp44_);
				result = _tmp45_;
				_g_object_unref0 (output);
				return result;
			}
			result = NULL;
			_g_object_unref0 (output);
			return result;
		}
	}
	_tmp46_ = output;
	if (_tmp46_ == NULL) {
		gint64 _tmp47_;
		SkkKeyEvent* _tmp48_ = NULL;
		_tmp47_ = time;
		_tmp48_ = skk_nicola_key_event_filter_dispatch (self, _tmp47_);
		_g_object_unref0 (output);
		output = _tmp48_;
	}
	result = output;
	return result;
}


/**
         * {@inheritDoc}
         */
static void skk_nicola_key_event_filter_real_reset (SkkKeyEventFilter* base) {
	SkkNicolaKeyEventFilter * self;
	GeeLinkedList* _tmp0_;
	self = (SkkNicolaKeyEventFilter*) base;
	_tmp0_ = self->priv->pending;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp0_);
}


SkkNicolaKeyEventFilter* skk_nicola_key_event_filter_construct (GType object_type) {
	SkkNicolaKeyEventFilter * self = NULL;
	self = (SkkNicolaKeyEventFilter*) skk_key_event_filter_construct (object_type);
	return self;
}


SkkNicolaKeyEventFilter* skk_nicola_key_event_filter_new (void) {
	return skk_nicola_key_event_filter_construct (SKK_TYPE_NICOLA_KEY_EVENT_FILTER);
}


static gchar** _vala_array_dup5 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static GObject * skk_nicola_key_event_filter_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	SkkNicolaKeyEventFilter * self;
	gchar** _tmp0_;
	gint _tmp0__length1;
	parent_class = G_OBJECT_CLASS (skk_nicola_key_event_filter_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = SKK_NICOLA_KEY_EVENT_FILTER (obj);
	_tmp0_ = (SKK_NICOLA_KEY_EVENT_FILTER_SPECIAL_DOUBLES != NULL) ? _vala_array_dup5 (SKK_NICOLA_KEY_EVENT_FILTER_SPECIAL_DOUBLES, G_N_ELEMENTS (SKK_NICOLA_KEY_EVENT_FILTER_SPECIAL_DOUBLES)) : ((gpointer) SKK_NICOLA_KEY_EVENT_FILTER_SPECIAL_DOUBLES);
	_tmp0__length1 = G_N_ELEMENTS (SKK_NICOLA_KEY_EVENT_FILTER_SPECIAL_DOUBLES);
	self->special_doubles = (_vala_array_free (self->special_doubles, self->special_doubles_length1, (GDestroyNotify) g_free), NULL);
	self->special_doubles = _tmp0_;
	self->special_doubles_length1 = _tmp0__length1;
	return obj;
}


static SkkNicolaKeyEventFilterTimedEntry* skk_nicola_key_event_filter_timed_entry_construct (GType object_type, GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer data, gint64 time) {
	SkkNicolaKeyEventFilterTimedEntry* self = NULL;
	gconstpointer _tmp0_;
	gpointer _tmp1_;
	gint64 _tmp2_;
	self = (SkkNicolaKeyEventFilterTimedEntry*) g_type_create_instance (object_type);
	self->priv->t_type = t_type;
	self->priv->t_dup_func = t_dup_func;
	self->priv->t_destroy_func = t_destroy_func;
	_tmp0_ = data;
	_tmp1_ = ((_tmp0_ != NULL) && (t_dup_func != NULL)) ? t_dup_func ((gpointer) _tmp0_) : ((gpointer) _tmp0_);
	_t_destroy_func0 (self->data);
	self->data = _tmp1_;
	_tmp2_ = time;
	self->time = _tmp2_;
	return self;
}


static SkkNicolaKeyEventFilterTimedEntry* skk_nicola_key_event_filter_timed_entry_new (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer data, gint64 time) {
	return skk_nicola_key_event_filter_timed_entry_construct (SKK_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY, t_type, t_dup_func, t_destroy_func, data, time);
}


static void skk_nicola_key_event_filter_value_timed_entry_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void skk_nicola_key_event_filter_value_timed_entry_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		skk_nicola_key_event_filter_timed_entry_unref (value->data[0].v_pointer);
	}
}


static void skk_nicola_key_event_filter_value_timed_entry_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = skk_nicola_key_event_filter_timed_entry_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer skk_nicola_key_event_filter_value_timed_entry_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* skk_nicola_key_event_filter_value_timed_entry_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SkkNicolaKeyEventFilterTimedEntry* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = skk_nicola_key_event_filter_timed_entry_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* skk_nicola_key_event_filter_value_timed_entry_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SkkNicolaKeyEventFilterTimedEntry** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = skk_nicola_key_event_filter_timed_entry_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* skk_nicola_key_event_filter_param_spec_timed_entry (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	SkkNicolaKeyEventFilterParamSpecTimedEntry* spec;
	g_return_val_if_fail (g_type_is_a (object_type, SKK_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer skk_nicola_key_event_filter_value_get_timed_entry (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SKK_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY), NULL);
	return value->data[0].v_pointer;
}


static void skk_nicola_key_event_filter_value_set_timed_entry (GValue* value, gpointer v_object) {
	SkkNicolaKeyEventFilterTimedEntry* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SKK_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SKK_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		skk_nicola_key_event_filter_timed_entry_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		skk_nicola_key_event_filter_timed_entry_unref (old);
	}
}


static void skk_nicola_key_event_filter_value_take_timed_entry (GValue* value, gpointer v_object) {
	SkkNicolaKeyEventFilterTimedEntry* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SKK_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SKK_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		skk_nicola_key_event_filter_timed_entry_unref (old);
	}
}


static void skk_nicola_key_event_filter_timed_entry_class_init (SkkNicolaKeyEventFilterTimedEntryClass * klass) {
	skk_nicola_key_event_filter_timed_entry_parent_class = g_type_class_peek_parent (klass);
	SKK_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY_CLASS (klass)->finalize = skk_nicola_key_event_filter_timed_entry_finalize;
	g_type_class_add_private (klass, sizeof (SkkNicolaKeyEventFilterTimedEntryPrivate));
}


static void skk_nicola_key_event_filter_timed_entry_instance_init (SkkNicolaKeyEventFilterTimedEntry * self) {
	self->priv = SKK_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void skk_nicola_key_event_filter_timed_entry_finalize (SkkNicolaKeyEventFilterTimedEntry* obj) {
	SkkNicolaKeyEventFilterTimedEntry * self;
	self = SKK_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY (obj);
	((self->data == NULL) || (self->priv->t_destroy_func == NULL)) ? NULL : (self->data = (self->priv->t_destroy_func (self->data), NULL));
}


static GType skk_nicola_key_event_filter_timed_entry_get_type (void) {
	static volatile gsize skk_nicola_key_event_filter_timed_entry_type_id__volatile = 0;
	if (g_once_init_enter (&skk_nicola_key_event_filter_timed_entry_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { skk_nicola_key_event_filter_value_timed_entry_init, skk_nicola_key_event_filter_value_timed_entry_free_value, skk_nicola_key_event_filter_value_timed_entry_copy_value, skk_nicola_key_event_filter_value_timed_entry_peek_pointer, "p", skk_nicola_key_event_filter_value_timed_entry_collect_value, "p", skk_nicola_key_event_filter_value_timed_entry_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SkkNicolaKeyEventFilterTimedEntryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) skk_nicola_key_event_filter_timed_entry_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SkkNicolaKeyEventFilterTimedEntry), 0, (GInstanceInitFunc) skk_nicola_key_event_filter_timed_entry_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType skk_nicola_key_event_filter_timed_entry_type_id;
		skk_nicola_key_event_filter_timed_entry_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SkkNicolaKeyEventFilterTimedEntry", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&skk_nicola_key_event_filter_timed_entry_type_id__volatile, skk_nicola_key_event_filter_timed_entry_type_id);
	}
	return skk_nicola_key_event_filter_timed_entry_type_id__volatile;
}


static gpointer skk_nicola_key_event_filter_timed_entry_ref (gpointer instance) {
	SkkNicolaKeyEventFilterTimedEntry* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void skk_nicola_key_event_filter_timed_entry_unref (gpointer instance) {
	SkkNicolaKeyEventFilterTimedEntry* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SKK_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void skk_nicola_key_event_filter_class_init (SkkNicolaKeyEventFilterClass * klass) {
	skk_nicola_key_event_filter_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SkkNicolaKeyEventFilterPrivate));
	SKK_KEY_EVENT_FILTER_CLASS (klass)->filter_key_event = skk_nicola_key_event_filter_real_filter_key_event;
	SKK_KEY_EVENT_FILTER_CLASS (klass)->reset = skk_nicola_key_event_filter_real_reset;
	G_OBJECT_CLASS (klass)->constructor = skk_nicola_key_event_filter_constructor;
	G_OBJECT_CLASS (klass)->finalize = skk_nicola_key_event_filter_finalize;
}


static void skk_nicola_key_event_filter_instance_init (SkkNicolaKeyEventFilter * self) {
	GeeLinkedList* _tmp0_;
	self->priv = SKK_NICOLA_KEY_EVENT_FILTER_GET_PRIVATE (self);
	self->get_time_func = _skk_nicola_key_event_filter_get_time_skk_get_time;
	self->timeout = (gint64) 100000;
	self->overlap = (gint64) 50000;
	self->maxwait = (gint64) 10000000;
	_tmp0_ = gee_linked_list_new (SKK_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY, (GBoxedCopyFunc) skk_nicola_key_event_filter_timed_entry_ref, skk_nicola_key_event_filter_timed_entry_unref, NULL);
	self->priv->pending = _tmp0_;
	self->priv->timeout_id = (guint) 0;
}


static void skk_nicola_key_event_filter_finalize (GObject* obj) {
	SkkNicolaKeyEventFilter * self;
	self = SKK_NICOLA_KEY_EVENT_FILTER (obj);
	(self->get_time_func_target_destroy_notify == NULL) ? NULL : (self->get_time_func_target_destroy_notify (self->get_time_func_target), NULL);
	self->get_time_func = NULL;
	self->get_time_func_target = NULL;
	self->get_time_func_target_destroy_notify = NULL;
	self->special_doubles = (_vala_array_free (self->special_doubles, self->special_doubles_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (self->priv->pending);
	G_OBJECT_CLASS (skk_nicola_key_event_filter_parent_class)->finalize (obj);
}


/**
     * Key event filter implementing NICOLA (thumb shift) input
     *
     * This class is rarely used in programs but specified as "filter"
     * property in rule metadata.
     *
     * @see Rule
     */
GType skk_nicola_key_event_filter_get_type (void) {
	static volatile gsize skk_nicola_key_event_filter_type_id__volatile = 0;
	if (g_once_init_enter (&skk_nicola_key_event_filter_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SkkNicolaKeyEventFilterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) skk_nicola_key_event_filter_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SkkNicolaKeyEventFilter), 0, (GInstanceInitFunc) skk_nicola_key_event_filter_instance_init, NULL };
		GType skk_nicola_key_event_filter_type_id;
		skk_nicola_key_event_filter_type_id = g_type_register_static (SKK_TYPE_KEY_EVENT_FILTER, "SkkNicolaKeyEventFilter", &g_define_type_info, 0);
		g_once_init_leave (&skk_nicola_key_event_filter_type_id__volatile, skk_nicola_key_event_filter_type_id);
	}
	return skk_nicola_key_event_filter_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



