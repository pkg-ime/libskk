/* context.c generated by valac 0.14.0, the Vala compiler
 * generated from context.vala, do not modify */

/*
 * Copyright (C) 2011 Daiki Ueno <ueno@unixuser.org>
 * Copyright (C) 2011 Red Hat, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>


#define SKK_TYPE_UTIL (skk_util_get_type ())
#define SKK_UTIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_UTIL, SkkUtil))
#define SKK_UTIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_UTIL, SkkUtilClass))
#define SKK_IS_UTIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_UTIL))
#define SKK_IS_UTIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_UTIL))
#define SKK_UTIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_UTIL, SkkUtilClass))

typedef struct _SkkUtil SkkUtil;
typedef struct _SkkUtilClass SkkUtilClass;
#define _g_type_class_unref0(var) ((var == NULL) ? NULL : (var = (g_type_class_unref (var), NULL)))

#define SKK_TYPE_RULE (skk_rule_get_type ())
#define SKK_RULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_RULE, SkkRule))
#define SKK_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_RULE, SkkRuleClass))
#define SKK_IS_RULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_RULE))
#define SKK_IS_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_RULE))
#define SKK_RULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_RULE, SkkRuleClass))

typedef struct _SkkRule SkkRule;
typedef struct _SkkRuleClass SkkRuleClass;

#define SKK_TYPE_KANA_MODE (skk_kana_mode_get_type ())

#define SKK_TYPE_INPUT_MODE (skk_input_mode_get_type ())

#define SKK_TYPE_CONTEXT (skk_context_get_type ())
#define SKK_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_CONTEXT, SkkContext))
#define SKK_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_CONTEXT, SkkContextClass))
#define SKK_IS_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_CONTEXT))
#define SKK_IS_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_CONTEXT))
#define SKK_CONTEXT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_CONTEXT, SkkContextClass))

typedef struct _SkkContext SkkContext;
typedef struct _SkkContextClass SkkContextClass;
typedef struct _SkkContextPrivate SkkContextPrivate;

#define SKK_TYPE_DICT (skk_dict_get_type ())
#define SKK_DICT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_DICT, SkkDict))
#define SKK_DICT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_DICT, SkkDictClass))
#define SKK_IS_DICT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_DICT))
#define SKK_IS_DICT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_DICT))
#define SKK_DICT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_DICT, SkkDictClass))

typedef struct _SkkDict SkkDict;
typedef struct _SkkDictClass SkkDictClass;

#define SKK_TYPE_STATE (skk_state_get_type ())
#define SKK_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_STATE, SkkState))
#define SKK_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_STATE, SkkStateClass))
#define SKK_IS_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_STATE))
#define SKK_IS_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_STATE))
#define SKK_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_STATE, SkkStateClass))

typedef struct _SkkState SkkState;
typedef struct _SkkStateClass SkkStateClass;

#define SKK_TYPE_STATE_HANDLER (skk_state_handler_get_type ())
#define SKK_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_STATE_HANDLER, SkkStateHandler))
#define SKK_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_STATE_HANDLER, SkkStateHandlerClass))
#define SKK_IS_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_STATE_HANDLER))
#define SKK_IS_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_STATE_HANDLER))
#define SKK_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_STATE_HANDLER, SkkStateHandlerClass))

typedef struct _SkkStateHandler SkkStateHandler;
typedef struct _SkkStateHandlerClass SkkStateHandlerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_slist_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_slist_free__g_object_unref0_ (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define SKK_TYPE_NONE_STATE_HANDLER (skk_none_state_handler_get_type ())
#define SKK_NONE_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_NONE_STATE_HANDLER, SkkNoneStateHandler))
#define SKK_NONE_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_NONE_STATE_HANDLER, SkkNoneStateHandlerClass))
#define SKK_IS_NONE_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_NONE_STATE_HANDLER))
#define SKK_IS_NONE_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_NONE_STATE_HANDLER))
#define SKK_NONE_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_NONE_STATE_HANDLER, SkkNoneStateHandlerClass))

typedef struct _SkkNoneStateHandler SkkNoneStateHandler;
typedef struct _SkkNoneStateHandlerClass SkkNoneStateHandlerClass;

#define SKK_TYPE_START_STATE_HANDLER (skk_start_state_handler_get_type ())
#define SKK_START_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_START_STATE_HANDLER, SkkStartStateHandler))
#define SKK_START_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_START_STATE_HANDLER, SkkStartStateHandlerClass))
#define SKK_IS_START_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_START_STATE_HANDLER))
#define SKK_IS_START_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_START_STATE_HANDLER))
#define SKK_START_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_START_STATE_HANDLER, SkkStartStateHandlerClass))

typedef struct _SkkStartStateHandler SkkStartStateHandler;
typedef struct _SkkStartStateHandlerClass SkkStartStateHandlerClass;

#define SKK_TYPE_SELECT_STATE_HANDLER (skk_select_state_handler_get_type ())
#define SKK_SELECT_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_SELECT_STATE_HANDLER, SkkSelectStateHandler))
#define SKK_SELECT_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_SELECT_STATE_HANDLER, SkkSelectStateHandlerClass))
#define SKK_IS_SELECT_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_SELECT_STATE_HANDLER))
#define SKK_IS_SELECT_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_SELECT_STATE_HANDLER))
#define SKK_SELECT_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_SELECT_STATE_HANDLER, SkkSelectStateHandlerClass))

typedef struct _SkkSelectStateHandler SkkSelectStateHandler;
typedef struct _SkkSelectStateHandlerClass SkkSelectStateHandlerClass;

#define SKK_TYPE_ABBREV_STATE_HANDLER (skk_abbrev_state_handler_get_type ())
#define SKK_ABBREV_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_ABBREV_STATE_HANDLER, SkkAbbrevStateHandler))
#define SKK_ABBREV_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_ABBREV_STATE_HANDLER, SkkAbbrevStateHandlerClass))
#define SKK_IS_ABBREV_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_ABBREV_STATE_HANDLER))
#define SKK_IS_ABBREV_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_ABBREV_STATE_HANDLER))
#define SKK_ABBREV_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_ABBREV_STATE_HANDLER, SkkAbbrevStateHandlerClass))

typedef struct _SkkAbbrevStateHandler SkkAbbrevStateHandler;
typedef struct _SkkAbbrevStateHandlerClass SkkAbbrevStateHandlerClass;

#define SKK_TYPE_KUTEN_STATE_HANDLER (skk_kuten_state_handler_get_type ())
#define SKK_KUTEN_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_KUTEN_STATE_HANDLER, SkkKutenStateHandler))
#define SKK_KUTEN_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_KUTEN_STATE_HANDLER, SkkKutenStateHandlerClass))
#define SKK_IS_KUTEN_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_KUTEN_STATE_HANDLER))
#define SKK_IS_KUTEN_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_KUTEN_STATE_HANDLER))
#define SKK_KUTEN_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_KUTEN_STATE_HANDLER, SkkKutenStateHandlerClass))

typedef struct _SkkKutenStateHandler SkkKutenStateHandler;
typedef struct _SkkKutenStateHandlerClass SkkKutenStateHandlerClass;

#define SKK_TYPE_CANDIDATE_LIST (skk_candidate_list_get_type ())
#define SKK_CANDIDATE_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_CANDIDATE_LIST, SkkCandidateList))
#define SKK_CANDIDATE_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_CANDIDATE_LIST, SkkCandidateListClass))
#define SKK_IS_CANDIDATE_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_CANDIDATE_LIST))
#define SKK_IS_CANDIDATE_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_CANDIDATE_LIST))
#define SKK_CANDIDATE_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_CANDIDATE_LIST, SkkCandidateListClass))

typedef struct _SkkCandidateList SkkCandidateList;
typedef struct _SkkCandidateListClass SkkCandidateListClass;

#define SKK_TYPE_CANDIDATE (skk_candidate_get_type ())
#define SKK_CANDIDATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_CANDIDATE, SkkCandidate))
#define SKK_CANDIDATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_CANDIDATE, SkkCandidateClass))
#define SKK_IS_CANDIDATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_CANDIDATE))
#define SKK_IS_CANDIDATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_CANDIDATE))
#define SKK_CANDIDATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_CANDIDATE, SkkCandidateClass))

typedef struct _SkkCandidate SkkCandidate;
typedef struct _SkkCandidateClass SkkCandidateClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _SkkStatePrivate SkkStatePrivate;

#define SKK_TYPE_ROM_KANA_CONVERTER (skk_rom_kana_converter_get_type ())
#define SKK_ROM_KANA_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_ROM_KANA_CONVERTER, SkkRomKanaConverter))
#define SKK_ROM_KANA_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_ROM_KANA_CONVERTER, SkkRomKanaConverterClass))
#define SKK_IS_ROM_KANA_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_ROM_KANA_CONVERTER))
#define SKK_IS_ROM_KANA_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_ROM_KANA_CONVERTER))
#define SKK_ROM_KANA_CONVERTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_ROM_KANA_CONVERTER, SkkRomKanaConverterClass))

typedef struct _SkkRomKanaConverter SkkRomKanaConverter;
typedef struct _SkkRomKanaConverterClass SkkRomKanaConverterClass;

#define SKK_TYPE_UNICODE_STRING (skk_unicode_string_get_type ())
#define SKK_UNICODE_STRING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_UNICODE_STRING, SkkUnicodeString))
#define SKK_UNICODE_STRING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_UNICODE_STRING, SkkUnicodeStringClass))
#define SKK_IS_UNICODE_STRING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_UNICODE_STRING))
#define SKK_IS_UNICODE_STRING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_UNICODE_STRING))
#define SKK_UNICODE_STRING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_UNICODE_STRING, SkkUnicodeStringClass))

typedef struct _SkkUnicodeString SkkUnicodeString;
typedef struct _SkkUnicodeStringClass SkkUnicodeStringClass;
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

#define SKK_TYPE_KEY_EVENT (skk_key_event_get_type ())
#define SKK_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_KEY_EVENT, SkkKeyEvent))
#define SKK_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_KEY_EVENT, SkkKeyEventClass))
#define SKK_IS_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_KEY_EVENT))
#define SKK_IS_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_KEY_EVENT))
#define SKK_KEY_EVENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_KEY_EVENT, SkkKeyEventClass))

typedef struct _SkkKeyEvent SkkKeyEvent;
typedef struct _SkkKeyEventClass SkkKeyEventClass;
#define _skk_key_event_unref0(var) ((var == NULL) ? NULL : (var = (skk_key_event_unref (var), NULL)))

#define SKK_TYPE_KEY_EVENT_FILTER (skk_key_event_filter_get_type ())
#define SKK_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_KEY_EVENT_FILTER, SkkKeyEventFilter))
#define SKK_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_KEY_EVENT_FILTER, SkkKeyEventFilterClass))
#define SKK_IS_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_KEY_EVENT_FILTER))
#define SKK_IS_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_KEY_EVENT_FILTER))
#define SKK_KEY_EVENT_FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_KEY_EVENT_FILTER, SkkKeyEventFilterClass))

typedef struct _SkkKeyEventFilter SkkKeyEventFilter;
typedef struct _SkkKeyEventFilterClass SkkKeyEventFilterClass;

#define SKK_TYPE_PERIOD_STYLE (skk_period_style_get_type ())

typedef enum  {
	SKK_KANA_MODE_HIRAGANA,
	SKK_KANA_MODE_KATAKANA,
	SKK_KANA_MODE_HANKAKU_KATAKANA
} SkkKanaMode;

typedef enum  {
	SKK_INPUT_MODE_HIRAGANA = SKK_KANA_MODE_HIRAGANA,
	SKK_INPUT_MODE_KATAKANA = SKK_KANA_MODE_KATAKANA,
	SKK_INPUT_MODE_HANKAKU_KATAKANA = SKK_KANA_MODE_HANKAKU_KATAKANA,
	SKK_INPUT_MODE_LATIN,
	SKK_INPUT_MODE_WIDE_LATIN,
	SKK_INPUT_MODE_LAST,
	SKK_INPUT_MODE_DEFAULT = SKK_INPUT_MODE_HIRAGANA
} SkkInputMode;

struct _SkkContext {
	GObject parent_instance;
	SkkContextPrivate * priv;
};

struct _SkkContextClass {
	GObjectClass parent_class;
};

struct _SkkContextPrivate {
	GeeArrayList* _dictionaries;
	GSList* state_stack;
	GeeHashMap* handlers;
	gchar* _preedit;
	guint preedit_underline_offset;
	guint preedit_underline_nchars;
};

struct _SkkState {
	GObject parent_instance;
	SkkStatePrivate * priv;
	GType handler_type;
	GeeArrayList* dictionaries;
	SkkCandidateList* candidates;
	SkkRomKanaConverter* rom_kana_converter;
	SkkRomKanaConverter* okuri_rom_kana_converter;
	gboolean okuri;
	gchar* midasi;
	GString* output;
	GString* abbrev;
	GString* kuten;
	GeeIterator* completion_iterator;
	gchar** auto_start_henkan_keywords;
	gint auto_start_henkan_keywords_length1;
	gint _auto_start_henkan_keywords_size_;
	gchar* auto_start_henkan_keyword;
	gboolean egg_like_newline;
	SkkUnicodeString* surrounding_text;
	guint surrounding_end;
};

struct _SkkStateClass {
	GObjectClass parent_class;
};

typedef enum  {
	SKK_PERIOD_STYLE_JA_JA,
	SKK_PERIOD_STYLE_EN_EN,
	SKK_PERIOD_STYLE_JA_EN,
	SKK_PERIOD_STYLE_EN_JA
} SkkPeriodStyle;


static gpointer skk_context_parent_class = NULL;

void skk_init (void);
GType skk_util_get_type (void) G_GNUC_CONST;
GType skk_rule_get_type (void) G_GNUC_CONST;
GType skk_kana_mode_get_type (void) G_GNUC_CONST;
GType skk_input_mode_get_type (void) G_GNUC_CONST;
GType skk_context_get_type (void) G_GNUC_CONST;
GType skk_dict_get_type (void) G_GNUC_CONST;
GType skk_state_get_type (void) G_GNUC_CONST;
GType skk_state_handler_get_type (void) G_GNUC_CONST;
#define SKK_CONTEXT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SKK_TYPE_CONTEXT, SkkContextPrivate))
enum  {
	SKK_CONTEXT_DUMMY_PROPERTY,
	SKK_CONTEXT_CANDIDATES,
	SKK_CONTEXT_INPUT_MODE,
	SKK_CONTEXT_AUTO_START_HENKAN_KEYWORDS,
	SKK_CONTEXT_EGG_LIKE_NEWLINE,
	SKK_CONTEXT_PERIOD_STYLE,
	SKK_CONTEXT_TYPING_RULE,
	SKK_CONTEXT_KEY_EVENT_FILTER,
	SKK_CONTEXT_PREEDIT
};
static void _g_object_unref0_ (gpointer var);
static void _g_slist_free__g_object_unref0_ (GSList* self);
SkkContext* skk_context_new (SkkDict** dictionaries, int dictionaries_length1);
SkkContext* skk_context_construct (GType object_type, SkkDict** dictionaries, int dictionaries_length1);
void skk_context_set_dictionaries (SkkContext* self, SkkDict** value, int value_length1);
GType skk_none_state_handler_get_type (void) G_GNUC_CONST;
SkkNoneStateHandler* skk_none_state_handler_new (void);
SkkNoneStateHandler* skk_none_state_handler_construct (GType object_type);
GType skk_start_state_handler_get_type (void) G_GNUC_CONST;
SkkStartStateHandler* skk_start_state_handler_new (void);
SkkStartStateHandler* skk_start_state_handler_construct (GType object_type);
GType skk_select_state_handler_get_type (void) G_GNUC_CONST;
SkkSelectStateHandler* skk_select_state_handler_new (void);
SkkSelectStateHandler* skk_select_state_handler_construct (GType object_type);
GType skk_abbrev_state_handler_get_type (void) G_GNUC_CONST;
SkkAbbrevStateHandler* skk_abbrev_state_handler_new (void);
SkkAbbrevStateHandler* skk_abbrev_state_handler_construct (GType object_type);
GType skk_kuten_state_handler_get_type (void) G_GNUC_CONST;
SkkKutenStateHandler* skk_kuten_state_handler_new (void);
SkkKutenStateHandler* skk_kuten_state_handler_construct (GType object_type);
SkkState* skk_state_new (GeeArrayList* dictionaries);
SkkState* skk_state_construct (GType object_type, GeeArrayList* dictionaries);
static void skk_context_connect_state_signals (SkkContext* self, SkkState* state);
GType skk_candidate_list_get_type (void) G_GNUC_CONST;
SkkCandidateList* skk_context_get_candidates (SkkContext* self);
static void __lambda6_ (SkkContext* self);
gint skk_candidate_list_get_cursor_pos (SkkCandidateList* self);
static void skk_context_update_preedit (SkkContext* self);
static void ___lambda6__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
GType skk_candidate_get_type (void) G_GNUC_CONST;
static void __lambda7_ (SkkContext* self, SkkCandidate* candidate);
static gboolean skk_context_select_candidate_in_dictionaries (SkkContext* self, SkkCandidate* candidate);
void skk_context_save_dictionaries (SkkContext* self, GError** error);
static void ___lambda7__skk_candidate_list_selected (SkkCandidateList* _sender, SkkCandidate* candidate, gpointer self);
static void skk_context_start_dict_edit (SkkContext* self, const gchar* midasi, gboolean okuri);
static void _skk_context_start_dict_edit_skk_state_recursive_edit_start (SkkState* _sender, const gchar* midasi, gboolean okuri, gpointer self);
static gboolean skk_context_end_dict_edit (SkkContext* self, const gchar* text);
static gboolean _skk_context_end_dict_edit_skk_state_recursive_edit_end (SkkState* _sender, const gchar* text, gpointer self);
static gboolean skk_context_abort_dict_edit (SkkContext* self);
static gboolean _skk_context_abort_dict_edit_skk_state_recursive_edit_abort (SkkState* _sender, gpointer self);
static void __lambda3_ (SkkContext* self, GObject* s, GParamSpec* p);
static void ___lambda3__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static gboolean __lambda4_ (SkkContext* self, gchar** t, guint* c);
static gboolean ___lambda4__skk_state_retrieve_surrounding_text (SkkState* _sender, gchar** text, guint* cursor_pos, gpointer self);
static gboolean __lambda5_ (SkkContext* self, gint o, guint n);
static gboolean ___lambda5__skk_state_delete_surrounding_text (SkkState* _sender, gint offset, guint nchars, gpointer self);
SkkDict** skk_context_get_dictionaries (SkkContext* self, int* result_length1);
gboolean skk_dict_get_read_only (SkkDict* self);
gboolean skk_dict_select_candidate (SkkDict* self, SkkCandidate* candidate);
static guint skk_context_dict_edit_level (SkkContext* self);
GType skk_rom_kana_converter_get_type (void) G_GNUC_CONST;
GType skk_unicode_string_get_type (void) G_GNUC_CONST;
static gboolean skk_context_leave_dict_edit (SkkContext* self, gchar** midasi, gboolean** okuri);
SkkCandidate* skk_candidate_new (const gchar* midasi, gboolean okuri, const gchar* text, const gchar* annotation, const gchar* output);
SkkCandidate* skk_candidate_construct (GType object_type, const gchar* midasi, gboolean okuri, const gchar* text, const gchar* annotation, const gchar* output);
void skk_state_reset (SkkState* self);
static gboolean* _bool_dup (gboolean* self);
void skk_state_cancel_okuri (SkkState* self);
gboolean skk_context_process_key_events (SkkContext* self, const gchar* keyseq);
SkkKeyEvent* skk_key_event_new_from_string (const gchar* key);
SkkKeyEvent* skk_key_event_construct_from_string (GType object_type, const gchar* key);
gpointer skk_key_event_ref (gpointer instance);
void skk_key_event_unref (gpointer instance);
GParamSpec* skk_param_spec_key_event (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void skk_value_set_key_event (GValue* value, gpointer v_object);
void skk_value_take_key_event (GValue* value, gpointer v_object);
gpointer skk_value_get_key_event (const GValue* value);
GType skk_key_event_get_type (void) G_GNUC_CONST;
gboolean skk_context_process_key_event (SkkContext* self, SkkKeyEvent* key);
GType skk_key_event_filter_get_type (void) G_GNUC_CONST;
SkkKeyEventFilter* skk_context_get_key_event_filter (SkkContext* self);
SkkKeyEvent* skk_key_event_filter_filter_key_event (SkkKeyEventFilter* self, SkkKeyEvent* key);
static gboolean skk_context_process_key_event_internal (SkkContext* self, SkkKeyEvent* key);
SkkKeyEvent* skk_key_event_copy (SkkKeyEvent* self);
gboolean skk_state_handler_process_key_event (SkkStateHandler* self, SkkState* state, SkkKeyEvent** key);
void skk_context_reset (SkkContext* self);
void skk_state_output_surrounding_text (SkkState* self);
gchar* skk_context_get_output (SkkContext* self);
gchar* skk_context_poll_output (SkkContext* self);
static gchar* skk_context_retrieve_output (SkkContext* self, gboolean clear);
gchar* skk_state_handler_get_output (SkkStateHandler* self, SkkState* state);
gchar* skk_context_peek_output (SkkContext* self);
void skk_context_clear_output (SkkContext* self);
gchar* skk_state_handler_get_preedit (SkkStateHandler* self, SkkState* state, guint* underline_offset, guint* underline_nchars);
const gchar* skk_context_get_preedit (SkkContext* self);
static void skk_context_set_preedit (SkkContext* self, const gchar* value);
void skk_context_get_preedit_underline (SkkContext* self, guint* offset, guint* nchars);
void skk_dict_save (SkkDict* self, GError** error);
SkkInputMode skk_context_get_input_mode (SkkContext* self);
SkkInputMode skk_state_get_input_mode (SkkState* self);
void skk_context_set_input_mode (SkkContext* self, SkkInputMode value);
void skk_state_set_input_mode (SkkState* self, SkkInputMode value);
gchar** skk_context_get_auto_start_henkan_keywords (SkkContext* self, int* result_length1);
void skk_context_set_auto_start_henkan_keywords (SkkContext* self, gchar** value, int value_length1);
static gchar** _vala_array_dup3 (gchar** self, int length);
gboolean skk_context_get_egg_like_newline (SkkContext* self);
void skk_context_set_egg_like_newline (SkkContext* self, gboolean value);
GType skk_period_style_get_type (void) G_GNUC_CONST;
SkkPeriodStyle skk_context_get_period_style (SkkContext* self);
SkkPeriodStyle skk_state_get_period_style (SkkState* self);
void skk_context_set_period_style (SkkContext* self, SkkPeriodStyle value);
void skk_state_set_period_style (SkkState* self, SkkPeriodStyle value);
SkkRule* skk_context_get_typing_rule (SkkContext* self);
SkkRule* skk_state_get_typing_rule (SkkState* self);
void skk_context_set_typing_rule (SkkContext* self, SkkRule* value);
void skk_state_set_typing_rule (SkkState* self, SkkRule* value);
SkkKeyEventFilter* skk_rule_get_filter (SkkRule* self);
static void _skk_context_typing_rule___lambda8_ (SkkContext* self, SkkKeyEvent* key);
static void __skk_context_typing_rule___lambda8__skk_key_event_filter_forwarded (SkkKeyEventFilter* _sender, SkkKeyEvent* key, gpointer self);
static void g_cclosure_user_marshal_BOOLEAN__POINTER_POINTER (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_BOOLEAN__INT_UINT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void skk_context_finalize (GObject* obj);
static void _vala_skk_context_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_skk_context_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


/**
     * Initialize libskk.
     *
     * Must be called before using any functions in libskk.
     */
void skk_init (void) {
	GTypeClass* _tmp0_ = NULL;
	GTypeClass* _tmp1_;
	GTypeClass* _tmp2_ = NULL;
	GTypeClass* _tmp3_;
	_tmp0_ = g_type_class_ref (SKK_TYPE_UTIL);
	_tmp1_ = _tmp0_;
	_g_type_class_unref0 (_tmp1_);
	_tmp2_ = g_type_class_ref (SKK_TYPE_RULE);
	_tmp3_ = _tmp2_;
	_g_type_class_unref0 (_tmp3_);
}


/**
     * Type to specify input modes.
     */
GType skk_input_mode_get_type (void) {
	static volatile gsize skk_input_mode_type_id__volatile = 0;
	if (g_once_init_enter (&skk_input_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{SKK_INPUT_MODE_HIRAGANA, "SKK_INPUT_MODE_HIRAGANA", "hiragana"}, {SKK_INPUT_MODE_KATAKANA, "SKK_INPUT_MODE_KATAKANA", "katakana"}, {SKK_INPUT_MODE_HANKAKU_KATAKANA, "SKK_INPUT_MODE_HANKAKU_KATAKANA", "hankaku-katakana"}, {SKK_INPUT_MODE_LATIN, "SKK_INPUT_MODE_LATIN", "latin"}, {SKK_INPUT_MODE_WIDE_LATIN, "SKK_INPUT_MODE_WIDE_LATIN", "wide-latin"}, {SKK_INPUT_MODE_LAST, "SKK_INPUT_MODE_LAST", "last"}, {SKK_INPUT_MODE_DEFAULT, "SKK_INPUT_MODE_DEFAULT", "default"}, {0, NULL, NULL}};
		GType skk_input_mode_type_id;
		skk_input_mode_type_id = g_enum_register_static ("SkkInputMode", values);
		g_once_init_leave (&skk_input_mode_type_id__volatile, skk_input_mode_type_id);
	}
	return skk_input_mode_type_id__volatile;
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_slist_free__g_object_unref0_ (GSList* self) {
	g_slist_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_slist_free (self);
}


/**
         * Create a new Context.
         *
         * @param dictionaries an array of Dict
         *
         * @return a new Context
         */
static void __lambda6_ (SkkContext* self) {
	SkkCandidateList* _tmp0_;
	SkkCandidateList* _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	_tmp0_ = skk_context_get_candidates (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = skk_candidate_list_get_cursor_pos (_tmp1_);
	_tmp3_ = _tmp2_;
	if (_tmp3_ >= 0) {
		skk_context_update_preedit (self);
	}
}


static void ___lambda6__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	__lambda6_ (self);
}


static void __lambda7_ (SkkContext* self, SkkCandidate* candidate) {
	SkkCandidate* _tmp0_;
	gboolean _tmp1_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (candidate != NULL);
	_tmp0_ = candidate;
	_tmp1_ = skk_context_select_candidate_in_dictionaries (self, _tmp0_);
	if (_tmp1_) {
		{
			skk_context_save_dictionaries (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch32_g_error;
			}
		}
		goto __finally32;
		__catch32_g_error:
		{
			GError* e = NULL;
			GError* _tmp2_;
			const gchar* _tmp3_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp2_ = e;
			_tmp3_ = _tmp2_->message;
			g_warning ("context.vala:213: error saving dictionaries %s", _tmp3_);
			_g_error_free0 (e);
		}
		__finally32:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	skk_context_update_preedit (self);
}


static void ___lambda7__skk_candidate_list_selected (SkkCandidateList* _sender, SkkCandidate* candidate, gpointer self) {
	__lambda7_ (self, candidate);
}


SkkContext* skk_context_construct (GType object_type, SkkDict** dictionaries, int dictionaries_length1) {
	SkkContext * self = NULL;
	SkkDict** _tmp0_;
	gint _tmp0__length1;
	GeeHashMap* _tmp1_;
	SkkNoneStateHandler* _tmp2_;
	SkkNoneStateHandler* _tmp3_;
	GeeHashMap* _tmp4_;
	SkkStartStateHandler* _tmp5_;
	SkkStartStateHandler* _tmp6_;
	GeeHashMap* _tmp7_;
	SkkSelectStateHandler* _tmp8_;
	SkkSelectStateHandler* _tmp9_;
	GeeHashMap* _tmp10_;
	SkkAbbrevStateHandler* _tmp11_;
	SkkAbbrevStateHandler* _tmp12_;
	GeeHashMap* _tmp13_;
	SkkKutenStateHandler* _tmp14_;
	SkkKutenStateHandler* _tmp15_;
	GeeArrayList* _tmp16_;
	SkkState* _tmp17_;
	GSList* _tmp18_;
	gconstpointer _tmp19_;
	SkkCandidateList* _tmp20_;
	SkkCandidateList* _tmp21_;
	SkkCandidateList* _tmp22_;
	SkkCandidateList* _tmp23_;
	self = (SkkContext*) g_object_new (object_type, NULL);
	_tmp0_ = dictionaries;
	_tmp0__length1 = dictionaries_length1;
	skk_context_set_dictionaries (self, _tmp0_, _tmp0__length1);
	_tmp1_ = self->priv->handlers;
	_tmp2_ = skk_none_state_handler_new ();
	_tmp3_ = _tmp2_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp1_, GINT_TO_POINTER (SKK_TYPE_NONE_STATE_HANDLER), (SkkStateHandler*) _tmp3_);
	_g_object_unref0 (_tmp3_);
	_tmp4_ = self->priv->handlers;
	_tmp5_ = skk_start_state_handler_new ();
	_tmp6_ = _tmp5_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp4_, GINT_TO_POINTER (SKK_TYPE_START_STATE_HANDLER), (SkkStateHandler*) _tmp6_);
	_g_object_unref0 (_tmp6_);
	_tmp7_ = self->priv->handlers;
	_tmp8_ = skk_select_state_handler_new ();
	_tmp9_ = _tmp8_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp7_, GINT_TO_POINTER (SKK_TYPE_SELECT_STATE_HANDLER), (SkkStateHandler*) _tmp9_);
	_g_object_unref0 (_tmp9_);
	_tmp10_ = self->priv->handlers;
	_tmp11_ = skk_abbrev_state_handler_new ();
	_tmp12_ = _tmp11_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp10_, GINT_TO_POINTER (SKK_TYPE_ABBREV_STATE_HANDLER), (SkkStateHandler*) _tmp12_);
	_g_object_unref0 (_tmp12_);
	_tmp13_ = self->priv->handlers;
	_tmp14_ = skk_kuten_state_handler_new ();
	_tmp15_ = _tmp14_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp13_, GINT_TO_POINTER (SKK_TYPE_KUTEN_STATE_HANDLER), (SkkStateHandler*) _tmp15_);
	_g_object_unref0 (_tmp15_);
	_tmp16_ = self->priv->_dictionaries;
	_tmp17_ = skk_state_new (_tmp16_);
	self->priv->state_stack = g_slist_prepend (self->priv->state_stack, _tmp17_);
	_tmp18_ = self->priv->state_stack;
	_tmp19_ = _tmp18_->data;
	skk_context_connect_state_signals (self, (SkkState*) _tmp19_);
	_tmp20_ = skk_context_get_candidates (self);
	_tmp21_ = _tmp20_;
	g_signal_connect_object ((GObject*) _tmp21_, "notify::cursor-pos", (GCallback) ___lambda6__g_object_notify, self, 0);
	_tmp22_ = skk_context_get_candidates (self);
	_tmp23_ = _tmp22_;
	g_signal_connect_object (_tmp23_, "selected", (GCallback) ___lambda7__skk_candidate_list_selected, self, 0);
	return self;
}


SkkContext* skk_context_new (SkkDict** dictionaries, int dictionaries_length1) {
	return skk_context_construct (SKK_TYPE_CONTEXT, dictionaries, dictionaries_length1);
}


static void _skk_context_start_dict_edit_skk_state_recursive_edit_start (SkkState* _sender, const gchar* midasi, gboolean okuri, gpointer self) {
	skk_context_start_dict_edit (self, midasi, okuri);
}


static gboolean _skk_context_end_dict_edit_skk_state_recursive_edit_end (SkkState* _sender, const gchar* text, gpointer self) {
	gboolean result;
	result = skk_context_end_dict_edit (self, text);
	return result;
}


static gboolean _skk_context_abort_dict_edit_skk_state_recursive_edit_abort (SkkState* _sender, gpointer self) {
	gboolean result;
	result = skk_context_abort_dict_edit (self);
	return result;
}


static void __lambda3_ (SkkContext* self, GObject* s, GParamSpec* p) {
	g_return_if_fail (s != NULL);
	g_return_if_fail (p != NULL);
	g_object_notify ((GObject*) self, "input-mode");
}


static void ___lambda3__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	__lambda3_ (self, _sender, pspec);
}


static gboolean __lambda4_ (SkkContext* self, gchar** t, guint* c) {
	gchar* _vala_t = NULL;
	guint _vala_c = 0U;
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	guint _tmp1_ = 0U;
	gboolean _tmp2_ = FALSE;
	g_signal_emit_by_name (self, "retrieve-surrounding-text", &_tmp0_, &_tmp1_, &_tmp2_);
	_g_free0 (_vala_t);
	_vala_t = _tmp0_;
	_vala_c = _tmp1_;
	result = _tmp2_;
	if (t) {
		*t = _vala_t;
	} else {
		_g_free0 (_vala_t);
	}
	if (c) {
		*c = _vala_c;
	}
	return result;
}


static gboolean ___lambda4__skk_state_retrieve_surrounding_text (SkkState* _sender, gchar** text, guint* cursor_pos, gpointer self) {
	gboolean result;
	result = __lambda4_ (self, text, cursor_pos);
	return result;
}


static gboolean __lambda5_ (SkkContext* self, gint o, guint n) {
	gboolean result = FALSE;
	gint _tmp0_;
	guint _tmp1_;
	gboolean _tmp2_ = FALSE;
	_tmp0_ = o;
	_tmp1_ = n;
	g_signal_emit_by_name (self, "delete-surrounding-text", _tmp0_, _tmp1_, &_tmp2_);
	result = _tmp2_;
	return result;
}


static gboolean ___lambda5__skk_state_delete_surrounding_text (SkkState* _sender, gint offset, guint nchars, gpointer self) {
	gboolean result;
	result = __lambda5_ (self, offset, nchars);
	return result;
}


static void skk_context_connect_state_signals (SkkContext* self, SkkState* state) {
	SkkState* _tmp0_;
	SkkState* _tmp1_;
	SkkState* _tmp2_;
	SkkState* _tmp3_;
	SkkState* _tmp4_;
	SkkState* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (state != NULL);
	_tmp0_ = state;
	g_signal_connect_object (_tmp0_, "recursive-edit-start", (GCallback) _skk_context_start_dict_edit_skk_state_recursive_edit_start, self, 0);
	_tmp1_ = state;
	g_signal_connect_object (_tmp1_, "recursive-edit-end", (GCallback) _skk_context_end_dict_edit_skk_state_recursive_edit_end, self, 0);
	_tmp2_ = state;
	g_signal_connect_object (_tmp2_, "recursive-edit-abort", (GCallback) _skk_context_abort_dict_edit_skk_state_recursive_edit_abort, self, 0);
	_tmp3_ = state;
	g_signal_connect_object ((GObject*) _tmp3_, "notify::input-mode", (GCallback) ___lambda3__g_object_notify, self, 0);
	_tmp4_ = state;
	g_signal_connect_object (_tmp4_, "retrieve-surrounding-text", (GCallback) ___lambda4__skk_state_retrieve_surrounding_text, self, 0);
	_tmp5_ = state;
	g_signal_connect_object (_tmp5_, "delete-surrounding-text", (GCallback) ___lambda5__skk_state_delete_surrounding_text, self, 0);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gboolean skk_context_select_candidate_in_dictionaries (SkkContext* self, SkkCandidate* candidate) {
	gboolean result = FALSE;
	gboolean changed;
	SkkDict** _tmp0_;
	gint _tmp0__length1;
	SkkDict** _tmp1_;
	gint _tmp1__length1;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (candidate != NULL, FALSE);
	changed = FALSE;
	_tmp0_ = skk_context_get_dictionaries (self, &_tmp0__length1);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = _tmp0__length1;
	{
		SkkDict** dict_collection = NULL;
		gint dict_collection_length1 = 0;
		gint _dict_collection_size_ = 0;
		gint dict_it = 0;
		dict_collection = _tmp1_;
		dict_collection_length1 = _tmp1__length1;
		for (dict_it = 0; dict_it < _tmp1__length1; dict_it = dict_it + 1) {
			SkkDict* _tmp2_;
			SkkDict* dict = NULL;
			_tmp2_ = _g_object_ref0 (dict_collection[dict_it]);
			dict = _tmp2_;
			{
				gboolean _tmp3_ = FALSE;
				SkkDict* _tmp4_;
				gboolean _tmp5_;
				gboolean _tmp6_;
				gboolean _tmp10_;
				_tmp4_ = dict;
				_tmp5_ = skk_dict_get_read_only (_tmp4_);
				_tmp6_ = _tmp5_;
				if (!_tmp6_) {
					SkkDict* _tmp7_;
					SkkCandidate* _tmp8_;
					gboolean _tmp9_ = FALSE;
					_tmp7_ = dict;
					_tmp8_ = candidate;
					_tmp9_ = skk_dict_select_candidate (_tmp7_, _tmp8_);
					_tmp3_ = _tmp9_;
				} else {
					_tmp3_ = FALSE;
				}
				_tmp10_ = _tmp3_;
				if (_tmp10_) {
					changed = TRUE;
				}
				_g_object_unref0 (dict);
			}
		}
		dict_collection = (_vala_array_free (dict_collection, dict_collection_length1, (GDestroyNotify) g_object_unref), NULL);
	}
	result = changed;
	return result;
}


static guint skk_context_dict_edit_level (SkkContext* self) {
	guint result = 0U;
	GSList* _tmp0_;
	guint _tmp1_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = g_slist_length (_tmp0_);
	result = _tmp1_ - 1;
	return result;
}


static void skk_context_start_dict_edit (SkkContext* self, const gchar* midasi, gboolean okuri) {
	GeeArrayList* _tmp0_;
	SkkState* _tmp1_;
	SkkState* state;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gboolean _tmp4_;
	SkkState* _tmp5_;
	GSList* _tmp6_;
	gconstpointer _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (midasi != NULL);
	_tmp0_ = self->priv->_dictionaries;
	_tmp1_ = skk_state_new (_tmp0_);
	state = _tmp1_;
	_tmp2_ = midasi;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (state->midasi);
	state->midasi = _tmp3_;
	_tmp4_ = okuri;
	state->okuri = _tmp4_;
	_tmp5_ = _g_object_ref0 (state);
	self->priv->state_stack = g_slist_prepend (self->priv->state_stack, _tmp5_);
	_tmp6_ = self->priv->state_stack;
	_tmp7_ = _tmp6_->data;
	skk_context_connect_state_signals (self, (SkkState*) _tmp7_);
	skk_context_update_preedit (self);
	g_object_notify ((GObject*) self, "candidates");
	_g_object_unref0 (state);
}


static gboolean skk_context_end_dict_edit (SkkContext* self, const gchar* text) {
	gboolean result = FALSE;
	gchar* midasi = NULL;
	gboolean* okuri = FALSE;
	gchar* _tmp0_ = NULL;
	gboolean* _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (text != NULL, FALSE);
	_tmp2_ = skk_context_leave_dict_edit (self, &_tmp0_, &_tmp1_);
	_g_free0 (midasi);
	midasi = _tmp0_;
	_g_free0 (okuri);
	okuri = _tmp1_;
	if (_tmp2_) {
		const gchar* _tmp3_;
		gboolean* _tmp4_;
		const gchar* _tmp5_;
		SkkCandidate* _tmp6_;
		SkkCandidate* candidate;
		SkkCandidate* _tmp7_;
		gboolean _tmp8_ = FALSE;
		GSList* _tmp11_;
		gconstpointer _tmp12_;
		GSList* _tmp13_;
		gconstpointer _tmp14_;
		GString* _tmp15_;
		const gchar* _tmp16_;
		_tmp3_ = midasi;
		_tmp4_ = okuri;
		_tmp5_ = text;
		_tmp6_ = skk_candidate_new (_tmp3_, *_tmp4_, _tmp5_, NULL, NULL);
		candidate = _tmp6_;
		_tmp7_ = candidate;
		_tmp8_ = skk_context_select_candidate_in_dictionaries (self, _tmp7_);
		if (_tmp8_) {
			{
				skk_context_save_dictionaries (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					goto __catch33_g_error;
				}
			}
			goto __finally33;
			__catch33_g_error:
			{
				GError* e = NULL;
				GError* _tmp9_;
				const gchar* _tmp10_;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp9_ = e;
				_tmp10_ = _tmp9_->message;
				g_warning ("context.vala:297: error saving dictionaries %s", _tmp10_);
				_g_error_free0 (e);
			}
			__finally33:
			if (_inner_error_ != NULL) {
				_g_object_unref0 (candidate);
				_g_free0 (okuri);
				_g_free0 (midasi);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
		}
		_tmp11_ = self->priv->state_stack;
		_tmp12_ = _tmp11_->data;
		skk_state_reset ((SkkState*) _tmp12_);
		_tmp13_ = self->priv->state_stack;
		_tmp14_ = _tmp13_->data;
		_tmp15_ = ((SkkState*) _tmp14_)->output;
		_tmp16_ = text;
		g_string_assign (_tmp15_, _tmp16_);
		skk_context_update_preedit (self);
		result = TRUE;
		_g_object_unref0 (candidate);
		_g_free0 (okuri);
		_g_free0 (midasi);
		return result;
	}
	result = FALSE;
	_g_free0 (okuri);
	_g_free0 (midasi);
	return result;
}


static gboolean* _bool_dup (gboolean* self) {
	gboolean* dup;
	dup = g_new0 (gboolean, 1);
	memcpy (dup, self, sizeof (gboolean));
	return dup;
}


static gpointer __bool_dup0 (gpointer self) {
	return self ? _bool_dup (self) : NULL;
}


static gboolean skk_context_leave_dict_edit (SkkContext* self, gchar** midasi, gboolean** okuri) {
	gchar* _vala_midasi = NULL;
	gboolean* _vala_okuri = FALSE;
	gboolean result = FALSE;
	guint _tmp0_ = 0U;
	gboolean _tmp12_;
	gboolean* _tmp13_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = skk_context_dict_edit_level (self);
	if (_tmp0_ > ((guint) 0)) {
		GSList* _tmp1_;
		gconstpointer _tmp2_;
		const gchar* _tmp3_;
		gchar* _tmp4_;
		GSList* _tmp5_;
		gconstpointer _tmp6_;
		gboolean _tmp7_;
		gboolean* _tmp8_;
		GSList* _tmp9_;
		GSList* _tmp10_;
		gconstpointer _tmp11_;
		_tmp1_ = self->priv->state_stack;
		_tmp2_ = _tmp1_->data;
		_tmp3_ = ((SkkState*) _tmp2_)->midasi;
		_tmp4_ = g_strdup (_tmp3_);
		_g_free0 (_vala_midasi);
		_vala_midasi = _tmp4_;
		_tmp5_ = self->priv->state_stack;
		_tmp6_ = _tmp5_->data;
		_tmp7_ = ((SkkState*) _tmp6_)->okuri;
		_tmp8_ = __bool_dup0 (&_tmp7_);
		_g_free0 (_vala_okuri);
		_vala_okuri = _tmp8_;
		_tmp9_ = self->priv->state_stack;
		self->priv->state_stack = g_slist_delete_link (self->priv->state_stack, _tmp9_);
		_tmp10_ = self->priv->state_stack;
		_tmp11_ = _tmp10_->data;
		skk_state_cancel_okuri ((SkkState*) _tmp11_);
		g_object_notify ((GObject*) self, "candidates");
		result = TRUE;
		if (midasi) {
			*midasi = _vala_midasi;
		} else {
			_g_free0 (_vala_midasi);
		}
		if (okuri) {
			*okuri = _vala_okuri;
		} else {
			_g_free0 (_vala_okuri);
		}
		return result;
	}
	_g_free0 (_vala_midasi);
	_vala_midasi = NULL;
	_tmp12_ = FALSE;
	_tmp13_ = __bool_dup0 (&_tmp12_);
	_g_free0 (_vala_okuri);
	_vala_okuri = _tmp13_;
	result = FALSE;
	if (midasi) {
		*midasi = _vala_midasi;
	} else {
		_g_free0 (_vala_midasi);
	}
	if (okuri) {
		*okuri = _vala_okuri;
	} else {
		_g_free0 (_vala_okuri);
	}
	return result;
}


static gboolean skk_context_abort_dict_edit (SkkContext* self) {
	gboolean result = FALSE;
	gchar* midasi = NULL;
	gboolean* okuri = FALSE;
	gchar* _tmp0_ = NULL;
	gboolean* _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp2_ = skk_context_leave_dict_edit (self, &_tmp0_, &_tmp1_);
	_g_free0 (midasi);
	midasi = _tmp0_;
	_g_free0 (okuri);
	okuri = _tmp1_;
	if (_tmp2_) {
		skk_context_update_preedit (self);
		result = TRUE;
		_g_free0 (okuri);
		_g_free0 (midasi);
		return result;
	}
	result = FALSE;
	_g_free0 (okuri);
	_g_free0 (midasi);
	return result;
}


/**
         * Pass key events (separated by spaces) to the context.
         *
         * This function is rarely used in programs but in unit tests.
         *
         * @param keyseq a string representing key events, seperated by " "
         *
         * @return `true` if any of key events are handled, `false` otherwise
         */
static gboolean string_get_next_char (const gchar* self, gint* index, gunichar* c) {
	gunichar _vala_c = 0U;
	gboolean result = FALSE;
	gint _tmp0_;
	gunichar _tmp1_ = 0U;
	gunichar _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = *index;
	_tmp1_ = g_utf8_get_char (((gchar*) self) + _tmp0_);
	_vala_c = _tmp1_;
	_tmp2_ = _vala_c;
	if (_tmp2_ != ((gunichar) 0)) {
		gint _tmp3_;
		gchar* _tmp4_ = NULL;
		_tmp3_ = *index;
		_tmp4_ = g_utf8_next_char (((gchar*) self) + _tmp3_);
		*index = (gint) (_tmp4_ - ((gchar*) self));
		result = TRUE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	} else {
		result = FALSE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	}
	if (c) {
		*c = _vala_c;
	}
}


gboolean skk_context_process_key_events (SkkContext* self, const gchar* keyseq) {
	gboolean result = FALSE;
	GeeArrayList* _tmp0_;
	GeeArrayList* keys;
	GString* _tmp1_;
	GString* builder;
	gboolean complex;
	gboolean escaped;
	gint index;
	gunichar uc = 0U;
	gboolean _tmp30_;
	GString* _tmp31_;
	gssize _tmp32_;
	gboolean retval;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (keyseq != NULL, FALSE);
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	keys = _tmp0_;
	_tmp1_ = g_string_new ("");
	builder = _tmp1_;
	complex = FALSE;
	escaped = FALSE;
	index = 0;
	while (TRUE) {
		const gchar* _tmp2_;
		gunichar _tmp3_ = 0U;
		gboolean _tmp4_ = FALSE;
		gboolean _tmp5_;
		gunichar _tmp8_;
		_tmp2_ = keyseq;
		_tmp4_ = string_get_next_char (_tmp2_, &index, &_tmp3_);
		uc = _tmp3_;
		if (!_tmp4_) {
			break;
		}
		_tmp5_ = escaped;
		if (_tmp5_) {
			GString* _tmp6_;
			gunichar _tmp7_;
			_tmp6_ = builder;
			_tmp7_ = uc;
			g_string_append_unichar (_tmp6_, _tmp7_);
			escaped = FALSE;
			continue;
		}
		_tmp8_ = uc;
		switch (_tmp8_) {
			case '\\':
			{
				escaped = TRUE;
				break;
			}
			case '(':
			{
				gboolean _tmp9_;
				GString* _tmp10_;
				gunichar _tmp11_;
				_tmp9_ = complex;
				if (_tmp9_) {
					g_warning ("context.vala:360: bare '(' is not allowed in complex keyseq");
					result = FALSE;
					_g_string_free0 (builder);
					_g_object_unref0 (keys);
					return result;
				}
				complex = TRUE;
				_tmp10_ = builder;
				_tmp11_ = uc;
				g_string_append_unichar (_tmp10_, _tmp11_);
				break;
			}
			case ')':
			{
				gboolean _tmp12_;
				GString* _tmp13_;
				gunichar _tmp14_;
				GeeArrayList* _tmp15_;
				GString* _tmp16_;
				const gchar* _tmp17_;
				GString* _tmp18_;
				_tmp12_ = complex;
				if (!_tmp12_) {
					g_warning ("context.vala:368: bare ')' is not allowed in simple keyseq");
					result = FALSE;
					_g_string_free0 (builder);
					_g_object_unref0 (keys);
					return result;
				}
				complex = FALSE;
				_tmp13_ = builder;
				_tmp14_ = uc;
				g_string_append_unichar (_tmp13_, _tmp14_);
				_tmp15_ = keys;
				_tmp16_ = builder;
				_tmp17_ = _tmp16_->str;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp15_, _tmp17_);
				_tmp18_ = builder;
				g_string_erase (_tmp18_, (gssize) 0, (gssize) (-1));
				break;
			}
			case ' ':
			{
				gboolean _tmp19_;
				_tmp19_ = complex;
				if (_tmp19_) {
					GString* _tmp20_;
					gunichar _tmp21_;
					_tmp20_ = builder;
					_tmp21_ = uc;
					g_string_append_unichar (_tmp20_, _tmp21_);
				} else {
					GString* _tmp22_;
					gssize _tmp23_;
					_tmp22_ = builder;
					_tmp23_ = _tmp22_->len;
					if (_tmp23_ > ((gssize) 0)) {
						GeeArrayList* _tmp24_;
						GString* _tmp25_;
						const gchar* _tmp26_;
						GString* _tmp27_;
						_tmp24_ = keys;
						_tmp25_ = builder;
						_tmp26_ = _tmp25_->str;
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp24_, _tmp26_);
						_tmp27_ = builder;
						g_string_erase (_tmp27_, (gssize) 0, (gssize) (-1));
					}
				}
				break;
			}
			default:
			{
				GString* _tmp28_;
				gunichar _tmp29_;
				_tmp28_ = builder;
				_tmp29_ = uc;
				g_string_append_unichar (_tmp28_, _tmp29_);
				break;
			}
		}
	}
	_tmp30_ = complex;
	if (_tmp30_) {
		g_warning ("context.vala:391: premature end of key events");
		result = FALSE;
		_g_string_free0 (builder);
		_g_object_unref0 (keys);
		return result;
	}
	_tmp31_ = builder;
	_tmp32_ = _tmp31_->len;
	if (_tmp32_ > ((gssize) 0)) {
		GeeArrayList* _tmp33_;
		GString* _tmp34_;
		const gchar* _tmp35_;
		_tmp33_ = keys;
		_tmp34_ = builder;
		_tmp35_ = _tmp34_->str;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp33_, _tmp35_);
	}
	retval = FALSE;
	{
		GeeArrayList* _tmp36_;
		GeeArrayList* _tmp37_;
		GeeArrayList* _key_list;
		GeeArrayList* _tmp38_;
		gint _tmp39_;
		gint _tmp40_;
		gint _key_size;
		gint _key_index;
		_tmp36_ = keys;
		_tmp37_ = _g_object_ref0 (_tmp36_);
		_key_list = _tmp37_;
		_tmp38_ = _key_list;
		_tmp39_ = gee_collection_get_size ((GeeCollection*) _tmp38_);
		_tmp40_ = _tmp39_;
		_key_size = _tmp40_;
		_key_index = -1;
		while (TRUE) {
			gint _tmp41_;
			gint _tmp42_;
			gint _tmp43_;
			GeeArrayList* _tmp44_;
			gint _tmp45_;
			gpointer _tmp46_ = NULL;
			gchar* key;
			const gchar* _tmp47_;
			const gchar* _tmp55_;
			SkkKeyEvent* _tmp56_;
			SkkKeyEvent* ev;
			gboolean _tmp57_ = FALSE;
			SkkKeyEvent* _tmp58_;
			gboolean _tmp59_ = FALSE;
			gboolean _tmp61_;
			_tmp41_ = _key_index;
			_key_index = _tmp41_ + 1;
			_tmp42_ = _key_index;
			_tmp43_ = _key_size;
			if (!(_tmp42_ < _tmp43_)) {
				break;
			}
			_tmp44_ = _key_list;
			_tmp45_ = _key_index;
			_tmp46_ = gee_abstract_list_get ((GeeAbstractList*) _tmp44_, _tmp45_);
			key = (gchar*) _tmp46_;
			_tmp47_ = key;
			if (g_strcmp0 (_tmp47_, "SPC") == 0) {
				gchar* _tmp48_;
				_tmp48_ = g_strdup (" ");
				_g_free0 (key);
				key = _tmp48_;
			} else {
				const gchar* _tmp49_;
				_tmp49_ = key;
				if (g_strcmp0 (_tmp49_, "TAB") == 0) {
					gchar* _tmp50_;
					_tmp50_ = g_strdup ("\t");
					_g_free0 (key);
					key = _tmp50_;
				} else {
					const gchar* _tmp51_;
					_tmp51_ = key;
					if (g_strcmp0 (_tmp51_, "RET") == 0) {
						gchar* _tmp52_;
						_tmp52_ = g_strdup ("\n");
						_g_free0 (key);
						key = _tmp52_;
					} else {
						const gchar* _tmp53_;
						_tmp53_ = key;
						if (g_strcmp0 (_tmp53_, "DEL") == 0) {
							gchar* _tmp54_;
							_tmp54_ = g_strdup ("\b");
							_g_free0 (key);
							key = _tmp54_;
						}
					}
				}
			}
			_tmp55_ = key;
			_tmp56_ = skk_key_event_new_from_string (_tmp55_);
			ev = _tmp56_;
			_tmp58_ = ev;
			_tmp59_ = skk_context_process_key_event (self, _tmp58_);
			if (_tmp59_) {
				gboolean _tmp60_;
				_tmp60_ = retval;
				_tmp57_ = !_tmp60_;
			} else {
				_tmp57_ = FALSE;
			}
			_tmp61_ = _tmp57_;
			if (_tmp61_) {
				retval = TRUE;
			}
			_skk_key_event_unref0 (ev);
			_g_free0 (key);
		}
		_g_object_unref0 (_key_list);
	}
	result = retval;
	_g_string_free0 (builder);
	_g_object_unref0 (keys);
	return result;
}


/**
         * Pass one key event to the context.
         *
         * @param key a key event
         *
         * @return `true` if the key event is handled, `false` otherwise
         */
gboolean skk_context_process_key_event (SkkContext* self, SkkKeyEvent* key) {
	gboolean result = FALSE;
	SkkKeyEventFilter* _tmp0_;
	SkkKeyEventFilter* _tmp1_;
	SkkKeyEventFilter* _tmp2_;
	SkkKeyEvent* _tmp3_;
	SkkKeyEvent* _tmp4_ = NULL;
	SkkKeyEvent* _tmp5_;
	SkkKeyEvent* _key;
	SkkKeyEvent* _tmp6_;
	SkkKeyEvent* _tmp7_;
	gboolean _tmp8_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = skk_context_get_key_event_filter (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = _tmp1_;
	_tmp3_ = key;
	_tmp4_ = skk_key_event_filter_filter_key_event (_tmp2_, _tmp3_);
	_tmp5_ = _tmp4_;
	_g_object_unref0 (_tmp2_);
	_key = _tmp5_;
	_tmp6_ = _key;
	if (_tmp6_ == NULL) {
		result = TRUE;
		_skk_key_event_unref0 (_key);
		return result;
	}
	_tmp7_ = _key;
	_tmp8_ = skk_context_process_key_event_internal (self, _tmp7_);
	result = _tmp8_;
	_skk_key_event_unref0 (_key);
	return result;
}


static gboolean skk_context_process_key_event_internal (SkkContext* self, SkkKeyEvent* key) {
	gboolean result = FALSE;
	SkkKeyEvent* _tmp0_;
	SkkKeyEvent* _tmp1_ = NULL;
	SkkKeyEvent* _key;
	GSList* _tmp2_;
	gconstpointer _tmp3_;
	SkkState* _tmp4_;
	SkkState* state;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = key;
	_tmp1_ = skk_key_event_copy (_tmp0_);
	_key = _tmp1_;
	_tmp2_ = self->priv->state_stack;
	_tmp3_ = _tmp2_->data;
	_tmp4_ = _g_object_ref0 ((SkkState*) _tmp3_);
	state = _tmp4_;
	while (TRUE) {
		SkkState* _tmp5_;
		GType _tmp6_;
		GType handler_type;
		GeeHashMap* _tmp7_;
		GType _tmp8_;
		gpointer _tmp9_ = NULL;
		SkkStateHandler* handler;
		SkkStateHandler* _tmp10_;
		SkkState* _tmp11_;
		gboolean _tmp12_ = FALSE;
		GType _tmp13_;
		SkkState* _tmp14_;
		GType _tmp15_;
		_tmp5_ = state;
		_tmp6_ = _tmp5_->handler_type;
		handler_type = _tmp6_;
		_tmp7_ = self->priv->handlers;
		_tmp8_ = handler_type;
		_tmp9_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp7_, GINT_TO_POINTER (_tmp8_));
		handler = (SkkStateHandler*) _tmp9_;
		_tmp10_ = handler;
		_tmp11_ = state;
		_tmp12_ = skk_state_handler_process_key_event (_tmp10_, _tmp11_, &_key);
		if (_tmp12_) {
			skk_context_update_preedit (self);
			result = TRUE;
			_g_object_unref0 (handler);
			_g_object_unref0 (state);
			_skk_key_event_unref0 (_key);
			return result;
		}
		_tmp13_ = handler_type;
		_tmp14_ = state;
		_tmp15_ = _tmp14_->handler_type;
		if (_tmp13_ == _tmp15_) {
			guint _tmp16_ = 0U;
			_tmp16_ = skk_context_dict_edit_level (self);
			result = _tmp16_ > ((guint) 0);
			_g_object_unref0 (handler);
			_g_object_unref0 (state);
			_skk_key_event_unref0 (_key);
			return result;
		}
		_g_object_unref0 (handler);
	}
	_g_object_unref0 (state);
	_skk_key_event_unref0 (_key);
}


/**
         * Reset the context.
         */
void skk_context_reset (SkkContext* self) {
	GSList* _tmp4_;
	gconstpointer _tmp5_;
	GSList* _tmp6_;
	gconstpointer _tmp7_;
	g_return_if_fail (self != NULL);
	while (TRUE) {
		guint _tmp0_ = 0U;
		GSList* _tmp1_;
		GSList* _tmp2_;
		gconstpointer _tmp3_;
		_tmp0_ = skk_context_dict_edit_level (self);
		if (!(_tmp0_ > ((guint) 0))) {
			break;
		}
		_tmp1_ = self->priv->state_stack;
		self->priv->state_stack = g_slist_delete_link (self->priv->state_stack, _tmp1_);
		_tmp2_ = self->priv->state_stack;
		_tmp3_ = _tmp2_->data;
		skk_state_cancel_okuri ((SkkState*) _tmp3_);
	}
	_tmp4_ = self->priv->state_stack;
	_tmp5_ = _tmp4_->data;
	skk_state_output_surrounding_text ((SkkState*) _tmp5_);
	_tmp6_ = self->priv->state_stack;
	_tmp7_ = _tmp6_->data;
	skk_state_reset ((SkkState*) _tmp7_);
	g_object_notify ((GObject*) self, "candidates");
}


/**
         * This is replaced with {@link poll_output}.
         *
         * @return an output string
         * @deprecated 0.0.6
         */
gchar* skk_context_get_output (SkkContext* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = skk_context_poll_output (self);
	result = _tmp0_;
	return result;
}


static gchar* skk_context_retrieve_output (SkkContext* self, gboolean clear) {
	gchar* result = NULL;
	GSList* _tmp0_;
	gconstpointer _tmp1_;
	SkkState* _tmp2_;
	SkkState* state;
	GeeHashMap* _tmp3_;
	SkkState* _tmp4_;
	GType _tmp5_;
	gpointer _tmp6_ = NULL;
	SkkStateHandler* handler;
	guint _tmp7_ = 0U;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = _g_object_ref0 ((SkkState*) _tmp1_);
	state = _tmp2_;
	_tmp3_ = self->priv->handlers;
	_tmp4_ = state;
	_tmp5_ = _tmp4_->handler_type;
	_tmp6_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp3_, GINT_TO_POINTER (_tmp5_));
	handler = (SkkStateHandler*) _tmp6_;
	_tmp7_ = skk_context_dict_edit_level (self);
	if (_tmp7_ > ((guint) 0)) {
		gchar* _tmp8_;
		_tmp8_ = g_strdup ("");
		result = _tmp8_;
		_g_object_unref0 (handler);
		_g_object_unref0 (state);
		return result;
	} else {
		SkkStateHandler* _tmp9_;
		SkkState* _tmp10_;
		gchar* _tmp11_ = NULL;
		gchar* output;
		gboolean _tmp12_;
		_tmp9_ = handler;
		_tmp10_ = state;
		_tmp11_ = skk_state_handler_get_output (_tmp9_, _tmp10_);
		output = _tmp11_;
		_tmp12_ = clear;
		if (_tmp12_) {
			SkkState* _tmp13_;
			GString* _tmp14_;
			_tmp13_ = state;
			_tmp14_ = _tmp13_->output;
			g_string_erase (_tmp14_, (gssize) 0, (gssize) (-1));
		}
		result = output;
		_g_object_unref0 (handler);
		_g_object_unref0 (state);
		return result;
	}
	_g_object_unref0 (handler);
	_g_object_unref0 (state);
}


/**
         * Peek (retrieve, but not remove) the current output string.
         *
         * @return an output string
         * @since 0.0.6
         */
gchar* skk_context_peek_output (SkkContext* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = skk_context_retrieve_output (self, FALSE);
	result = _tmp0_;
	return result;
}


/**
         * Poll (retrieve and remove) the current output string.
         *
         * @return an output string
         * @since 0.0.6
         */
gchar* skk_context_poll_output (SkkContext* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = skk_context_retrieve_output (self, TRUE);
	result = _tmp0_;
	return result;
}


/**
         * Clear the output buffer.
         *
         * @since 0.0.6
         */
void skk_context_clear_output (SkkContext* self) {
	GSList* _tmp0_;
	gconstpointer _tmp1_;
	GString* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = ((SkkState*) _tmp1_)->output;
	g_string_erase (_tmp2_, (gssize) 0, (gssize) (-1));
}


static void skk_context_update_preedit (SkkContext* self) {
	GSList* _tmp0_;
	gconstpointer _tmp1_;
	SkkState* _tmp2_;
	SkkState* state;
	GeeHashMap* _tmp3_;
	SkkState* _tmp4_;
	GType _tmp5_;
	gpointer _tmp6_ = NULL;
	SkkStateHandler* handler;
	GString* _tmp7_;
	GString* builder;
	guint _tmp8_ = 0U;
	guint offset = 0U;
	guint nchars = 0U;
	GString* _tmp35_;
	SkkStateHandler* _tmp36_;
	SkkState* _tmp37_;
	guint _tmp38_ = 0U;
	guint _tmp39_ = 0U;
	gchar* _tmp40_ = NULL;
	gchar* _tmp41_;
	guint _tmp42_;
	GString* _tmp43_;
	const gchar* _tmp44_;
	gint _tmp45_ = 0;
	gboolean changed;
	const gchar* _tmp46_;
	GString* _tmp47_;
	const gchar* _tmp48_;
	gboolean _tmp59_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = _g_object_ref0 ((SkkState*) _tmp1_);
	state = _tmp2_;
	_tmp3_ = self->priv->handlers;
	_tmp4_ = state;
	_tmp5_ = _tmp4_->handler_type;
	_tmp6_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp3_, GINT_TO_POINTER (_tmp5_));
	handler = (SkkStateHandler*) _tmp6_;
	_tmp7_ = g_string_new ("");
	builder = _tmp7_;
	_tmp8_ = skk_context_dict_edit_level (self);
	if (_tmp8_ > ((guint) 0)) {
		guint _tmp9_ = 0U;
		guint level;
		GString* _tmp16_;
		const gchar* _tmp17_ = NULL;
		GString* _tmp24_;
		GString* _tmp25_;
		GSList* _tmp26_;
		gconstpointer _tmp27_;
		const gchar* _tmp28_;
		GString* _tmp29_;
		GString* _tmp30_;
		SkkStateHandler* _tmp31_;
		SkkState* _tmp32_;
		gchar* _tmp33_ = NULL;
		gchar* _tmp34_;
		_tmp9_ = skk_context_dict_edit_level (self);
		level = _tmp9_;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp10_;
				_tmp10_ = TRUE;
				while (TRUE) {
					gboolean _tmp11_;
					gint _tmp13_;
					guint _tmp14_;
					GString* _tmp15_;
					_tmp11_ = _tmp10_;
					if (!_tmp11_) {
						gint _tmp12_;
						_tmp12_ = i;
						i = _tmp12_ + 1;
					}
					_tmp10_ = FALSE;
					_tmp13_ = i;
					_tmp14_ = level;
					if (!(((guint) _tmp13_) < _tmp14_)) {
						break;
					}
					_tmp15_ = builder;
					g_string_append_c (_tmp15_, '[');
				}
			}
		}
		_tmp16_ = builder;
		_tmp17_ = _ ("DictEdit");
		g_string_append (_tmp16_, _tmp17_);
		{
			gint i;
			i = 0;
			{
				gboolean _tmp18_;
				_tmp18_ = TRUE;
				while (TRUE) {
					gboolean _tmp19_;
					gint _tmp21_;
					guint _tmp22_;
					GString* _tmp23_;
					_tmp19_ = _tmp18_;
					if (!_tmp19_) {
						gint _tmp20_;
						_tmp20_ = i;
						i = _tmp20_ + 1;
					}
					_tmp18_ = FALSE;
					_tmp21_ = i;
					_tmp22_ = level;
					if (!(((guint) _tmp21_) < _tmp22_)) {
						break;
					}
					_tmp23_ = builder;
					g_string_append_c (_tmp23_, ']');
				}
			}
		}
		_tmp24_ = builder;
		g_string_append (_tmp24_, " ");
		_tmp25_ = builder;
		_tmp26_ = self->priv->state_stack;
		_tmp27_ = _tmp26_->data;
		_tmp28_ = ((SkkState*) _tmp27_)->midasi;
		g_string_append (_tmp25_, _tmp28_);
		_tmp29_ = builder;
		g_string_append (_tmp29_, " ");
		_tmp30_ = builder;
		_tmp31_ = handler;
		_tmp32_ = state;
		_tmp33_ = skk_state_handler_get_output (_tmp31_, _tmp32_);
		_tmp34_ = _tmp33_;
		g_string_append (_tmp30_, _tmp34_);
		_g_free0 (_tmp34_);
	}
	_tmp35_ = builder;
	_tmp36_ = handler;
	_tmp37_ = state;
	_tmp40_ = skk_state_handler_get_preedit (_tmp36_, _tmp37_, &_tmp38_, &_tmp39_);
	offset = _tmp38_;
	nchars = _tmp39_;
	_tmp41_ = _tmp40_;
	g_string_append (_tmp35_, _tmp41_);
	_g_free0 (_tmp41_);
	_tmp42_ = offset;
	_tmp43_ = builder;
	_tmp44_ = _tmp43_->str;
	_tmp45_ = g_utf8_strlen (_tmp44_, (gssize) (-1));
	offset = _tmp42_ + ((guint) _tmp45_);
	changed = FALSE;
	_tmp46_ = self->priv->_preedit;
	_tmp47_ = builder;
	_tmp48_ = _tmp47_->str;
	if (g_strcmp0 (_tmp46_, _tmp48_) != 0) {
		GString* _tmp49_;
		const gchar* _tmp50_;
		_tmp49_ = builder;
		_tmp50_ = _tmp49_->str;
		skk_context_set_preedit (self, _tmp50_);
		changed = TRUE;
	} else {
		gboolean _tmp51_ = FALSE;
		guint _tmp52_;
		guint _tmp53_;
		gboolean _tmp56_;
		_tmp52_ = self->priv->preedit_underline_offset;
		_tmp53_ = offset;
		if (_tmp52_ != _tmp53_) {
			_tmp51_ = TRUE;
		} else {
			guint _tmp54_;
			guint _tmp55_;
			_tmp54_ = self->priv->preedit_underline_nchars;
			_tmp55_ = nchars;
			_tmp51_ = _tmp54_ != _tmp55_;
		}
		_tmp56_ = _tmp51_;
		if (_tmp56_) {
			guint _tmp57_;
			guint _tmp58_;
			_tmp57_ = offset;
			self->priv->preedit_underline_offset = _tmp57_;
			_tmp58_ = nchars;
			self->priv->preedit_underline_nchars = _tmp58_;
			changed = TRUE;
		}
	}
	_tmp59_ = changed;
	if (_tmp59_) {
		g_object_notify ((GObject*) self, "preedit");
	}
	_g_string_free0 (builder);
	_g_object_unref0 (handler);
	_g_object_unref0 (state);
}


/**
         * Get underlined range of preedit.
         *
         * @param offset starting offset (in chars) of underline
         * @param nchars number of characters to be underlined
         * @since 0.0.6
         */
void skk_context_get_preedit_underline (SkkContext* self, guint* offset, guint* nchars) {
	guint _vala_offset = 0U;
	guint _vala_nchars = 0U;
	guint _tmp0_;
	guint _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->preedit_underline_offset;
	_vala_offset = _tmp0_;
	_tmp1_ = self->priv->preedit_underline_nchars;
	_vala_nchars = _tmp1_;
	if (offset) {
		*offset = _vala_offset;
	}
	if (nchars) {
		*nchars = _vala_nchars;
	}
}


/**
         * Save dictionaries on to disk.
         */
void skk_context_save_dictionaries (SkkContext* self, GError** error) {
	SkkDict** _tmp0_;
	gint _tmp0__length1;
	SkkDict** _tmp1_;
	gint _tmp1__length1;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = skk_context_get_dictionaries (self, &_tmp0__length1);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = _tmp0__length1;
	{
		SkkDict** dict_collection = NULL;
		gint dict_collection_length1 = 0;
		gint _dict_collection_size_ = 0;
		gint dict_it = 0;
		dict_collection = _tmp1_;
		dict_collection_length1 = _tmp1__length1;
		for (dict_it = 0; dict_it < _tmp1__length1; dict_it = dict_it + 1) {
			SkkDict* _tmp2_;
			SkkDict* dict = NULL;
			_tmp2_ = _g_object_ref0 (dict_collection[dict_it]);
			dict = _tmp2_;
			{
				SkkDict* _tmp3_;
				gboolean _tmp4_;
				gboolean _tmp5_;
				_tmp3_ = dict;
				_tmp4_ = skk_dict_get_read_only (_tmp3_);
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					SkkDict* _tmp6_;
					_tmp6_ = dict;
					skk_dict_save (_tmp6_, &_inner_error_);
					if (_inner_error_ != NULL) {
						g_propagate_error (error, _inner_error_);
						_g_object_unref0 (dict);
						dict_collection = (_vala_array_free (dict_collection, dict_collection_length1, (GDestroyNotify) g_object_unref), NULL);
						return;
					}
				}
				_g_object_unref0 (dict);
			}
		}
		dict_collection = (_vala_array_free (dict_collection, dict_collection_length1, (GDestroyNotify) g_object_unref), NULL);
	}
}


SkkDict** skk_context_get_dictionaries (SkkContext* self, int* result_length1) {
	SkkDict** result;
	GeeArrayList* _tmp0_;
	gint _tmp1_ = 0;
	gpointer* _tmp2_ = NULL;
	SkkDict** _tmp3_;
	gint _tmp3__length1;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_dictionaries;
	_tmp2_ = gee_abstract_collection_to_array ((GeeAbstractCollection*) _tmp0_, &_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp3__length1 = _tmp1_;
	if (result_length1) {
		*result_length1 = _tmp3__length1;
	}
	result = _tmp3_;
	return result;
}


void skk_context_set_dictionaries (SkkContext* self, SkkDict** value, int value_length1) {
	GeeArrayList* _tmp0_;
	SkkDict** _tmp1_;
	gint _tmp1__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_dictionaries;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp0_);
	_tmp1_ = value;
	_tmp1__length1 = value_length1;
	{
		SkkDict** dict_collection = NULL;
		gint dict_collection_length1 = 0;
		gint _dict_collection_size_ = 0;
		gint dict_it = 0;
		dict_collection = _tmp1_;
		dict_collection_length1 = _tmp1__length1;
		for (dict_it = 0; dict_it < _tmp1__length1; dict_it = dict_it + 1) {
			SkkDict* _tmp2_;
			SkkDict* dict = NULL;
			_tmp2_ = _g_object_ref0 (dict_collection[dict_it]);
			dict = _tmp2_;
			{
				GeeArrayList* _tmp3_;
				SkkDict* _tmp4_;
				_tmp3_ = self->priv->_dictionaries;
				_tmp4_ = dict;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp3_, _tmp4_);
				_g_object_unref0 (dict);
			}
		}
	}
}


SkkCandidateList* skk_context_get_candidates (SkkContext* self) {
	SkkCandidateList* result;
	GSList* _tmp0_;
	gconstpointer _tmp1_;
	SkkCandidateList* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = ((SkkState*) _tmp1_)->candidates;
	result = _tmp2_;
	return result;
}


SkkInputMode skk_context_get_input_mode (SkkContext* self) {
	SkkInputMode result;
	GSList* _tmp0_;
	gconstpointer _tmp1_;
	SkkInputMode _tmp2_;
	SkkInputMode _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = skk_state_get_input_mode ((SkkState*) _tmp1_);
	_tmp3_ = _tmp2_;
	result = _tmp3_;
	return result;
}


void skk_context_set_input_mode (SkkContext* self, SkkInputMode value) {
	GSList* _tmp0_;
	gconstpointer _tmp1_;
	SkkInputMode _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = value;
	skk_state_set_input_mode ((SkkState*) _tmp1_, _tmp2_);
	g_object_notify ((GObject *) self, "input-mode");
}


gchar** skk_context_get_auto_start_henkan_keywords (SkkContext* self, int* result_length1) {
	gchar** result;
	GSList* _tmp0_;
	gconstpointer _tmp1_;
	gchar** _tmp2_;
	gint _tmp2__length1;
	gchar** _tmp3_;
	gint _tmp3__length1;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = ((SkkState*) _tmp1_)->auto_start_henkan_keywords;
	_tmp2__length1 = ((SkkState*) _tmp1_)->auto_start_henkan_keywords_length1;
	_tmp3_ = _tmp2_;
	_tmp3__length1 = _tmp2__length1;
	if (result_length1) {
		*result_length1 = _tmp3__length1;
	}
	result = _tmp3_;
	return result;
}


static gchar** _vala_array_dup3 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


void skk_context_set_auto_start_henkan_keywords (SkkContext* self, gchar** value, int value_length1) {
	GSList* _tmp0_;
	gconstpointer _tmp1_;
	gchar** _tmp2_;
	gint _tmp2__length1;
	gchar** _tmp3_;
	gint _tmp3__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = value;
	_tmp2__length1 = value_length1;
	_tmp3_ = (_tmp2_ != NULL) ? _vala_array_dup3 (_tmp2_, _tmp2__length1) : ((gpointer) _tmp2_);
	_tmp3__length1 = _tmp2__length1;
	((SkkState*) _tmp1_)->auto_start_henkan_keywords = (_vala_array_free (((SkkState*) _tmp1_)->auto_start_henkan_keywords, ((SkkState*) _tmp1_)->auto_start_henkan_keywords_length1, (GDestroyNotify) g_free), NULL);
	((SkkState*) _tmp1_)->auto_start_henkan_keywords = _tmp3_;
	((SkkState*) _tmp1_)->auto_start_henkan_keywords_length1 = _tmp3__length1;
	((SkkState*) _tmp1_)->_auto_start_henkan_keywords_size_ = ((SkkState*) _tmp1_)->auto_start_henkan_keywords_length1;
	g_object_notify ((GObject *) self, "auto-start-henkan-keywords");
}


gboolean skk_context_get_egg_like_newline (SkkContext* self) {
	gboolean result;
	GSList* _tmp0_;
	gconstpointer _tmp1_;
	gboolean _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = ((SkkState*) _tmp1_)->egg_like_newline;
	result = _tmp2_;
	return result;
}


void skk_context_set_egg_like_newline (SkkContext* self, gboolean value) {
	GSList* _tmp0_;
	gconstpointer _tmp1_;
	gboolean _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = value;
	((SkkState*) _tmp1_)->egg_like_newline = _tmp2_;
	g_object_notify ((GObject *) self, "egg-like-newline");
}


SkkPeriodStyle skk_context_get_period_style (SkkContext* self) {
	SkkPeriodStyle result;
	GSList* _tmp0_;
	gconstpointer _tmp1_;
	SkkPeriodStyle _tmp2_;
	SkkPeriodStyle _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = skk_state_get_period_style ((SkkState*) _tmp1_);
	_tmp3_ = _tmp2_;
	result = _tmp3_;
	return result;
}


void skk_context_set_period_style (SkkContext* self, SkkPeriodStyle value) {
	GSList* _tmp0_;
	gconstpointer _tmp1_;
	SkkPeriodStyle _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = value;
	skk_state_set_period_style ((SkkState*) _tmp1_, _tmp2_);
	g_object_notify ((GObject *) self, "period-style");
}


SkkRule* skk_context_get_typing_rule (SkkContext* self) {
	SkkRule* result;
	GSList* _tmp0_;
	gconstpointer _tmp1_;
	SkkRule* _tmp2_;
	SkkRule* _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = skk_state_get_typing_rule ((SkkState*) _tmp1_);
	_tmp3_ = _tmp2_;
	result = _tmp3_;
	return result;
}


static void _skk_context_typing_rule___lambda8_ (SkkContext* self, SkkKeyEvent* key) {
	SkkKeyEvent* _tmp0_;
	g_return_if_fail (key != NULL);
	_tmp0_ = key;
	skk_context_process_key_event_internal (self, _tmp0_);
}


static void __skk_context_typing_rule___lambda8__skk_key_event_filter_forwarded (SkkKeyEventFilter* _sender, SkkKeyEvent* key, gpointer self) {
	_skk_context_typing_rule___lambda8_ (self, key);
}


void skk_context_set_typing_rule (SkkContext* self, SkkRule* value) {
	GSList* _tmp0_;
	gconstpointer _tmp1_;
	SkkRule* _tmp2_;
	SkkRule* _tmp3_;
	SkkRule* rule;
	SkkKeyEventFilter* _tmp4_ = NULL;
	SkkKeyEventFilter* filter;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = value;
	skk_state_set_typing_rule ((SkkState*) _tmp1_, _tmp2_);
	_tmp3_ = _g_object_ref0 (_tmp2_);
	rule = _tmp3_;
	_tmp4_ = skk_rule_get_filter (rule);
	filter = _tmp4_;
	g_signal_connect_object (filter, "forwarded", (GCallback) __skk_context_typing_rule___lambda8__skk_key_event_filter_forwarded, self, 0);
	_g_object_unref0 (filter);
	_g_object_unref0 (rule);
	g_object_notify ((GObject *) self, "typing-rule");
}


SkkKeyEventFilter* skk_context_get_key_event_filter (SkkContext* self) {
	SkkKeyEventFilter* result;
	GSList* _tmp0_;
	gconstpointer _tmp1_;
	SkkRule* _tmp2_;
	SkkRule* _tmp3_;
	SkkKeyEventFilter* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = skk_state_get_typing_rule ((SkkState*) _tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = skk_rule_get_filter (_tmp3_);
	result = _tmp4_;
	return result;
}


const gchar* skk_context_get_preedit (SkkContext* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_preedit;
	result = _tmp0_;
	return result;
}


static void skk_context_set_preedit (SkkContext* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_preedit);
	self->priv->_preedit = _tmp1_;
}


static void g_cclosure_user_marshal_BOOLEAN__POINTER_POINTER (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef gboolean (*GMarshalFunc_BOOLEAN__POINTER_POINTER) (gpointer data1, gpointer arg_1, gpointer arg_2, gpointer data2);
	register GMarshalFunc_BOOLEAN__POINTER_POINTER callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	gboolean v_return;
	cc = (GCClosure *) closure;
	g_return_if_fail (return_value != NULL);
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_BOOLEAN__POINTER_POINTER) (marshal_data ? marshal_data : cc->callback);
	v_return = callback (data1, g_value_get_pointer (param_values + 1), g_value_get_pointer (param_values + 2), data2);
	g_value_set_boolean (return_value, v_return);
}


static void g_cclosure_user_marshal_BOOLEAN__INT_UINT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef gboolean (*GMarshalFunc_BOOLEAN__INT_UINT) (gpointer data1, gint arg_1, guint arg_2, gpointer data2);
	register GMarshalFunc_BOOLEAN__INT_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	gboolean v_return;
	cc = (GCClosure *) closure;
	g_return_if_fail (return_value != NULL);
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_BOOLEAN__INT_UINT) (marshal_data ? marshal_data : cc->callback);
	v_return = callback (data1, g_value_get_int (param_values + 1), g_value_get_uint (param_values + 2), data2);
	g_value_set_boolean (return_value, v_return);
}


static void skk_context_class_init (SkkContextClass * klass) {
	skk_context_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SkkContextPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_skk_context_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_skk_context_set_property;
	G_OBJECT_CLASS (klass)->finalize = skk_context_finalize;
	/**
	         * Current candidates.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_CANDIDATES, g_param_spec_object ("candidates", "candidates", "candidates", SKK_TYPE_CANDIDATE_LIST, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	         * Current input mode.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_INPUT_MODE, g_param_spec_enum ("input-mode", "input-mode", "input-mode", SKK_TYPE_INPUT_MODE, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	         * Array of strings which triggers automatic conversion.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_AUTO_START_HENKAN_KEYWORDS, g_param_spec_boxed ("auto-start-henkan-keywords", "auto-start-henkan-keywords", "auto-start-henkan-keywords", G_TYPE_STRV, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	         * Flag to indicate whether or not "\n" is consumed on commit.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_EGG_LIKE_NEWLINE, g_param_spec_boolean ("egg-like-newline", "egg-like-newline", "egg-like-newline", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	         * Period style used in romaji-to-kana conversion.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_PERIOD_STYLE, g_param_spec_enum ("period-style", "period-style", "period-style", SKK_TYPE_PERIOD_STYLE, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	         * The name of typing rule.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_TYPING_RULE, g_param_spec_object ("typing-rule", "typing-rule", "typing-rule", SKK_TYPE_RULE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	         * Filter which runs before process_key_event.
	         *
	         * This is particularly useful for NICOLA.
	         * @see NicolaKeyEventFilter
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_KEY_EVENT_FILTER, g_param_spec_object ("key-event-filter", "key-event-filter", "key-event-filter", SKK_TYPE_KEY_EVENT_FILTER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	         * Current preedit string.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_PREEDIT, g_param_spec_string ("preedit", "preedit", "preedit", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	         * Signal emitted when the context requires surrounding-text.
	         *
	         * @param text surrounding text
	         * @param cursor_pos cursor position in text
	         *
	         * @return `true` on success, `false` on failure
	         */
	g_signal_new ("retrieve_surrounding_text", SKK_TYPE_CONTEXT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_BOOLEAN__POINTER_POINTER, G_TYPE_BOOLEAN, 2, G_TYPE_POINTER, G_TYPE_POINTER);
	/**
	         * Signal emitted when the context requests deletion of
	         * surrounding-text.
	         *
	         * @param offset character offset from the cursor position.
	         * @param nchars number of characters to delete.
	         *
	         * @return `true` on success, `false` on failure
	         */
	g_signal_new ("delete_surrounding_text", SKK_TYPE_CONTEXT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_BOOLEAN__INT_UINT, G_TYPE_BOOLEAN, 2, G_TYPE_INT, G_TYPE_UINT);
}


static void skk_context_instance_init (SkkContext * self) {
	GeeArrayList* _tmp0_;
	GeeHashMap* _tmp1_;
	gchar* _tmp2_;
	self->priv = SKK_CONTEXT_GET_PRIVATE (self);
	_tmp0_ = gee_array_list_new (SKK_TYPE_DICT, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->_dictionaries = _tmp0_;
	_tmp1_ = gee_hash_map_new (G_TYPE_GTYPE, NULL, NULL, SKK_TYPE_STATE_HANDLER, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	self->priv->handlers = _tmp1_;
	_tmp2_ = g_strdup ("");
	self->priv->_preedit = _tmp2_;
	self->priv->preedit_underline_offset = (guint) 0;
	self->priv->preedit_underline_nchars = (guint) 0;
}


static void skk_context_finalize (GObject* obj) {
	SkkContext * self;
	GeeArrayList* _tmp0_;
	self = SKK_CONTEXT (obj);
	_tmp0_ = self->priv->_dictionaries;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp0_);
	_g_object_unref0 (self->priv->_dictionaries);
	__g_slist_free__g_object_unref0_0 (self->priv->state_stack);
	_g_object_unref0 (self->priv->handlers);
	_g_free0 (self->priv->_preedit);
	G_OBJECT_CLASS (skk_context_parent_class)->finalize (obj);
}


/**
     * The main entry point of libskk.
     *
     * Context represents an input context with support for SKK
     * kana-kanji conversion method.
     */
GType skk_context_get_type (void) {
	static volatile gsize skk_context_type_id__volatile = 0;
	if (g_once_init_enter (&skk_context_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SkkContextClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) skk_context_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SkkContext), 0, (GInstanceInitFunc) skk_context_instance_init, NULL };
		GType skk_context_type_id;
		skk_context_type_id = g_type_register_static (G_TYPE_OBJECT, "SkkContext", &g_define_type_info, 0);
		g_once_init_leave (&skk_context_type_id__volatile, skk_context_type_id);
	}
	return skk_context_type_id__volatile;
}


static void _vala_skk_context_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SkkContext * self;
	self = SKK_CONTEXT (object);
	switch (property_id) {
		case SKK_CONTEXT_CANDIDATES:
		g_value_set_object (value, skk_context_get_candidates (self));
		break;
		case SKK_CONTEXT_INPUT_MODE:
		g_value_set_enum (value, skk_context_get_input_mode (self));
		break;
		case SKK_CONTEXT_AUTO_START_HENKAN_KEYWORDS:
		{
			int length;
			g_value_set_boxed (value, skk_context_get_auto_start_henkan_keywords (self, &length));
		}
		break;
		case SKK_CONTEXT_EGG_LIKE_NEWLINE:
		g_value_set_boolean (value, skk_context_get_egg_like_newline (self));
		break;
		case SKK_CONTEXT_PERIOD_STYLE:
		g_value_set_enum (value, skk_context_get_period_style (self));
		break;
		case SKK_CONTEXT_TYPING_RULE:
		g_value_set_object (value, skk_context_get_typing_rule (self));
		break;
		case SKK_CONTEXT_KEY_EVENT_FILTER:
		g_value_take_object (value, skk_context_get_key_event_filter (self));
		break;
		case SKK_CONTEXT_PREEDIT:
		g_value_set_string (value, skk_context_get_preedit (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_skk_context_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SkkContext * self;
	self = SKK_CONTEXT (object);
	switch (property_id) {
		case SKK_CONTEXT_INPUT_MODE:
		skk_context_set_input_mode (self, g_value_get_enum (value));
		break;
		case SKK_CONTEXT_AUTO_START_HENKAN_KEYWORDS:
		{
			gpointer boxed;
			boxed = g_value_get_boxed (value);
			skk_context_set_auto_start_henkan_keywords (self, boxed, g_strv_length (boxed));
		}
		break;
		case SKK_CONTEXT_EGG_LIKE_NEWLINE:
		skk_context_set_egg_like_newline (self, g_value_get_boolean (value));
		break;
		case SKK_CONTEXT_PERIOD_STYLE:
		skk_context_set_period_style (self, g_value_get_enum (value));
		break;
		case SKK_CONTEXT_TYPING_RULE:
		skk_context_set_typing_rule (self, g_value_get_object (value));
		break;
		case SKK_CONTEXT_PREEDIT:
		skk_context_set_preedit (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



