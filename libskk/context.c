/* context.c generated by valac 0.14.0, the Vala compiler
 * generated from context.vala, do not modify */

/*
 * Copyright (C) 2011-2012 Daiki Ueno <ueno@unixuser.org>
 * Copyright (C) 2011-2012 Red Hat, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>


#define SKK_TYPE_UTIL (skk_util_get_type ())
#define SKK_UTIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_UTIL, SkkUtil))
#define SKK_UTIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_UTIL, SkkUtilClass))
#define SKK_IS_UTIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_UTIL))
#define SKK_IS_UTIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_UTIL))
#define SKK_UTIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_UTIL, SkkUtilClass))

typedef struct _SkkUtil SkkUtil;
typedef struct _SkkUtilClass SkkUtilClass;
#define _g_type_class_unref0(var) ((var == NULL) ? NULL : (var = (g_type_class_unref (var), NULL)))

#define SKK_TYPE_RULE (skk_rule_get_type ())
#define SKK_RULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_RULE, SkkRule))
#define SKK_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_RULE, SkkRuleClass))
#define SKK_IS_RULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_RULE))
#define SKK_IS_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_RULE))
#define SKK_RULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_RULE, SkkRuleClass))

typedef struct _SkkRule SkkRule;
typedef struct _SkkRuleClass SkkRuleClass;

#define SKK_TYPE_KANA_MODE (skk_kana_mode_get_type ())

#define SKK_TYPE_INPUT_MODE (skk_input_mode_get_type ())

#define SKK_TYPE_CONTEXT (skk_context_get_type ())
#define SKK_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_CONTEXT, SkkContext))
#define SKK_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_CONTEXT, SkkContextClass))
#define SKK_IS_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_CONTEXT))
#define SKK_IS_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_CONTEXT))
#define SKK_CONTEXT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_CONTEXT, SkkContextClass))

typedef struct _SkkContext SkkContext;
typedef struct _SkkContextClass SkkContextClass;
typedef struct _SkkContextPrivate SkkContextPrivate;

#define SKK_TYPE_DICT (skk_dict_get_type ())
#define SKK_DICT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_DICT, SkkDict))
#define SKK_DICT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_DICT, SkkDictClass))
#define SKK_IS_DICT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_DICT))
#define SKK_IS_DICT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_DICT))
#define SKK_DICT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_DICT, SkkDictClass))

typedef struct _SkkDict SkkDict;
typedef struct _SkkDictClass SkkDictClass;

#define SKK_TYPE_CANDIDATE_LIST (skk_candidate_list_get_type ())
#define SKK_CANDIDATE_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_CANDIDATE_LIST, SkkCandidateList))
#define SKK_CANDIDATE_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_CANDIDATE_LIST, SkkCandidateListClass))
#define SKK_IS_CANDIDATE_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_CANDIDATE_LIST))
#define SKK_IS_CANDIDATE_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_CANDIDATE_LIST))
#define SKK_CANDIDATE_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_CANDIDATE_LIST, SkkCandidateListClass))

typedef struct _SkkCandidateList SkkCandidateList;
typedef struct _SkkCandidateListClass SkkCandidateListClass;

#define SKK_TYPE_STATE (skk_state_get_type ())
#define SKK_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_STATE, SkkState))
#define SKK_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_STATE, SkkStateClass))
#define SKK_IS_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_STATE))
#define SKK_IS_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_STATE))
#define SKK_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_STATE, SkkStateClass))

typedef struct _SkkState SkkState;
typedef struct _SkkStateClass SkkStateClass;

#define SKK_TYPE_STATE_HANDLER (skk_state_handler_get_type ())
#define SKK_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_STATE_HANDLER, SkkStateHandler))
#define SKK_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_STATE_HANDLER, SkkStateHandlerClass))
#define SKK_IS_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_STATE_HANDLER))
#define SKK_IS_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_STATE_HANDLER))
#define SKK_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_STATE_HANDLER, SkkStateHandlerClass))

typedef struct _SkkStateHandler SkkStateHandler;
typedef struct _SkkStateHandlerClass SkkStateHandlerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define SKK_TYPE_KEY_EVENT (skk_key_event_get_type ())
#define SKK_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_KEY_EVENT, SkkKeyEvent))
#define SKK_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_KEY_EVENT, SkkKeyEventClass))
#define SKK_IS_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_KEY_EVENT))
#define SKK_IS_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_KEY_EVENT))
#define SKK_KEY_EVENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_KEY_EVENT, SkkKeyEventClass))

typedef struct _SkkKeyEvent SkkKeyEvent;
typedef struct _SkkKeyEventClass SkkKeyEventClass;

#define SKK_TYPE_NONE_STATE_HANDLER (skk_none_state_handler_get_type ())
#define SKK_NONE_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_NONE_STATE_HANDLER, SkkNoneStateHandler))
#define SKK_NONE_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_NONE_STATE_HANDLER, SkkNoneStateHandlerClass))
#define SKK_IS_NONE_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_NONE_STATE_HANDLER))
#define SKK_IS_NONE_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_NONE_STATE_HANDLER))
#define SKK_NONE_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_NONE_STATE_HANDLER, SkkNoneStateHandlerClass))

typedef struct _SkkNoneStateHandler SkkNoneStateHandler;
typedef struct _SkkNoneStateHandlerClass SkkNoneStateHandlerClass;

#define SKK_TYPE_START_STATE_HANDLER (skk_start_state_handler_get_type ())
#define SKK_START_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_START_STATE_HANDLER, SkkStartStateHandler))
#define SKK_START_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_START_STATE_HANDLER, SkkStartStateHandlerClass))
#define SKK_IS_START_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_START_STATE_HANDLER))
#define SKK_IS_START_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_START_STATE_HANDLER))
#define SKK_START_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_START_STATE_HANDLER, SkkStartStateHandlerClass))

typedef struct _SkkStartStateHandler SkkStartStateHandler;
typedef struct _SkkStartStateHandlerClass SkkStartStateHandlerClass;

#define SKK_TYPE_SELECT_STATE_HANDLER (skk_select_state_handler_get_type ())
#define SKK_SELECT_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_SELECT_STATE_HANDLER, SkkSelectStateHandler))
#define SKK_SELECT_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_SELECT_STATE_HANDLER, SkkSelectStateHandlerClass))
#define SKK_IS_SELECT_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_SELECT_STATE_HANDLER))
#define SKK_IS_SELECT_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_SELECT_STATE_HANDLER))
#define SKK_SELECT_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_SELECT_STATE_HANDLER, SkkSelectStateHandlerClass))

typedef struct _SkkSelectStateHandler SkkSelectStateHandler;
typedef struct _SkkSelectStateHandlerClass SkkSelectStateHandlerClass;

#define SKK_TYPE_ABBREV_STATE_HANDLER (skk_abbrev_state_handler_get_type ())
#define SKK_ABBREV_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_ABBREV_STATE_HANDLER, SkkAbbrevStateHandler))
#define SKK_ABBREV_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_ABBREV_STATE_HANDLER, SkkAbbrevStateHandlerClass))
#define SKK_IS_ABBREV_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_ABBREV_STATE_HANDLER))
#define SKK_IS_ABBREV_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_ABBREV_STATE_HANDLER))
#define SKK_ABBREV_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_ABBREV_STATE_HANDLER, SkkAbbrevStateHandlerClass))

typedef struct _SkkAbbrevStateHandler SkkAbbrevStateHandler;
typedef struct _SkkAbbrevStateHandlerClass SkkAbbrevStateHandlerClass;

#define SKK_TYPE_KUTEN_STATE_HANDLER (skk_kuten_state_handler_get_type ())
#define SKK_KUTEN_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_KUTEN_STATE_HANDLER, SkkKutenStateHandler))
#define SKK_KUTEN_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_KUTEN_STATE_HANDLER, SkkKutenStateHandlerClass))
#define SKK_IS_KUTEN_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_KUTEN_STATE_HANDLER))
#define SKK_IS_KUTEN_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_KUTEN_STATE_HANDLER))
#define SKK_KUTEN_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_KUTEN_STATE_HANDLER, SkkKutenStateHandlerClass))

typedef struct _SkkKutenStateHandler SkkKutenStateHandler;
typedef struct _SkkKutenStateHandlerClass SkkKutenStateHandlerClass;
typedef struct _SkkStatePrivate SkkStatePrivate;

#define SKK_TYPE_ROM_KANA_CONVERTER (skk_rom_kana_converter_get_type ())
#define SKK_ROM_KANA_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_ROM_KANA_CONVERTER, SkkRomKanaConverter))
#define SKK_ROM_KANA_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_ROM_KANA_CONVERTER, SkkRomKanaConverterClass))
#define SKK_IS_ROM_KANA_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_ROM_KANA_CONVERTER))
#define SKK_IS_ROM_KANA_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_ROM_KANA_CONVERTER))
#define SKK_ROM_KANA_CONVERTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_ROM_KANA_CONVERTER, SkkRomKanaConverterClass))

typedef struct _SkkRomKanaConverter SkkRomKanaConverter;
typedef struct _SkkRomKanaConverterClass SkkRomKanaConverterClass;

#define SKK_TYPE_UNICODE_STRING (skk_unicode_string_get_type ())
#define SKK_UNICODE_STRING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_UNICODE_STRING, SkkUnicodeString))
#define SKK_UNICODE_STRING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_UNICODE_STRING, SkkUnicodeStringClass))
#define SKK_IS_UNICODE_STRING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_UNICODE_STRING))
#define SKK_IS_UNICODE_STRING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_UNICODE_STRING))
#define SKK_UNICODE_STRING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_UNICODE_STRING, SkkUnicodeStringClass))

typedef struct _SkkUnicodeString SkkUnicodeString;
typedef struct _SkkUnicodeStringClass SkkUnicodeStringClass;

#define SKK_TYPE_PROXY_CANDIDATE_LIST (skk_proxy_candidate_list_get_type ())
#define SKK_PROXY_CANDIDATE_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_PROXY_CANDIDATE_LIST, SkkProxyCandidateList))
#define SKK_PROXY_CANDIDATE_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_PROXY_CANDIDATE_LIST, SkkProxyCandidateListClass))
#define SKK_IS_PROXY_CANDIDATE_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_PROXY_CANDIDATE_LIST))
#define SKK_IS_PROXY_CANDIDATE_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_PROXY_CANDIDATE_LIST))
#define SKK_PROXY_CANDIDATE_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_PROXY_CANDIDATE_LIST, SkkProxyCandidateListClass))

typedef struct _SkkProxyCandidateList SkkProxyCandidateList;
typedef struct _SkkProxyCandidateListClass SkkProxyCandidateListClass;

#define SKK_TYPE_CANDIDATE (skk_candidate_get_type ())
#define SKK_CANDIDATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_CANDIDATE, SkkCandidate))
#define SKK_CANDIDATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_CANDIDATE, SkkCandidateClass))
#define SKK_IS_CANDIDATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_CANDIDATE))
#define SKK_IS_CANDIDATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_CANDIDATE))
#define SKK_CANDIDATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_CANDIDATE, SkkCandidateClass))

typedef struct _SkkCandidate SkkCandidate;
typedef struct _SkkCandidateClass SkkCandidateClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

#define SKK_TYPE_KEY_EVENT_FILTER (skk_key_event_filter_get_type ())
#define SKK_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_KEY_EVENT_FILTER, SkkKeyEventFilter))
#define SKK_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_KEY_EVENT_FILTER, SkkKeyEventFilterClass))
#define SKK_IS_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_KEY_EVENT_FILTER))
#define SKK_IS_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_KEY_EVENT_FILTER))
#define SKK_KEY_EVENT_FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_KEY_EVENT_FILTER, SkkKeyEventFilterClass))

typedef struct _SkkKeyEventFilter SkkKeyEventFilter;
typedef struct _SkkKeyEventFilterClass SkkKeyEventFilterClass;

#define SKK_TYPE_PERIOD_STYLE (skk_period_style_get_type ())

typedef enum  {
	SKK_KANA_MODE_HIRAGANA,
	SKK_KANA_MODE_KATAKANA,
	SKK_KANA_MODE_HANKAKU_KATAKANA
} SkkKanaMode;

typedef enum  {
	SKK_INPUT_MODE_HIRAGANA = SKK_KANA_MODE_HIRAGANA,
	SKK_INPUT_MODE_KATAKANA = SKK_KANA_MODE_KATAKANA,
	SKK_INPUT_MODE_HANKAKU_KATAKANA = SKK_KANA_MODE_HANKAKU_KATAKANA,
	SKK_INPUT_MODE_LATIN,
	SKK_INPUT_MODE_WIDE_LATIN,
	SKK_INPUT_MODE_LAST,
	SKK_INPUT_MODE_DEFAULT = SKK_INPUT_MODE_HIRAGANA
} SkkInputMode;

struct _SkkContext {
	GObject parent_instance;
	SkkContextPrivate * priv;
};

struct _SkkContextClass {
	GObjectClass parent_class;
};

struct _SkkContextPrivate {
	GeeList* _dictionaries;
	SkkCandidateList* _candidates;
	GeeLinkedList* state_stack;
	GeeMap* handlers;
	gchar* _preedit;
	guint preedit_underline_offset;
	guint preedit_underline_nchars;
};

struct _SkkState {
	GObject parent_instance;
	SkkStatePrivate * priv;
	GType handler_type;
	GeeList* dictionaries;
	SkkCandidateList* candidates;
	SkkRomKanaConverter* rom_kana_converter;
	SkkRomKanaConverter* okuri_rom_kana_converter;
	gboolean okuri;
	gchar* midasi;
	GString* output;
	GString* abbrev;
	GString* kuten;
	GeeIterator* completion_iterator;
	gchar** auto_start_henkan_keywords;
	gint auto_start_henkan_keywords_length1;
	gint _auto_start_henkan_keywords_size_;
	gchar* auto_start_henkan_keyword;
	gboolean egg_like_newline;
	SkkUnicodeString* surrounding_text;
	guint surrounding_end;
};

struct _SkkStateClass {
	GObjectClass parent_class;
};

typedef enum  {
	SKK_PERIOD_STYLE_JA_JA,
	SKK_PERIOD_STYLE_EN_EN,
	SKK_PERIOD_STYLE_JA_EN,
	SKK_PERIOD_STYLE_EN_JA
} SkkPeriodStyle;


static gpointer skk_context_parent_class = NULL;

void skk_init (void);
GType skk_util_get_type (void) G_GNUC_CONST;
GType skk_rule_get_type (void) G_GNUC_CONST;
GType skk_kana_mode_get_type (void) G_GNUC_CONST;
GType skk_input_mode_get_type (void) G_GNUC_CONST;
GType skk_context_get_type (void) G_GNUC_CONST;
GType skk_dict_get_type (void) G_GNUC_CONST;
GType skk_candidate_list_get_type (void) G_GNUC_CONST;
GType skk_state_get_type (void) G_GNUC_CONST;
GType skk_state_handler_get_type (void) G_GNUC_CONST;
#define SKK_CONTEXT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SKK_TYPE_CONTEXT, SkkContextPrivate))
enum  {
	SKK_CONTEXT_DUMMY_PROPERTY,
	SKK_CONTEXT_CANDIDATES,
	SKK_CONTEXT_INPUT_MODE,
	SKK_CONTEXT_AUTO_START_HENKAN_KEYWORDS,
	SKK_CONTEXT_EGG_LIKE_NEWLINE,
	SKK_CONTEXT_PERIOD_STYLE,
	SKK_CONTEXT_TYPING_RULE,
	SKK_CONTEXT_KEY_EVENT_FILTER,
	SKK_CONTEXT_PREEDIT
};
void skk_context_add_dictionary (SkkContext* self, SkkDict* dict);
void skk_context_remove_dictionary (SkkContext* self, SkkDict* dict);
GType skk_key_event_get_type (void) G_GNUC_CONST;
static void skk_context_filter_forwarded_cb (SkkContext* self, SkkKeyEvent* key);
static gboolean skk_context_process_key_event_internal (SkkContext* self, SkkKeyEvent* key);
SkkContext* skk_context_new (SkkDict** dictionaries, int dictionaries_length1);
SkkContext* skk_context_construct (GType object_type, SkkDict** dictionaries, int dictionaries_length1);
GType skk_none_state_handler_get_type (void) G_GNUC_CONST;
SkkNoneStateHandler* skk_none_state_handler_new (void);
SkkNoneStateHandler* skk_none_state_handler_construct (GType object_type);
GType skk_start_state_handler_get_type (void) G_GNUC_CONST;
SkkStartStateHandler* skk_start_state_handler_new (void);
SkkStartStateHandler* skk_start_state_handler_construct (GType object_type);
GType skk_select_state_handler_get_type (void) G_GNUC_CONST;
SkkSelectStateHandler* skk_select_state_handler_new (void);
SkkSelectStateHandler* skk_select_state_handler_construct (GType object_type);
GType skk_abbrev_state_handler_get_type (void) G_GNUC_CONST;
SkkAbbrevStateHandler* skk_abbrev_state_handler_new (void);
SkkAbbrevStateHandler* skk_abbrev_state_handler_construct (GType object_type);
GType skk_kuten_state_handler_get_type (void) G_GNUC_CONST;
SkkKutenStateHandler* skk_kuten_state_handler_new (void);
SkkKutenStateHandler* skk_kuten_state_handler_construct (GType object_type);
SkkState* skk_state_new (GeeList* dictionaries);
SkkState* skk_state_construct (GType object_type, GeeList* dictionaries);
GType skk_rom_kana_converter_get_type (void) G_GNUC_CONST;
GType skk_unicode_string_get_type (void) G_GNUC_CONST;
SkkProxyCandidateList* skk_proxy_candidate_list_new (SkkCandidateList* candidates);
SkkProxyCandidateList* skk_proxy_candidate_list_construct (GType object_type, SkkCandidateList* candidates);
GType skk_proxy_candidate_list_get_type (void) G_GNUC_CONST;
static void skk_context_push_state (SkkContext* self, SkkState* state);
static void __lambda3_ (SkkContext* self);
gint skk_candidate_list_get_cursor_pos (SkkCandidateList* self);
static void skk_context_update_preedit (SkkContext* self);
static void ___lambda3__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
GType skk_candidate_get_type (void) G_GNUC_CONST;
static void __lambda4_ (SkkContext* self, SkkCandidate* candidate);
static gboolean skk_context_select_candidate_in_dictionaries (SkkContext* self, SkkCandidate* candidate);
void skk_context_save_dictionaries (SkkContext* self, GError** error);
static void ___lambda4__skk_candidate_list_selected (SkkCandidateList* _sender, SkkCandidate* candidate, gpointer self);
static void skk_context_notify_input_mode_cb (SkkContext* self, GObject* s, GParamSpec* p);
static gboolean skk_context_retrieve_surrounding_text_cb (SkkContext* self, gchar** text, guint* cursor_pos);
static gboolean skk_context_delete_surrounding_text_cb (SkkContext* self, gint offset, guint nchars);
static void skk_context_connect_state_signals (SkkContext* self, SkkState* state);
static void skk_context_start_dict_edit (SkkContext* self, const gchar* midasi, gboolean okuri);
static void _skk_context_start_dict_edit_skk_state_recursive_edit_start (SkkState* _sender, const gchar* midasi, gboolean okuri, gpointer self);
static gboolean skk_context_end_dict_edit (SkkContext* self, const gchar* text);
static gboolean _skk_context_end_dict_edit_skk_state_recursive_edit_end (SkkState* _sender, const gchar* text, gpointer self);
static gboolean skk_context_abort_dict_edit (SkkContext* self);
static gboolean _skk_context_abort_dict_edit_skk_state_recursive_edit_abort (SkkState* _sender, gpointer self);
static void _skk_context_notify_input_mode_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static gboolean _skk_context_retrieve_surrounding_text_cb_skk_state_retrieve_surrounding_text (SkkState* _sender, gchar** text, guint* cursor_pos, gpointer self);
static gboolean _skk_context_delete_surrounding_text_cb_skk_state_delete_surrounding_text (SkkState* _sender, gint offset, guint nchars, gpointer self);
static void skk_context_disconnect_state_signals (SkkContext* self, SkkState* state);
SkkDict** skk_context_get_dictionaries (SkkContext* self, int* result_length1);
gboolean skk_dict_get_read_only (SkkDict* self);
gboolean skk_dict_select_candidate (SkkDict* self, SkkCandidate* candidate);
static guint skk_context_dict_edit_level (SkkContext* self);
SkkCandidateList* skk_proxy_candidate_list_get_candidates (SkkProxyCandidateList* self);
void skk_proxy_candidate_list_set_candidates (SkkProxyCandidateList* self, SkkCandidateList* value);
static void skk_context_pop_state (SkkContext* self);
static gboolean skk_context_leave_dict_edit (SkkContext* self, gchar** midasi, gboolean** okuri);
SkkCandidate* skk_candidate_new (const gchar* midasi, gboolean okuri, const gchar* text, const gchar* annotation, const gchar* output);
SkkCandidate* skk_candidate_construct (GType object_type, const gchar* midasi, gboolean okuri, const gchar* text, const gchar* annotation, const gchar* output);
void skk_state_reset (SkkState* self);
static gboolean* _bool_dup (gboolean* self);
void skk_state_cancel_okuri (SkkState* self);
gboolean skk_context_process_key_events (SkkContext* self, const gchar* keyseq);
SkkKeyEvent* skk_key_event_new_from_string (const gchar* key);
SkkKeyEvent* skk_key_event_construct_from_string (GType object_type, const gchar* key);
gboolean skk_context_process_key_event (SkkContext* self, SkkKeyEvent* key);
GType skk_key_event_filter_get_type (void) G_GNUC_CONST;
SkkKeyEventFilter* skk_context_get_key_event_filter (SkkContext* self);
SkkKeyEvent* skk_key_event_filter_filter_key_event (SkkKeyEventFilter* self, SkkKeyEvent* key);
SkkKeyEvent* skk_key_event_copy (SkkKeyEvent* self);
gboolean skk_state_handler_process_key_event (SkkStateHandler* self, SkkState* state, SkkKeyEvent** key);
void skk_context_reset (SkkContext* self);
void skk_state_output_surrounding_text (SkkState* self);
gchar* skk_context_get_output (SkkContext* self);
gchar* skk_context_poll_output (SkkContext* self);
static gchar* skk_context_retrieve_output (SkkContext* self, gboolean clear);
gchar* skk_state_handler_get_output (SkkStateHandler* self, SkkState* state);
gchar* skk_context_peek_output (SkkContext* self);
void skk_context_clear_output (SkkContext* self);
gchar* skk_state_handler_get_preedit (SkkStateHandler* self, SkkState* state, guint* underline_offset, guint* underline_nchars);
const gchar* skk_context_get_preedit (SkkContext* self);
static void skk_context_set_preedit (SkkContext* self, const gchar* value);
void skk_context_get_preedit_underline (SkkContext* self, guint* offset, guint* nchars);
void skk_dict_save (SkkDict* self, GError** error);
void skk_context_set_dictionaries (SkkContext* self, SkkDict** value, int value_length1);
SkkCandidateList* skk_context_get_candidates (SkkContext* self);
SkkInputMode skk_context_get_input_mode (SkkContext* self);
SkkInputMode skk_state_get_input_mode (SkkState* self);
void skk_context_set_input_mode (SkkContext* self, SkkInputMode value);
void skk_state_set_input_mode (SkkState* self, SkkInputMode value);
gchar** skk_context_get_auto_start_henkan_keywords (SkkContext* self, int* result_length1);
void skk_context_set_auto_start_henkan_keywords (SkkContext* self, gchar** value, int value_length1);
static gchar** _vala_array_dup4 (gchar** self, int length);
gboolean skk_context_get_egg_like_newline (SkkContext* self);
void skk_context_set_egg_like_newline (SkkContext* self, gboolean value);
GType skk_period_style_get_type (void) G_GNUC_CONST;
SkkPeriodStyle skk_context_get_period_style (SkkContext* self);
SkkPeriodStyle skk_state_get_period_style (SkkState* self);
void skk_context_set_period_style (SkkContext* self, SkkPeriodStyle value);
void skk_state_set_period_style (SkkState* self, SkkPeriodStyle value);
SkkRule* skk_context_get_typing_rule (SkkContext* self);
SkkRule* skk_state_get_typing_rule (SkkState* self);
void skk_context_set_typing_rule (SkkContext* self, SkkRule* value);
SkkKeyEventFilter* skk_rule_get_filter (SkkRule* self);
static void _skk_context_filter_forwarded_cb_skk_key_event_filter_forwarded (SkkKeyEventFilter* _sender, SkkKeyEvent* key, gpointer self);
void skk_state_set_typing_rule (SkkState* self, SkkRule* value);
static void g_cclosure_user_marshal_BOOLEAN__POINTER_POINTER (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_BOOLEAN__INT_UINT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void skk_context_finalize (GObject* obj);
static void _vala_skk_context_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_skk_context_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


/**
     * Initialize libskk.
     *
     * Must be called before using any functions in libskk.
     */
void skk_init (void) {
	GTypeClass* _tmp0_ = NULL;
	GTypeClass* _tmp1_;
	GTypeClass* _tmp2_ = NULL;
	GTypeClass* _tmp3_;
	_tmp0_ = g_type_class_ref (SKK_TYPE_UTIL);
	_tmp1_ = _tmp0_;
	_g_type_class_unref0 (_tmp1_);
	_tmp2_ = g_type_class_ref (SKK_TYPE_RULE);
	_tmp3_ = _tmp2_;
	_g_type_class_unref0 (_tmp3_);
}


/**
     * Type to specify input modes.
     */
GType skk_input_mode_get_type (void) {
	static volatile gsize skk_input_mode_type_id__volatile = 0;
	if (g_once_init_enter (&skk_input_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{SKK_INPUT_MODE_HIRAGANA, "SKK_INPUT_MODE_HIRAGANA", "hiragana"}, {SKK_INPUT_MODE_KATAKANA, "SKK_INPUT_MODE_KATAKANA", "katakana"}, {SKK_INPUT_MODE_HANKAKU_KATAKANA, "SKK_INPUT_MODE_HANKAKU_KATAKANA", "hankaku-katakana"}, {SKK_INPUT_MODE_LATIN, "SKK_INPUT_MODE_LATIN", "latin"}, {SKK_INPUT_MODE_WIDE_LATIN, "SKK_INPUT_MODE_WIDE_LATIN", "wide-latin"}, {SKK_INPUT_MODE_LAST, "SKK_INPUT_MODE_LAST", "last"}, {SKK_INPUT_MODE_DEFAULT, "SKK_INPUT_MODE_DEFAULT", "default"}, {0, NULL, NULL}};
		GType skk_input_mode_type_id;
		skk_input_mode_type_id = g_enum_register_static ("SkkInputMode", values);
		g_once_init_leave (&skk_input_mode_type_id__volatile, skk_input_mode_type_id);
	}
	return skk_input_mode_type_id__volatile;
}


/**
         * Register dictionary.
         *
         * @param dict a dictionary
         * @since 0.0.8
         */
void skk_context_add_dictionary (SkkContext* self, SkkDict* dict) {
	GeeList* _tmp0_;
	SkkDict* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dict != NULL);
	_tmp0_ = self->priv->_dictionaries;
	_tmp1_ = dict;
	gee_collection_add ((GeeCollection*) _tmp0_, _tmp1_);
}


/**
         * Unregister dictionary.
         *
         * @param dict a dictionary
         * @since 0.0.8
         */
void skk_context_remove_dictionary (SkkContext* self, SkkDict* dict) {
	GeeList* _tmp0_;
	SkkDict* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dict != NULL);
	_tmp0_ = self->priv->_dictionaries;
	_tmp1_ = dict;
	gee_collection_remove ((GeeCollection*) _tmp0_, _tmp1_);
}


static void skk_context_filter_forwarded_cb (SkkContext* self, SkkKeyEvent* key) {
	SkkKeyEvent* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	_tmp0_ = key;
	skk_context_process_key_event_internal (self, _tmp0_);
}


/**
         * Create a new Context.
         *
         * @param dictionaries an array of Dict
         *
         * @return a new Context
         */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void __lambda3_ (SkkContext* self) {
	SkkCandidateList* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	_tmp0_ = self->priv->_candidates;
	_tmp1_ = skk_candidate_list_get_cursor_pos (_tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ >= 0) {
		skk_context_update_preedit (self);
	}
}


static void ___lambda3__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	__lambda3_ (self);
}


static void __lambda4_ (SkkContext* self, SkkCandidate* candidate) {
	SkkCandidate* _tmp0_;
	gboolean _tmp1_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (candidate != NULL);
	_tmp0_ = candidate;
	_tmp1_ = skk_context_select_candidate_in_dictionaries (self, _tmp0_);
	if (_tmp1_) {
		{
			skk_context_save_dictionaries (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch33_g_error;
			}
		}
		goto __finally33;
		__catch33_g_error:
		{
			GError* e = NULL;
			GError* _tmp2_;
			const gchar* _tmp3_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp2_ = e;
			_tmp3_ = _tmp2_->message;
			g_warning ("context.vala:242: error saving dictionaries %s", _tmp3_);
			_g_error_free0 (e);
		}
		__finally33:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	skk_context_update_preedit (self);
}


static void ___lambda4__skk_candidate_list_selected (SkkCandidateList* _sender, SkkCandidate* candidate, gpointer self) {
	__lambda4_ (self, candidate);
}


SkkContext* skk_context_construct (GType object_type, SkkDict** dictionaries, int dictionaries_length1) {
	SkkContext * self = NULL;
	SkkDict** _tmp0_;
	gint _tmp0__length1;
	GeeMap* _tmp3_;
	SkkNoneStateHandler* _tmp4_;
	SkkNoneStateHandler* _tmp5_;
	GeeMap* _tmp6_;
	SkkStartStateHandler* _tmp7_;
	SkkStartStateHandler* _tmp8_;
	GeeMap* _tmp9_;
	SkkSelectStateHandler* _tmp10_;
	SkkSelectStateHandler* _tmp11_;
	GeeMap* _tmp12_;
	SkkAbbrevStateHandler* _tmp13_;
	SkkAbbrevStateHandler* _tmp14_;
	GeeMap* _tmp15_;
	SkkKutenStateHandler* _tmp16_;
	SkkKutenStateHandler* _tmp17_;
	GeeList* _tmp18_;
	SkkState* _tmp19_;
	SkkState* state;
	SkkCandidateList* _tmp20_;
	SkkProxyCandidateList* _tmp21_;
	SkkCandidateList* _tmp22_;
	SkkCandidateList* _tmp23_;
	self = (SkkContext*) g_object_new (object_type, NULL);
	_tmp0_ = dictionaries;
	_tmp0__length1 = dictionaries_length1;
	{
		SkkDict** dict_collection = NULL;
		gint dict_collection_length1 = 0;
		gint _dict_collection_size_ = 0;
		gint dict_it = 0;
		dict_collection = _tmp0_;
		dict_collection_length1 = _tmp0__length1;
		for (dict_it = 0; dict_it < _tmp0__length1; dict_it = dict_it + 1) {
			SkkDict* _tmp1_;
			SkkDict* dict = NULL;
			_tmp1_ = _g_object_ref0 (dict_collection[dict_it]);
			dict = _tmp1_;
			{
				SkkDict* _tmp2_;
				_tmp2_ = dict;
				skk_context_add_dictionary (self, _tmp2_);
				_g_object_unref0 (dict);
			}
		}
	}
	_tmp3_ = self->priv->handlers;
	_tmp4_ = skk_none_state_handler_new ();
	_tmp5_ = _tmp4_;
	gee_map_set (_tmp3_, GINT_TO_POINTER (SKK_TYPE_NONE_STATE_HANDLER), (SkkStateHandler*) _tmp5_);
	_g_object_unref0 (_tmp5_);
	_tmp6_ = self->priv->handlers;
	_tmp7_ = skk_start_state_handler_new ();
	_tmp8_ = _tmp7_;
	gee_map_set (_tmp6_, GINT_TO_POINTER (SKK_TYPE_START_STATE_HANDLER), (SkkStateHandler*) _tmp8_);
	_g_object_unref0 (_tmp8_);
	_tmp9_ = self->priv->handlers;
	_tmp10_ = skk_select_state_handler_new ();
	_tmp11_ = _tmp10_;
	gee_map_set (_tmp9_, GINT_TO_POINTER (SKK_TYPE_SELECT_STATE_HANDLER), (SkkStateHandler*) _tmp11_);
	_g_object_unref0 (_tmp11_);
	_tmp12_ = self->priv->handlers;
	_tmp13_ = skk_abbrev_state_handler_new ();
	_tmp14_ = _tmp13_;
	gee_map_set (_tmp12_, GINT_TO_POINTER (SKK_TYPE_ABBREV_STATE_HANDLER), (SkkStateHandler*) _tmp14_);
	_g_object_unref0 (_tmp14_);
	_tmp15_ = self->priv->handlers;
	_tmp16_ = skk_kuten_state_handler_new ();
	_tmp17_ = _tmp16_;
	gee_map_set (_tmp15_, GINT_TO_POINTER (SKK_TYPE_KUTEN_STATE_HANDLER), (SkkStateHandler*) _tmp17_);
	_g_object_unref0 (_tmp17_);
	_tmp18_ = self->priv->_dictionaries;
	_tmp19_ = skk_state_new (_tmp18_);
	state = _tmp19_;
	_tmp20_ = state->candidates;
	_tmp21_ = skk_proxy_candidate_list_new (_tmp20_);
	_g_object_unref0 (self->priv->_candidates);
	self->priv->_candidates = (SkkCandidateList*) _tmp21_;
	skk_context_push_state (self, state);
	_tmp22_ = self->priv->_candidates;
	g_signal_connect_object ((GObject*) _tmp22_, "notify::cursor-pos", (GCallback) ___lambda3__g_object_notify, self, 0);
	_tmp23_ = self->priv->_candidates;
	g_signal_connect_object (_tmp23_, "selected", (GCallback) ___lambda4__skk_candidate_list_selected, self, 0);
	_g_object_unref0 (state);
	return self;
}


SkkContext* skk_context_new (SkkDict** dictionaries, int dictionaries_length1) {
	return skk_context_construct (SKK_TYPE_CONTEXT, dictionaries, dictionaries_length1);
}


static void skk_context_notify_input_mode_cb (SkkContext* self, GObject* s, GParamSpec* p) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (s != NULL);
	g_object_notify ((GObject*) self, "input-mode");
}


static gboolean skk_context_retrieve_surrounding_text_cb (SkkContext* self, gchar** text, guint* cursor_pos) {
	gchar* _vala_text = NULL;
	guint _vala_cursor_pos = 0U;
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	guint _tmp1_ = 0U;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_signal_emit_by_name (self, "retrieve-surrounding-text", &_tmp0_, &_tmp1_, &_tmp2_);
	_g_free0 (_vala_text);
	_vala_text = _tmp0_;
	_vala_cursor_pos = _tmp1_;
	result = _tmp2_;
	if (text) {
		*text = _vala_text;
	} else {
		_g_free0 (_vala_text);
	}
	if (cursor_pos) {
		*cursor_pos = _vala_cursor_pos;
	}
	return result;
}


static gboolean skk_context_delete_surrounding_text_cb (SkkContext* self, gint offset, guint nchars) {
	gboolean result = FALSE;
	gint _tmp0_;
	guint _tmp1_;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = offset;
	_tmp1_ = nchars;
	g_signal_emit_by_name (self, "delete-surrounding-text", _tmp0_, _tmp1_, &_tmp2_);
	result = _tmp2_;
	return result;
}


static void _skk_context_start_dict_edit_skk_state_recursive_edit_start (SkkState* _sender, const gchar* midasi, gboolean okuri, gpointer self) {
	skk_context_start_dict_edit (self, midasi, okuri);
}


static gboolean _skk_context_end_dict_edit_skk_state_recursive_edit_end (SkkState* _sender, const gchar* text, gpointer self) {
	gboolean result;
	result = skk_context_end_dict_edit (self, text);
	return result;
}


static gboolean _skk_context_abort_dict_edit_skk_state_recursive_edit_abort (SkkState* _sender, gpointer self) {
	gboolean result;
	result = skk_context_abort_dict_edit (self);
	return result;
}


static void _skk_context_notify_input_mode_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	skk_context_notify_input_mode_cb (self, _sender, pspec);
}


static gboolean _skk_context_retrieve_surrounding_text_cb_skk_state_retrieve_surrounding_text (SkkState* _sender, gchar** text, guint* cursor_pos, gpointer self) {
	gboolean result;
	result = skk_context_retrieve_surrounding_text_cb (self, text, cursor_pos);
	return result;
}


static gboolean _skk_context_delete_surrounding_text_cb_skk_state_delete_surrounding_text (SkkState* _sender, gint offset, guint nchars, gpointer self) {
	gboolean result;
	result = skk_context_delete_surrounding_text_cb (self, offset, nchars);
	return result;
}


static void skk_context_connect_state_signals (SkkContext* self, SkkState* state) {
	SkkState* _tmp0_;
	SkkState* _tmp1_;
	SkkState* _tmp2_;
	SkkState* _tmp3_;
	SkkState* _tmp4_;
	SkkState* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (state != NULL);
	_tmp0_ = state;
	g_signal_connect_object (_tmp0_, "recursive-edit-start", (GCallback) _skk_context_start_dict_edit_skk_state_recursive_edit_start, self, 0);
	_tmp1_ = state;
	g_signal_connect_object (_tmp1_, "recursive-edit-end", (GCallback) _skk_context_end_dict_edit_skk_state_recursive_edit_end, self, 0);
	_tmp2_ = state;
	g_signal_connect_object (_tmp2_, "recursive-edit-abort", (GCallback) _skk_context_abort_dict_edit_skk_state_recursive_edit_abort, self, 0);
	_tmp3_ = state;
	g_signal_connect_object ((GObject*) _tmp3_, "notify::input-mode", (GCallback) _skk_context_notify_input_mode_cb_g_object_notify, self, 0);
	_tmp4_ = state;
	g_signal_connect_object (_tmp4_, "retrieve-surrounding-text", (GCallback) _skk_context_retrieve_surrounding_text_cb_skk_state_retrieve_surrounding_text, self, 0);
	_tmp5_ = state;
	g_signal_connect_object (_tmp5_, "delete-surrounding-text", (GCallback) _skk_context_delete_surrounding_text_cb_skk_state_delete_surrounding_text, self, 0);
}


static void skk_context_disconnect_state_signals (SkkContext* self, SkkState* state) {
	SkkState* _tmp0_;
	guint _tmp1_ = 0U;
	SkkState* _tmp2_;
	guint _tmp3_ = 0U;
	SkkState* _tmp4_;
	guint _tmp5_ = 0U;
	SkkState* _tmp6_;
	guint _tmp7_ = 0U;
	GQuark _tmp8_ = 0U;
	SkkState* _tmp9_;
	guint _tmp10_ = 0U;
	SkkState* _tmp11_;
	guint _tmp12_ = 0U;
	g_return_if_fail (self != NULL);
	g_return_if_fail (state != NULL);
	_tmp0_ = state;
	g_signal_parse_name ("recursive-edit-start", SKK_TYPE_STATE, &_tmp1_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp0_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _skk_context_start_dict_edit_skk_state_recursive_edit_start, self);
	_tmp2_ = state;
	g_signal_parse_name ("recursive-edit-end", SKK_TYPE_STATE, &_tmp3_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp2_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp3_, 0, NULL, (GCallback) _skk_context_end_dict_edit_skk_state_recursive_edit_end, self);
	_tmp4_ = state;
	g_signal_parse_name ("recursive-edit-abort", SKK_TYPE_STATE, &_tmp5_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp4_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp5_, 0, NULL, (GCallback) _skk_context_abort_dict_edit_skk_state_recursive_edit_abort, self);
	_tmp6_ = state;
	g_signal_parse_name ("notify::input-mode", G_TYPE_OBJECT, &_tmp7_, &_tmp8_, TRUE);
	g_signal_handlers_disconnect_matched ((GObject*) _tmp6_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp7_, _tmp8_, NULL, (GCallback) _skk_context_notify_input_mode_cb_g_object_notify, self);
	_tmp9_ = state;
	g_signal_parse_name ("retrieve-surrounding-text", SKK_TYPE_STATE, &_tmp10_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp9_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp10_, 0, NULL, (GCallback) _skk_context_retrieve_surrounding_text_cb_skk_state_retrieve_surrounding_text, self);
	_tmp11_ = state;
	g_signal_parse_name ("delete-surrounding-text", SKK_TYPE_STATE, &_tmp12_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp11_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp12_, 0, NULL, (GCallback) _skk_context_delete_surrounding_text_cb_skk_state_delete_surrounding_text, self);
}


static gboolean skk_context_select_candidate_in_dictionaries (SkkContext* self, SkkCandidate* candidate) {
	gboolean result = FALSE;
	gboolean changed;
	SkkDict** _tmp0_;
	gint _tmp0__length1;
	SkkDict** _tmp1_;
	gint _tmp1__length1;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (candidate != NULL, FALSE);
	changed = FALSE;
	_tmp0_ = skk_context_get_dictionaries (self, &_tmp0__length1);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = _tmp0__length1;
	{
		SkkDict** dict_collection = NULL;
		gint dict_collection_length1 = 0;
		gint _dict_collection_size_ = 0;
		gint dict_it = 0;
		dict_collection = _tmp1_;
		dict_collection_length1 = _tmp1__length1;
		for (dict_it = 0; dict_it < _tmp1__length1; dict_it = dict_it + 1) {
			SkkDict* _tmp2_;
			SkkDict* dict = NULL;
			_tmp2_ = _g_object_ref0 (dict_collection[dict_it]);
			dict = _tmp2_;
			{
				gboolean _tmp3_ = FALSE;
				SkkDict* _tmp4_;
				gboolean _tmp5_;
				gboolean _tmp6_;
				gboolean _tmp10_;
				_tmp4_ = dict;
				_tmp5_ = skk_dict_get_read_only (_tmp4_);
				_tmp6_ = _tmp5_;
				if (!_tmp6_) {
					SkkDict* _tmp7_;
					SkkCandidate* _tmp8_;
					gboolean _tmp9_ = FALSE;
					_tmp7_ = dict;
					_tmp8_ = candidate;
					_tmp9_ = skk_dict_select_candidate (_tmp7_, _tmp8_);
					_tmp3_ = _tmp9_;
				} else {
					_tmp3_ = FALSE;
				}
				_tmp10_ = _tmp3_;
				if (_tmp10_) {
					changed = TRUE;
				}
				_g_object_unref0 (dict);
			}
		}
		dict_collection = (_vala_array_free (dict_collection, dict_collection_length1, (GDestroyNotify) g_object_unref), NULL);
	}
	result = changed;
	return result;
}


static guint skk_context_dict_edit_level (SkkContext* self) {
	guint result = 0U;
	GeeLinkedList* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_collection_get_size ((GeeCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	result = (guint) (_tmp2_ - 1);
	return result;
}


static void skk_context_push_state (SkkContext* self, SkkState* state) {
	GeeLinkedList* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	GeeLinkedList* _tmp6_;
	SkkState* _tmp7_;
	SkkState* _tmp8_;
	SkkCandidateList* _tmp9_;
	SkkProxyCandidateList* _tmp10_;
	SkkProxyCandidateList* pcandidates;
	SkkProxyCandidateList* _tmp11_;
	SkkCandidateList* _tmp12_;
	SkkCandidateList* _tmp13_;
	SkkState* _tmp14_;
	SkkCandidateList* _tmp15_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (state != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_abstract_collection_get_is_empty ((GeeAbstractCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	if (!_tmp2_) {
		GeeLinkedList* _tmp3_;
		gpointer _tmp4_ = NULL;
		SkkState* _tmp5_;
		_tmp3_ = self->priv->state_stack;
		_tmp4_ = gee_deque_peek_head ((GeeDeque*) _tmp3_);
		_tmp5_ = (SkkState*) _tmp4_;
		skk_context_disconnect_state_signals (self, _tmp5_);
		_g_object_unref0 (_tmp5_);
	}
	_tmp6_ = self->priv->state_stack;
	_tmp7_ = state;
	gee_deque_offer_head ((GeeDeque*) _tmp6_, _tmp7_);
	_tmp8_ = state;
	skk_context_connect_state_signals (self, _tmp8_);
	_tmp9_ = self->priv->_candidates;
	_tmp10_ = _g_object_ref0 (SKK_PROXY_CANDIDATE_LIST (_tmp9_));
	pcandidates = _tmp10_;
	_tmp11_ = pcandidates;
	_tmp12_ = skk_proxy_candidate_list_get_candidates (_tmp11_);
	_tmp13_ = _tmp12_;
	_tmp14_ = state;
	_tmp15_ = _tmp14_->candidates;
	if (_tmp13_ != _tmp15_) {
		SkkProxyCandidateList* _tmp16_;
		SkkState* _tmp17_;
		SkkCandidateList* _tmp18_;
		_tmp16_ = pcandidates;
		_tmp17_ = state;
		_tmp18_ = _tmp17_->candidates;
		skk_proxy_candidate_list_set_candidates (_tmp16_, _tmp18_);
	}
	_g_object_unref0 (pcandidates);
}


static void skk_context_pop_state (SkkContext* self) {
	GeeLinkedList* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	GeeLinkedList* _tmp3_;
	gpointer _tmp4_ = NULL;
	SkkState* _tmp5_;
	GeeLinkedList* _tmp6_;
	gboolean _tmp7_;
	gboolean _tmp8_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_abstract_collection_get_is_empty ((GeeAbstractCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	g_assert (!_tmp2_);
	_tmp3_ = self->priv->state_stack;
	_tmp4_ = gee_deque_poll_head ((GeeDeque*) _tmp3_);
	_tmp5_ = (SkkState*) _tmp4_;
	skk_context_disconnect_state_signals (self, _tmp5_);
	_g_object_unref0 (_tmp5_);
	_tmp6_ = self->priv->state_stack;
	_tmp7_ = gee_abstract_collection_get_is_empty ((GeeAbstractCollection*) _tmp6_);
	_tmp8_ = _tmp7_;
	if (!_tmp8_) {
		GeeLinkedList* _tmp9_;
		gpointer _tmp10_ = NULL;
		SkkState* state;
		SkkState* _tmp11_;
		SkkCandidateList* _tmp12_;
		SkkProxyCandidateList* _tmp13_;
		SkkProxyCandidateList* pcandidates;
		SkkProxyCandidateList* _tmp14_;
		SkkCandidateList* _tmp15_;
		SkkCandidateList* _tmp16_;
		SkkState* _tmp17_;
		SkkCandidateList* _tmp18_;
		_tmp9_ = self->priv->state_stack;
		_tmp10_ = gee_deque_peek_head ((GeeDeque*) _tmp9_);
		state = (SkkState*) _tmp10_;
		_tmp11_ = state;
		skk_context_connect_state_signals (self, _tmp11_);
		_tmp12_ = self->priv->_candidates;
		_tmp13_ = _g_object_ref0 (SKK_PROXY_CANDIDATE_LIST (_tmp12_));
		pcandidates = _tmp13_;
		_tmp14_ = pcandidates;
		_tmp15_ = skk_proxy_candidate_list_get_candidates (_tmp14_);
		_tmp16_ = _tmp15_;
		_tmp17_ = state;
		_tmp18_ = _tmp17_->candidates;
		if (_tmp16_ != _tmp18_) {
			SkkProxyCandidateList* _tmp19_;
			SkkState* _tmp20_;
			SkkCandidateList* _tmp21_;
			_tmp19_ = pcandidates;
			_tmp20_ = state;
			_tmp21_ = _tmp20_->candidates;
			skk_proxy_candidate_list_set_candidates (_tmp19_, _tmp21_);
		}
		_g_object_unref0 (pcandidates);
		_g_object_unref0 (state);
	}
}


static void skk_context_start_dict_edit (SkkContext* self, const gchar* midasi, gboolean okuri) {
	GeeList* _tmp0_;
	SkkState* _tmp1_;
	SkkState* state;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gboolean _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (midasi != NULL);
	_tmp0_ = self->priv->_dictionaries;
	_tmp1_ = skk_state_new (_tmp0_);
	state = _tmp1_;
	_tmp2_ = midasi;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (state->midasi);
	state->midasi = _tmp3_;
	_tmp4_ = okuri;
	state->okuri = _tmp4_;
	skk_context_push_state (self, state);
	skk_context_update_preedit (self);
	_g_object_unref0 (state);
}


static gboolean skk_context_end_dict_edit (SkkContext* self, const gchar* text) {
	gboolean result = FALSE;
	gchar* midasi = NULL;
	gboolean* okuri = FALSE;
	gchar* _tmp0_ = NULL;
	gboolean* _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (text != NULL, FALSE);
	_tmp2_ = skk_context_leave_dict_edit (self, &_tmp0_, &_tmp1_);
	_g_free0 (midasi);
	midasi = _tmp0_;
	_g_free0 (okuri);
	okuri = _tmp1_;
	if (_tmp2_) {
		const gchar* _tmp3_;
		gboolean* _tmp4_;
		const gchar* _tmp5_;
		SkkCandidate* _tmp6_;
		SkkCandidate* candidate;
		SkkCandidate* _tmp7_;
		gboolean _tmp8_ = FALSE;
		GeeLinkedList* _tmp11_;
		gpointer _tmp12_ = NULL;
		SkkState* state;
		SkkState* _tmp13_;
		SkkState* _tmp14_;
		GString* _tmp15_;
		const gchar* _tmp16_;
		_tmp3_ = midasi;
		_tmp4_ = okuri;
		_tmp5_ = text;
		_tmp6_ = skk_candidate_new (_tmp3_, *_tmp4_, _tmp5_, NULL, NULL);
		candidate = _tmp6_;
		_tmp7_ = candidate;
		_tmp8_ = skk_context_select_candidate_in_dictionaries (self, _tmp7_);
		if (_tmp8_) {
			{
				skk_context_save_dictionaries (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					goto __catch34_g_error;
				}
			}
			goto __finally34;
			__catch34_g_error:
			{
				GError* e = NULL;
				GError* _tmp9_;
				const gchar* _tmp10_;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp9_ = e;
				_tmp10_ = _tmp9_->message;
				g_warning ("context.vala:369: error saving dictionaries %s", _tmp10_);
				_g_error_free0 (e);
			}
			__finally34:
			if (_inner_error_ != NULL) {
				_g_object_unref0 (candidate);
				_g_free0 (okuri);
				_g_free0 (midasi);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
		}
		_tmp11_ = self->priv->state_stack;
		_tmp12_ = gee_deque_peek_head ((GeeDeque*) _tmp11_);
		state = (SkkState*) _tmp12_;
		_tmp13_ = state;
		skk_state_reset (_tmp13_);
		_tmp14_ = state;
		_tmp15_ = _tmp14_->output;
		_tmp16_ = text;
		g_string_assign (_tmp15_, _tmp16_);
		skk_context_update_preedit (self);
		result = TRUE;
		_g_object_unref0 (state);
		_g_object_unref0 (candidate);
		_g_free0 (okuri);
		_g_free0 (midasi);
		return result;
	}
	result = FALSE;
	_g_free0 (okuri);
	_g_free0 (midasi);
	return result;
}


static gboolean* _bool_dup (gboolean* self) {
	gboolean* dup;
	dup = g_new0 (gboolean, 1);
	memcpy (dup, self, sizeof (gboolean));
	return dup;
}


static gpointer __bool_dup0 (gpointer self) {
	return self ? _bool_dup (self) : NULL;
}


static gboolean skk_context_leave_dict_edit (SkkContext* self, gchar** midasi, gboolean** okuri) {
	gchar* _vala_midasi = NULL;
	gboolean* _vala_okuri = FALSE;
	gboolean result = FALSE;
	guint _tmp0_ = 0U;
	gboolean _tmp12_;
	gboolean* _tmp13_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = skk_context_dict_edit_level (self);
	if (_tmp0_ > ((guint) 0)) {
		GeeLinkedList* _tmp1_;
		gpointer _tmp2_ = NULL;
		SkkState* state;
		SkkState* _tmp3_;
		const gchar* _tmp4_;
		gchar* _tmp5_;
		SkkState* _tmp6_;
		gboolean _tmp7_;
		gboolean* _tmp8_;
		GeeLinkedList* _tmp9_;
		gpointer _tmp10_ = NULL;
		SkkState* _tmp11_;
		_tmp1_ = self->priv->state_stack;
		_tmp2_ = gee_deque_peek_head ((GeeDeque*) _tmp1_);
		state = (SkkState*) _tmp2_;
		_tmp3_ = state;
		_tmp4_ = _tmp3_->midasi;
		_tmp5_ = g_strdup (_tmp4_);
		_g_free0 (_vala_midasi);
		_vala_midasi = _tmp5_;
		_tmp6_ = state;
		_tmp7_ = _tmp6_->okuri;
		_tmp8_ = __bool_dup0 (&_tmp7_);
		_g_free0 (_vala_okuri);
		_vala_okuri = _tmp8_;
		skk_context_pop_state (self);
		_tmp9_ = self->priv->state_stack;
		_tmp10_ = gee_deque_peek_head ((GeeDeque*) _tmp9_);
		_g_object_unref0 (state);
		state = (SkkState*) _tmp10_;
		_tmp11_ = state;
		skk_state_cancel_okuri (_tmp11_);
		result = TRUE;
		_g_object_unref0 (state);
		if (midasi) {
			*midasi = _vala_midasi;
		} else {
			_g_free0 (_vala_midasi);
		}
		if (okuri) {
			*okuri = _vala_okuri;
		} else {
			_g_free0 (_vala_okuri);
		}
		return result;
	}
	_g_free0 (_vala_midasi);
	_vala_midasi = NULL;
	_tmp12_ = FALSE;
	_tmp13_ = __bool_dup0 (&_tmp12_);
	_g_free0 (_vala_okuri);
	_vala_okuri = _tmp13_;
	result = FALSE;
	if (midasi) {
		*midasi = _vala_midasi;
	} else {
		_g_free0 (_vala_midasi);
	}
	if (okuri) {
		*okuri = _vala_okuri;
	} else {
		_g_free0 (_vala_okuri);
	}
	return result;
}


static gboolean skk_context_abort_dict_edit (SkkContext* self) {
	gboolean result = FALSE;
	gchar* midasi = NULL;
	gboolean* okuri = FALSE;
	gchar* _tmp0_ = NULL;
	gboolean* _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp2_ = skk_context_leave_dict_edit (self, &_tmp0_, &_tmp1_);
	_g_free0 (midasi);
	midasi = _tmp0_;
	_g_free0 (okuri);
	okuri = _tmp1_;
	if (_tmp2_) {
		skk_context_update_preedit (self);
		result = TRUE;
		_g_free0 (okuri);
		_g_free0 (midasi);
		return result;
	}
	result = FALSE;
	_g_free0 (okuri);
	_g_free0 (midasi);
	return result;
}


/**
         * Pass key events (separated by spaces) to the context.
         *
         * This function is rarely used in programs but in unit tests.
         *
         * @param keyseq a string representing key events, seperated by " "
         *
         * @return `true` if any of key events are handled, `false` otherwise
         */
static gboolean string_get_next_char (const gchar* self, gint* index, gunichar* c) {
	gunichar _vala_c = 0U;
	gboolean result = FALSE;
	gint _tmp0_;
	gunichar _tmp1_ = 0U;
	gunichar _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = *index;
	_tmp1_ = g_utf8_get_char (((gchar*) self) + _tmp0_);
	_vala_c = _tmp1_;
	_tmp2_ = _vala_c;
	if (_tmp2_ != ((gunichar) 0)) {
		gint _tmp3_;
		gchar* _tmp4_ = NULL;
		_tmp3_ = *index;
		_tmp4_ = g_utf8_next_char (((gchar*) self) + _tmp3_);
		*index = (gint) (_tmp4_ - ((gchar*) self));
		result = TRUE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	} else {
		result = FALSE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	}
	if (c) {
		*c = _vala_c;
	}
}


gboolean skk_context_process_key_events (SkkContext* self, const gchar* keyseq) {
	gboolean result = FALSE;
	GeeArrayList* _tmp0_;
	GeeList* keys;
	GString* _tmp1_;
	GString* builder;
	gboolean complex;
	gboolean escaped;
	gint index;
	gunichar uc = 0U;
	gboolean _tmp30_;
	GString* _tmp31_;
	gssize _tmp32_;
	gboolean retval;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (keyseq != NULL, FALSE);
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	keys = (GeeList*) _tmp0_;
	_tmp1_ = g_string_new ("");
	builder = _tmp1_;
	complex = FALSE;
	escaped = FALSE;
	index = 0;
	while (TRUE) {
		const gchar* _tmp2_;
		gunichar _tmp3_ = 0U;
		gboolean _tmp4_ = FALSE;
		gboolean _tmp5_;
		gunichar _tmp8_;
		_tmp2_ = keyseq;
		_tmp4_ = string_get_next_char (_tmp2_, &index, &_tmp3_);
		uc = _tmp3_;
		if (!_tmp4_) {
			break;
		}
		_tmp5_ = escaped;
		if (_tmp5_) {
			GString* _tmp6_;
			gunichar _tmp7_;
			_tmp6_ = builder;
			_tmp7_ = uc;
			g_string_append_unichar (_tmp6_, _tmp7_);
			escaped = FALSE;
			continue;
		}
		_tmp8_ = uc;
		switch (_tmp8_) {
			case '\\':
			{
				escaped = TRUE;
				break;
			}
			case '(':
			{
				gboolean _tmp9_;
				GString* _tmp10_;
				gunichar _tmp11_;
				_tmp9_ = complex;
				if (_tmp9_) {
					g_warning ("context.vala:434: bare '(' is not allowed in complex keyseq");
					result = FALSE;
					_g_string_free0 (builder);
					_g_object_unref0 (keys);
					return result;
				}
				complex = TRUE;
				_tmp10_ = builder;
				_tmp11_ = uc;
				g_string_append_unichar (_tmp10_, _tmp11_);
				break;
			}
			case ')':
			{
				gboolean _tmp12_;
				GString* _tmp13_;
				gunichar _tmp14_;
				GeeList* _tmp15_;
				GString* _tmp16_;
				const gchar* _tmp17_;
				GString* _tmp18_;
				_tmp12_ = complex;
				if (!_tmp12_) {
					g_warning ("context.vala:442: bare ')' is not allowed in simple keyseq");
					result = FALSE;
					_g_string_free0 (builder);
					_g_object_unref0 (keys);
					return result;
				}
				complex = FALSE;
				_tmp13_ = builder;
				_tmp14_ = uc;
				g_string_append_unichar (_tmp13_, _tmp14_);
				_tmp15_ = keys;
				_tmp16_ = builder;
				_tmp17_ = _tmp16_->str;
				gee_collection_add ((GeeCollection*) _tmp15_, _tmp17_);
				_tmp18_ = builder;
				g_string_erase (_tmp18_, (gssize) 0, (gssize) (-1));
				break;
			}
			case ' ':
			{
				gboolean _tmp19_;
				_tmp19_ = complex;
				if (_tmp19_) {
					GString* _tmp20_;
					gunichar _tmp21_;
					_tmp20_ = builder;
					_tmp21_ = uc;
					g_string_append_unichar (_tmp20_, _tmp21_);
				} else {
					GString* _tmp22_;
					gssize _tmp23_;
					_tmp22_ = builder;
					_tmp23_ = _tmp22_->len;
					if (_tmp23_ > ((gssize) 0)) {
						GeeList* _tmp24_;
						GString* _tmp25_;
						const gchar* _tmp26_;
						GString* _tmp27_;
						_tmp24_ = keys;
						_tmp25_ = builder;
						_tmp26_ = _tmp25_->str;
						gee_collection_add ((GeeCollection*) _tmp24_, _tmp26_);
						_tmp27_ = builder;
						g_string_erase (_tmp27_, (gssize) 0, (gssize) (-1));
					}
				}
				break;
			}
			default:
			{
				GString* _tmp28_;
				gunichar _tmp29_;
				_tmp28_ = builder;
				_tmp29_ = uc;
				g_string_append_unichar (_tmp28_, _tmp29_);
				break;
			}
		}
	}
	_tmp30_ = complex;
	if (_tmp30_) {
		g_warning ("context.vala:465: premature end of key events");
		result = FALSE;
		_g_string_free0 (builder);
		_g_object_unref0 (keys);
		return result;
	}
	_tmp31_ = builder;
	_tmp32_ = _tmp31_->len;
	if (_tmp32_ > ((gssize) 0)) {
		GeeList* _tmp33_;
		GString* _tmp34_;
		const gchar* _tmp35_;
		_tmp33_ = keys;
		_tmp34_ = builder;
		_tmp35_ = _tmp34_->str;
		gee_collection_add ((GeeCollection*) _tmp33_, _tmp35_);
	}
	retval = FALSE;
	{
		GeeList* _tmp36_;
		GeeList* _tmp37_;
		GeeList* _key_list;
		GeeList* _tmp38_;
		gint _tmp39_;
		gint _tmp40_;
		gint _key_size;
		gint _key_index;
		_tmp36_ = keys;
		_tmp37_ = _g_object_ref0 (_tmp36_);
		_key_list = _tmp37_;
		_tmp38_ = _key_list;
		_tmp39_ = gee_collection_get_size ((GeeCollection*) _tmp38_);
		_tmp40_ = _tmp39_;
		_key_size = _tmp40_;
		_key_index = -1;
		while (TRUE) {
			gint _tmp41_;
			gint _tmp42_;
			gint _tmp43_;
			GeeList* _tmp44_;
			gint _tmp45_;
			gpointer _tmp46_ = NULL;
			gchar* key;
			const gchar* _tmp47_;
			const gchar* _tmp55_;
			SkkKeyEvent* _tmp56_;
			SkkKeyEvent* ev;
			gboolean _tmp57_ = FALSE;
			SkkKeyEvent* _tmp58_;
			gboolean _tmp59_ = FALSE;
			gboolean _tmp61_;
			_tmp41_ = _key_index;
			_key_index = _tmp41_ + 1;
			_tmp42_ = _key_index;
			_tmp43_ = _key_size;
			if (!(_tmp42_ < _tmp43_)) {
				break;
			}
			_tmp44_ = _key_list;
			_tmp45_ = _key_index;
			_tmp46_ = gee_list_get (_tmp44_, _tmp45_);
			key = (gchar*) _tmp46_;
			_tmp47_ = key;
			if (g_strcmp0 (_tmp47_, "SPC") == 0) {
				gchar* _tmp48_;
				_tmp48_ = g_strdup (" ");
				_g_free0 (key);
				key = _tmp48_;
			} else {
				const gchar* _tmp49_;
				_tmp49_ = key;
				if (g_strcmp0 (_tmp49_, "TAB") == 0) {
					gchar* _tmp50_;
					_tmp50_ = g_strdup ("\t");
					_g_free0 (key);
					key = _tmp50_;
				} else {
					const gchar* _tmp51_;
					_tmp51_ = key;
					if (g_strcmp0 (_tmp51_, "RET") == 0) {
						gchar* _tmp52_;
						_tmp52_ = g_strdup ("\n");
						_g_free0 (key);
						key = _tmp52_;
					} else {
						const gchar* _tmp53_;
						_tmp53_ = key;
						if (g_strcmp0 (_tmp53_, "DEL") == 0) {
							gchar* _tmp54_;
							_tmp54_ = g_strdup ("\b");
							_g_free0 (key);
							key = _tmp54_;
						}
					}
				}
			}
			_tmp55_ = key;
			_tmp56_ = skk_key_event_new_from_string (_tmp55_);
			ev = _tmp56_;
			_tmp58_ = ev;
			_tmp59_ = skk_context_process_key_event (self, _tmp58_);
			if (_tmp59_) {
				gboolean _tmp60_;
				_tmp60_ = retval;
				_tmp57_ = !_tmp60_;
			} else {
				_tmp57_ = FALSE;
			}
			_tmp61_ = _tmp57_;
			if (_tmp61_) {
				retval = TRUE;
			}
			_g_object_unref0 (ev);
			_g_free0 (key);
		}
		_g_object_unref0 (_key_list);
	}
	result = retval;
	_g_string_free0 (builder);
	_g_object_unref0 (keys);
	return result;
}


/**
         * Pass one key event to the context.
         *
         * @param key a key event
         *
         * @return `true` if the key event is handled, `false` otherwise
         */
gboolean skk_context_process_key_event (SkkContext* self, SkkKeyEvent* key) {
	gboolean result = FALSE;
	SkkKeyEventFilter* _tmp0_;
	SkkKeyEventFilter* _tmp1_;
	SkkKeyEventFilter* _tmp2_;
	SkkKeyEvent* _tmp3_;
	SkkKeyEvent* _tmp4_ = NULL;
	SkkKeyEvent* _tmp5_;
	SkkKeyEvent* _key;
	SkkKeyEvent* _tmp6_;
	SkkKeyEvent* _tmp7_;
	gboolean _tmp8_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = skk_context_get_key_event_filter (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = _tmp1_;
	_tmp3_ = key;
	_tmp4_ = skk_key_event_filter_filter_key_event (_tmp2_, _tmp3_);
	_tmp5_ = _tmp4_;
	_g_object_unref0 (_tmp2_);
	_key = _tmp5_;
	_tmp6_ = _key;
	if (_tmp6_ == NULL) {
		result = TRUE;
		_g_object_unref0 (_key);
		return result;
	}
	_tmp7_ = _key;
	_tmp8_ = skk_context_process_key_event_internal (self, _tmp7_);
	result = _tmp8_;
	_g_object_unref0 (_key);
	return result;
}


static gboolean skk_context_process_key_event_internal (SkkContext* self, SkkKeyEvent* key) {
	gboolean result = FALSE;
	SkkKeyEvent* _tmp0_;
	SkkKeyEvent* _tmp1_ = NULL;
	SkkKeyEvent* _key;
	GeeLinkedList* _tmp2_;
	gpointer _tmp3_ = NULL;
	SkkState* state;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = key;
	_tmp1_ = skk_key_event_copy (_tmp0_);
	_key = _tmp1_;
	_tmp2_ = self->priv->state_stack;
	_tmp3_ = gee_deque_peek_head ((GeeDeque*) _tmp2_);
	state = (SkkState*) _tmp3_;
	while (TRUE) {
		SkkState* _tmp4_;
		GType _tmp5_;
		GType handler_type;
		GeeMap* _tmp6_;
		GType _tmp7_;
		gpointer _tmp8_ = NULL;
		SkkStateHandler* handler;
		SkkStateHandler* _tmp9_;
		SkkState* _tmp10_;
		gboolean _tmp11_ = FALSE;
		GType _tmp12_;
		SkkState* _tmp13_;
		GType _tmp14_;
		_tmp4_ = state;
		_tmp5_ = _tmp4_->handler_type;
		handler_type = _tmp5_;
		_tmp6_ = self->priv->handlers;
		_tmp7_ = handler_type;
		_tmp8_ = gee_map_get (_tmp6_, GINT_TO_POINTER (_tmp7_));
		handler = (SkkStateHandler*) _tmp8_;
		_tmp9_ = handler;
		_tmp10_ = state;
		_tmp11_ = skk_state_handler_process_key_event (_tmp9_, _tmp10_, &_key);
		if (_tmp11_) {
			skk_context_update_preedit (self);
			result = TRUE;
			_g_object_unref0 (handler);
			_g_object_unref0 (state);
			_g_object_unref0 (_key);
			return result;
		}
		_tmp12_ = handler_type;
		_tmp13_ = state;
		_tmp14_ = _tmp13_->handler_type;
		if (_tmp12_ == _tmp14_) {
			guint _tmp15_ = 0U;
			_tmp15_ = skk_context_dict_edit_level (self);
			result = _tmp15_ > ((guint) 0);
			_g_object_unref0 (handler);
			_g_object_unref0 (state);
			_g_object_unref0 (_key);
			return result;
		}
		_g_object_unref0 (handler);
	}
	_g_object_unref0 (state);
	_g_object_unref0 (_key);
}


/**
         * Reset the context.
         */
void skk_context_reset (SkkContext* self) {
	GeeLinkedList* _tmp4_;
	gpointer _tmp5_ = NULL;
	SkkState* state;
	SkkCandidateList* _tmp6_;
	SkkCandidateList* _tmp7_;
	g_return_if_fail (self != NULL);
	while (TRUE) {
		guint _tmp0_ = 0U;
		GeeLinkedList* _tmp1_;
		gpointer _tmp2_ = NULL;
		SkkState* _tmp3_;
		_tmp0_ = skk_context_dict_edit_level (self);
		if (!(_tmp0_ > ((guint) 0))) {
			break;
		}
		skk_context_pop_state (self);
		_tmp1_ = self->priv->state_stack;
		_tmp2_ = gee_deque_peek_head ((GeeDeque*) _tmp1_);
		_tmp3_ = (SkkState*) _tmp2_;
		skk_state_cancel_okuri (_tmp3_);
		_g_object_unref0 (_tmp3_);
	}
	_tmp4_ = self->priv->state_stack;
	_tmp5_ = gee_deque_peek_head ((GeeDeque*) _tmp4_);
	state = (SkkState*) _tmp5_;
	skk_state_output_surrounding_text (state);
	skk_state_reset (state);
	_tmp6_ = self->priv->_candidates;
	_tmp7_ = state->candidates;
	skk_proxy_candidate_list_set_candidates (SKK_PROXY_CANDIDATE_LIST (_tmp6_), _tmp7_);
	_g_object_unref0 (state);
}


/**
         * This is replaced with {@link poll_output}.
         *
         * @return an output string
         * @deprecated 0.0.6
         */
gchar* skk_context_get_output (SkkContext* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = skk_context_poll_output (self);
	result = _tmp0_;
	return result;
}


static gchar* skk_context_retrieve_output (SkkContext* self, gboolean clear) {
	gchar* result = NULL;
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	SkkState* state;
	GeeMap* _tmp2_;
	SkkState* _tmp3_;
	GType _tmp4_;
	gpointer _tmp5_ = NULL;
	SkkStateHandler* handler;
	guint _tmp6_ = 0U;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_deque_peek_head ((GeeDeque*) _tmp0_);
	state = (SkkState*) _tmp1_;
	_tmp2_ = self->priv->handlers;
	_tmp3_ = state;
	_tmp4_ = _tmp3_->handler_type;
	_tmp5_ = gee_map_get (_tmp2_, GINT_TO_POINTER (_tmp4_));
	handler = (SkkStateHandler*) _tmp5_;
	_tmp6_ = skk_context_dict_edit_level (self);
	if (_tmp6_ > ((guint) 0)) {
		gchar* _tmp7_;
		_tmp7_ = g_strdup ("");
		result = _tmp7_;
		_g_object_unref0 (handler);
		_g_object_unref0 (state);
		return result;
	} else {
		SkkStateHandler* _tmp8_;
		SkkState* _tmp9_;
		gchar* _tmp10_ = NULL;
		gchar* output;
		gboolean _tmp11_;
		_tmp8_ = handler;
		_tmp9_ = state;
		_tmp10_ = skk_state_handler_get_output (_tmp8_, _tmp9_);
		output = _tmp10_;
		_tmp11_ = clear;
		if (_tmp11_) {
			SkkState* _tmp12_;
			GString* _tmp13_;
			_tmp12_ = state;
			_tmp13_ = _tmp12_->output;
			g_string_erase (_tmp13_, (gssize) 0, (gssize) (-1));
		}
		result = output;
		_g_object_unref0 (handler);
		_g_object_unref0 (state);
		return result;
	}
	_g_object_unref0 (handler);
	_g_object_unref0 (state);
}


/**
         * Peek (retrieve, but not remove) the current output string.
         *
         * @return an output string
         * @since 0.0.6
         */
gchar* skk_context_peek_output (SkkContext* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = skk_context_retrieve_output (self, FALSE);
	result = _tmp0_;
	return result;
}


/**
         * Poll (retrieve and remove) the current output string.
         *
         * @return an output string
         * @since 0.0.6
         */
gchar* skk_context_poll_output (SkkContext* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = skk_context_retrieve_output (self, TRUE);
	result = _tmp0_;
	return result;
}


/**
         * Clear the output buffer.
         *
         * @since 0.0.6
         */
void skk_context_clear_output (SkkContext* self) {
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	SkkState* _tmp2_;
	GString* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_deque_peek_head ((GeeDeque*) _tmp0_);
	_tmp2_ = (SkkState*) _tmp1_;
	_tmp3_ = _tmp2_->output;
	g_string_erase (_tmp3_, (gssize) 0, (gssize) (-1));
	_g_object_unref0 (_tmp2_);
}


static void skk_context_update_preedit (SkkContext* self) {
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	SkkState* state;
	GeeMap* _tmp2_;
	SkkState* _tmp3_;
	GType _tmp4_;
	gpointer _tmp5_ = NULL;
	SkkStateHandler* handler;
	GString* _tmp6_;
	GString* builder;
	guint _tmp7_ = 0U;
	guint offset = 0U;
	guint nchars = 0U;
	GString* _tmp33_;
	SkkStateHandler* _tmp34_;
	SkkState* _tmp35_;
	guint _tmp36_ = 0U;
	guint _tmp37_ = 0U;
	gchar* _tmp38_ = NULL;
	gchar* _tmp39_;
	guint _tmp40_;
	GString* _tmp41_;
	const gchar* _tmp42_;
	gint _tmp43_ = 0;
	gboolean changed;
	const gchar* _tmp44_;
	GString* _tmp45_;
	const gchar* _tmp46_;
	gboolean _tmp49_ = FALSE;
	guint _tmp50_;
	guint _tmp51_;
	gboolean _tmp54_;
	gboolean _tmp57_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_deque_peek_head ((GeeDeque*) _tmp0_);
	state = (SkkState*) _tmp1_;
	_tmp2_ = self->priv->handlers;
	_tmp3_ = state;
	_tmp4_ = _tmp3_->handler_type;
	_tmp5_ = gee_map_get (_tmp2_, GINT_TO_POINTER (_tmp4_));
	handler = (SkkStateHandler*) _tmp5_;
	_tmp6_ = g_string_new ("");
	builder = _tmp6_;
	_tmp7_ = skk_context_dict_edit_level (self);
	if (_tmp7_ > ((guint) 0)) {
		guint _tmp8_ = 0U;
		guint level;
		GString* _tmp15_;
		const gchar* _tmp16_ = NULL;
		GString* _tmp23_;
		GString* _tmp24_;
		SkkState* _tmp25_;
		const gchar* _tmp26_;
		GString* _tmp27_;
		GString* _tmp28_;
		SkkStateHandler* _tmp29_;
		SkkState* _tmp30_;
		gchar* _tmp31_ = NULL;
		gchar* _tmp32_;
		_tmp8_ = skk_context_dict_edit_level (self);
		level = _tmp8_;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp9_;
				_tmp9_ = TRUE;
				while (TRUE) {
					gboolean _tmp10_;
					gint _tmp12_;
					guint _tmp13_;
					GString* _tmp14_;
					_tmp10_ = _tmp9_;
					if (!_tmp10_) {
						gint _tmp11_;
						_tmp11_ = i;
						i = _tmp11_ + 1;
					}
					_tmp9_ = FALSE;
					_tmp12_ = i;
					_tmp13_ = level;
					if (!(((guint) _tmp12_) < _tmp13_)) {
						break;
					}
					_tmp14_ = builder;
					g_string_append_c (_tmp14_, '[');
				}
			}
		}
		_tmp15_ = builder;
		_tmp16_ = _ ("DictEdit");
		g_string_append (_tmp15_, _tmp16_);
		{
			gint i;
			i = 0;
			{
				gboolean _tmp17_;
				_tmp17_ = TRUE;
				while (TRUE) {
					gboolean _tmp18_;
					gint _tmp20_;
					guint _tmp21_;
					GString* _tmp22_;
					_tmp18_ = _tmp17_;
					if (!_tmp18_) {
						gint _tmp19_;
						_tmp19_ = i;
						i = _tmp19_ + 1;
					}
					_tmp17_ = FALSE;
					_tmp20_ = i;
					_tmp21_ = level;
					if (!(((guint) _tmp20_) < _tmp21_)) {
						break;
					}
					_tmp22_ = builder;
					g_string_append_c (_tmp22_, ']');
				}
			}
		}
		_tmp23_ = builder;
		g_string_append (_tmp23_, " ");
		_tmp24_ = builder;
		_tmp25_ = state;
		_tmp26_ = _tmp25_->midasi;
		g_string_append (_tmp24_, _tmp26_);
		_tmp27_ = builder;
		g_string_append (_tmp27_, " ");
		_tmp28_ = builder;
		_tmp29_ = handler;
		_tmp30_ = state;
		_tmp31_ = skk_state_handler_get_output (_tmp29_, _tmp30_);
		_tmp32_ = _tmp31_;
		g_string_append (_tmp28_, _tmp32_);
		_g_free0 (_tmp32_);
	}
	_tmp33_ = builder;
	_tmp34_ = handler;
	_tmp35_ = state;
	_tmp38_ = skk_state_handler_get_preedit (_tmp34_, _tmp35_, &_tmp36_, &_tmp37_);
	offset = _tmp36_;
	nchars = _tmp37_;
	_tmp39_ = _tmp38_;
	g_string_append (_tmp33_, _tmp39_);
	_g_free0 (_tmp39_);
	_tmp40_ = offset;
	_tmp41_ = builder;
	_tmp42_ = _tmp41_->str;
	_tmp43_ = g_utf8_strlen (_tmp42_, (gssize) (-1));
	offset = _tmp40_ + ((guint) _tmp43_);
	changed = FALSE;
	_tmp44_ = self->priv->_preedit;
	_tmp45_ = builder;
	_tmp46_ = _tmp45_->str;
	if (g_strcmp0 (_tmp44_, _tmp46_) != 0) {
		GString* _tmp47_;
		const gchar* _tmp48_;
		_tmp47_ = builder;
		_tmp48_ = _tmp47_->str;
		skk_context_set_preedit (self, _tmp48_);
		changed = TRUE;
	}
	_tmp50_ = self->priv->preedit_underline_offset;
	_tmp51_ = offset;
	if (_tmp50_ != _tmp51_) {
		_tmp49_ = TRUE;
	} else {
		guint _tmp52_;
		guint _tmp53_;
		_tmp52_ = self->priv->preedit_underline_nchars;
		_tmp53_ = nchars;
		_tmp49_ = _tmp52_ != _tmp53_;
	}
	_tmp54_ = _tmp49_;
	if (_tmp54_) {
		guint _tmp55_;
		guint _tmp56_;
		_tmp55_ = offset;
		self->priv->preedit_underline_offset = _tmp55_;
		_tmp56_ = nchars;
		self->priv->preedit_underline_nchars = _tmp56_;
		changed = TRUE;
	}
	_tmp57_ = changed;
	if (_tmp57_) {
		g_object_notify ((GObject*) self, "preedit");
	}
	_g_string_free0 (builder);
	_g_object_unref0 (handler);
	_g_object_unref0 (state);
}


/**
         * Get underlined range of preedit.
         *
         * @param offset starting offset (in chars) of underline
         * @param nchars number of characters to be underlined
         * @since 0.0.6
         */
void skk_context_get_preedit_underline (SkkContext* self, guint* offset, guint* nchars) {
	guint _vala_offset = 0U;
	guint _vala_nchars = 0U;
	guint _tmp0_;
	guint _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->preedit_underline_offset;
	_vala_offset = _tmp0_;
	_tmp1_ = self->priv->preedit_underline_nchars;
	_vala_nchars = _tmp1_;
	if (offset) {
		*offset = _vala_offset;
	}
	if (nchars) {
		*nchars = _vala_nchars;
	}
}


/**
         * Save dictionaries on to disk.
         */
void skk_context_save_dictionaries (SkkContext* self, GError** error) {
	SkkDict** _tmp0_;
	gint _tmp0__length1;
	SkkDict** _tmp1_;
	gint _tmp1__length1;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = skk_context_get_dictionaries (self, &_tmp0__length1);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = _tmp0__length1;
	{
		SkkDict** dict_collection = NULL;
		gint dict_collection_length1 = 0;
		gint _dict_collection_size_ = 0;
		gint dict_it = 0;
		dict_collection = _tmp1_;
		dict_collection_length1 = _tmp1__length1;
		for (dict_it = 0; dict_it < _tmp1__length1; dict_it = dict_it + 1) {
			SkkDict* _tmp2_;
			SkkDict* dict = NULL;
			_tmp2_ = _g_object_ref0 (dict_collection[dict_it]);
			dict = _tmp2_;
			{
				SkkDict* _tmp3_;
				gboolean _tmp4_;
				gboolean _tmp5_;
				_tmp3_ = dict;
				_tmp4_ = skk_dict_get_read_only (_tmp3_);
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					SkkDict* _tmp6_;
					_tmp6_ = dict;
					skk_dict_save (_tmp6_, &_inner_error_);
					if (_inner_error_ != NULL) {
						g_propagate_error (error, _inner_error_);
						_g_object_unref0 (dict);
						dict_collection = (_vala_array_free (dict_collection, dict_collection_length1, (GDestroyNotify) g_object_unref), NULL);
						return;
					}
				}
				_g_object_unref0 (dict);
			}
		}
		dict_collection = (_vala_array_free (dict_collection, dict_collection_length1, (GDestroyNotify) g_object_unref), NULL);
	}
}


SkkDict** skk_context_get_dictionaries (SkkContext* self, int* result_length1) {
	SkkDict** result;
	GeeList* _tmp0_;
	gint _tmp1_ = 0;
	gpointer* _tmp2_ = NULL;
	SkkDict** _tmp3_;
	gint _tmp3__length1;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_dictionaries;
	_tmp2_ = gee_collection_to_array ((GeeCollection*) _tmp0_, &_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp3__length1 = _tmp1_;
	if (result_length1) {
		*result_length1 = _tmp3__length1;
	}
	result = _tmp3_;
	return result;
}


void skk_context_set_dictionaries (SkkContext* self, SkkDict** value, int value_length1) {
	GeeList* _tmp0_;
	SkkDict** _tmp1_;
	gint _tmp1__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_dictionaries;
	gee_collection_clear ((GeeCollection*) _tmp0_);
	_tmp1_ = value;
	_tmp1__length1 = value_length1;
	{
		SkkDict** dict_collection = NULL;
		gint dict_collection_length1 = 0;
		gint _dict_collection_size_ = 0;
		gint dict_it = 0;
		dict_collection = _tmp1_;
		dict_collection_length1 = _tmp1__length1;
		for (dict_it = 0; dict_it < _tmp1__length1; dict_it = dict_it + 1) {
			SkkDict* _tmp2_;
			SkkDict* dict = NULL;
			_tmp2_ = _g_object_ref0 (dict_collection[dict_it]);
			dict = _tmp2_;
			{
				GeeList* _tmp3_;
				SkkDict* _tmp4_;
				_tmp3_ = self->priv->_dictionaries;
				_tmp4_ = dict;
				gee_collection_add ((GeeCollection*) _tmp3_, _tmp4_);
				_g_object_unref0 (dict);
			}
		}
	}
}


SkkCandidateList* skk_context_get_candidates (SkkContext* self) {
	SkkCandidateList* result;
	SkkCandidateList* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_candidates;
	result = _tmp0_;
	return result;
}


SkkInputMode skk_context_get_input_mode (SkkContext* self) {
	SkkInputMode result;
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	SkkState* _tmp2_;
	SkkInputMode _tmp3_;
	SkkInputMode _tmp4_;
	SkkInputMode _tmp5_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_deque_peek_head ((GeeDeque*) _tmp0_);
	_tmp2_ = (SkkState*) _tmp1_;
	_tmp3_ = skk_state_get_input_mode (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = _tmp4_;
	_g_object_unref0 (_tmp2_);
	result = _tmp5_;
	return result;
}


void skk_context_set_input_mode (SkkContext* self, SkkInputMode value) {
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	SkkState* _tmp2_;
	SkkInputMode _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_deque_peek_head ((GeeDeque*) _tmp0_);
	_tmp2_ = (SkkState*) _tmp1_;
	_tmp3_ = value;
	skk_state_set_input_mode (_tmp2_, _tmp3_);
	_g_object_unref0 (_tmp2_);
	g_object_notify ((GObject *) self, "input-mode");
}


gchar** skk_context_get_auto_start_henkan_keywords (SkkContext* self, int* result_length1) {
	gchar** result;
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	SkkState* _tmp2_;
	gchar** _tmp3_;
	gint _tmp3__length1;
	gchar** _tmp4_;
	gint _tmp4__length1;
	gchar** _tmp5_;
	gint _tmp5__length1;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_deque_peek_head ((GeeDeque*) _tmp0_);
	_tmp2_ = (SkkState*) _tmp1_;
	_tmp3_ = _tmp2_->auto_start_henkan_keywords;
	_tmp3__length1 = _tmp2_->auto_start_henkan_keywords_length1;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = _tmp3__length1;
	_g_object_unref0 (_tmp2_);
	_tmp5_ = _tmp4_;
	_tmp5__length1 = _tmp4__length1;
	if (result_length1) {
		*result_length1 = _tmp5__length1;
	}
	result = _tmp5_;
	return result;
}


static gchar** _vala_array_dup4 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


void skk_context_set_auto_start_henkan_keywords (SkkContext* self, gchar** value, int value_length1) {
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	SkkState* _tmp2_;
	gchar** _tmp3_;
	gint _tmp3__length1;
	gchar** _tmp4_;
	gint _tmp4__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_deque_peek_head ((GeeDeque*) _tmp0_);
	_tmp2_ = (SkkState*) _tmp1_;
	_tmp3_ = value;
	_tmp3__length1 = value_length1;
	_tmp4_ = (_tmp3_ != NULL) ? _vala_array_dup4 (_tmp3_, _tmp3__length1) : ((gpointer) _tmp3_);
	_tmp4__length1 = _tmp3__length1;
	_tmp2_->auto_start_henkan_keywords = (_vala_array_free (_tmp2_->auto_start_henkan_keywords, _tmp2_->auto_start_henkan_keywords_length1, (GDestroyNotify) g_free), NULL);
	_tmp2_->auto_start_henkan_keywords = _tmp4_;
	_tmp2_->auto_start_henkan_keywords_length1 = _tmp4__length1;
	_tmp2_->_auto_start_henkan_keywords_size_ = _tmp2_->auto_start_henkan_keywords_length1;
	_g_object_unref0 (_tmp2_);
	g_object_notify ((GObject *) self, "auto-start-henkan-keywords");
}


gboolean skk_context_get_egg_like_newline (SkkContext* self) {
	gboolean result;
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	SkkState* _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_deque_peek_head ((GeeDeque*) _tmp0_);
	_tmp2_ = (SkkState*) _tmp1_;
	_tmp3_ = _tmp2_->egg_like_newline;
	_tmp4_ = _tmp3_;
	_g_object_unref0 (_tmp2_);
	result = _tmp4_;
	return result;
}


void skk_context_set_egg_like_newline (SkkContext* self, gboolean value) {
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	SkkState* _tmp2_;
	gboolean _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_deque_peek_head ((GeeDeque*) _tmp0_);
	_tmp2_ = (SkkState*) _tmp1_;
	_tmp3_ = value;
	_tmp2_->egg_like_newline = _tmp3_;
	_g_object_unref0 (_tmp2_);
	g_object_notify ((GObject *) self, "egg-like-newline");
}


SkkPeriodStyle skk_context_get_period_style (SkkContext* self) {
	SkkPeriodStyle result;
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	SkkState* _tmp2_;
	SkkPeriodStyle _tmp3_;
	SkkPeriodStyle _tmp4_;
	SkkPeriodStyle _tmp5_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_deque_peek_head ((GeeDeque*) _tmp0_);
	_tmp2_ = (SkkState*) _tmp1_;
	_tmp3_ = skk_state_get_period_style (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = _tmp4_;
	_g_object_unref0 (_tmp2_);
	result = _tmp5_;
	return result;
}


void skk_context_set_period_style (SkkContext* self, SkkPeriodStyle value) {
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	SkkState* _tmp2_;
	SkkPeriodStyle _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_deque_peek_head ((GeeDeque*) _tmp0_);
	_tmp2_ = (SkkState*) _tmp1_;
	_tmp3_ = value;
	skk_state_set_period_style (_tmp2_, _tmp3_);
	_g_object_unref0 (_tmp2_);
	g_object_notify ((GObject *) self, "period-style");
}


SkkRule* skk_context_get_typing_rule (SkkContext* self) {
	SkkRule* result;
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	SkkState* _tmp2_;
	SkkRule* _tmp3_;
	SkkRule* _tmp4_;
	SkkRule* _tmp5_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_deque_peek_head ((GeeDeque*) _tmp0_);
	_tmp2_ = (SkkState*) _tmp1_;
	_tmp3_ = skk_state_get_typing_rule (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = _tmp4_;
	_g_object_unref0 (_tmp2_);
	result = _tmp5_;
	return result;
}


static void _skk_context_filter_forwarded_cb_skk_key_event_filter_forwarded (SkkKeyEventFilter* _sender, SkkKeyEvent* key, gpointer self) {
	skk_context_filter_forwarded_cb (self, key);
}


void skk_context_set_typing_rule (SkkContext* self, SkkRule* value) {
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	SkkState* state;
	SkkRule* _tmp2_;
	SkkRule* _tmp3_;
	SkkKeyEventFilter* _tmp4_ = NULL;
	SkkKeyEventFilter* _tmp5_;
	guint _tmp6_ = 0U;
	SkkRule* _tmp7_;
	SkkRule* _tmp8_;
	SkkRule* _tmp9_;
	SkkKeyEventFilter* _tmp10_ = NULL;
	SkkKeyEventFilter* _tmp11_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_deque_peek_head ((GeeDeque*) _tmp0_);
	state = (SkkState*) _tmp1_;
	_tmp2_ = skk_state_get_typing_rule (state);
	_tmp3_ = _tmp2_;
	_tmp4_ = skk_rule_get_filter (_tmp3_);
	_tmp5_ = _tmp4_;
	g_signal_parse_name ("forwarded", SKK_TYPE_KEY_EVENT_FILTER, &_tmp6_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp5_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp6_, 0, NULL, (GCallback) _skk_context_filter_forwarded_cb_skk_key_event_filter_forwarded, self);
	_g_object_unref0 (_tmp5_);
	_tmp7_ = value;
	skk_state_set_typing_rule (state, _tmp7_);
	_tmp8_ = skk_state_get_typing_rule (state);
	_tmp9_ = _tmp8_;
	_tmp10_ = skk_rule_get_filter (_tmp9_);
	_tmp11_ = _tmp10_;
	g_signal_connect_object (_tmp11_, "forwarded", (GCallback) _skk_context_filter_forwarded_cb_skk_key_event_filter_forwarded, self, 0);
	_g_object_unref0 (_tmp11_);
	_g_object_unref0 (state);
	g_object_notify ((GObject *) self, "typing-rule");
}


SkkKeyEventFilter* skk_context_get_key_event_filter (SkkContext* self) {
	SkkKeyEventFilter* result;
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	SkkState* _tmp2_;
	SkkRule* _tmp3_;
	SkkRule* _tmp4_;
	SkkKeyEventFilter* _tmp5_ = NULL;
	SkkKeyEventFilter* _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->state_stack;
	_tmp1_ = gee_deque_peek_head ((GeeDeque*) _tmp0_);
	_tmp2_ = (SkkState*) _tmp1_;
	_tmp3_ = skk_state_get_typing_rule (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = skk_rule_get_filter (_tmp4_);
	_tmp6_ = _tmp5_;
	_g_object_unref0 (_tmp2_);
	result = _tmp6_;
	return result;
}


const gchar* skk_context_get_preedit (SkkContext* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_preedit;
	result = _tmp0_;
	return result;
}


static void skk_context_set_preedit (SkkContext* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_preedit);
	self->priv->_preedit = _tmp1_;
}


static void g_cclosure_user_marshal_BOOLEAN__POINTER_POINTER (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef gboolean (*GMarshalFunc_BOOLEAN__POINTER_POINTER) (gpointer data1, gpointer arg_1, gpointer arg_2, gpointer data2);
	register GMarshalFunc_BOOLEAN__POINTER_POINTER callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	gboolean v_return;
	cc = (GCClosure *) closure;
	g_return_if_fail (return_value != NULL);
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_BOOLEAN__POINTER_POINTER) (marshal_data ? marshal_data : cc->callback);
	v_return = callback (data1, g_value_get_pointer (param_values + 1), g_value_get_pointer (param_values + 2), data2);
	g_value_set_boolean (return_value, v_return);
}


static void g_cclosure_user_marshal_BOOLEAN__INT_UINT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef gboolean (*GMarshalFunc_BOOLEAN__INT_UINT) (gpointer data1, gint arg_1, guint arg_2, gpointer data2);
	register GMarshalFunc_BOOLEAN__INT_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	gboolean v_return;
	cc = (GCClosure *) closure;
	g_return_if_fail (return_value != NULL);
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_BOOLEAN__INT_UINT) (marshal_data ? marshal_data : cc->callback);
	v_return = callback (data1, g_value_get_int (param_values + 1), g_value_get_uint (param_values + 2), data2);
	g_value_set_boolean (return_value, v_return);
}


static void skk_context_class_init (SkkContextClass * klass) {
	skk_context_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SkkContextPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_skk_context_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_skk_context_set_property;
	G_OBJECT_CLASS (klass)->finalize = skk_context_finalize;
	/**
	         * Current candidates.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_CANDIDATES, g_param_spec_object ("candidates", "candidates", "candidates", SKK_TYPE_CANDIDATE_LIST, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	         * Current input mode.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_INPUT_MODE, g_param_spec_enum ("input-mode", "input-mode", "input-mode", SKK_TYPE_INPUT_MODE, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	         * Array of strings which triggers automatic conversion.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_AUTO_START_HENKAN_KEYWORDS, g_param_spec_boxed ("auto-start-henkan-keywords", "auto-start-henkan-keywords", "auto-start-henkan-keywords", G_TYPE_STRV, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	         * Flag to indicate whether or not "\n" is consumed on commit.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_EGG_LIKE_NEWLINE, g_param_spec_boolean ("egg-like-newline", "egg-like-newline", "egg-like-newline", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	         * Period style used in romaji-to-kana conversion.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_PERIOD_STYLE, g_param_spec_enum ("period-style", "period-style", "period-style", SKK_TYPE_PERIOD_STYLE, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	         * The name of typing rule.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_TYPING_RULE, g_param_spec_object ("typing-rule", "typing-rule", "typing-rule", SKK_TYPE_RULE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	         * Filter which runs before process_key_event.
	         *
	         * This is particularly useful for NICOLA.
	         * @see NicolaKeyEventFilter
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_KEY_EVENT_FILTER, g_param_spec_object ("key-event-filter", "key-event-filter", "key-event-filter", SKK_TYPE_KEY_EVENT_FILTER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	         * Current preedit string.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_CONTEXT_PREEDIT, g_param_spec_string ("preedit", "preedit", "preedit", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	         * Signal emitted when the context requires surrounding-text.
	         *
	         * @param text surrounding text
	         * @param cursor_pos cursor position in text
	         *
	         * @return `true` on success, `false` on failure
	         */
	g_signal_new ("retrieve_surrounding_text", SKK_TYPE_CONTEXT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_BOOLEAN__POINTER_POINTER, G_TYPE_BOOLEAN, 2, G_TYPE_POINTER, G_TYPE_POINTER);
	/**
	         * Signal emitted when the context requests deletion of
	         * surrounding-text.
	         *
	         * @param offset character offset from the cursor position.
	         * @param nchars number of characters to delete.
	         *
	         * @return `true` on success, `false` on failure
	         */
	g_signal_new ("delete_surrounding_text", SKK_TYPE_CONTEXT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_BOOLEAN__INT_UINT, G_TYPE_BOOLEAN, 2, G_TYPE_INT, G_TYPE_UINT);
}


static void skk_context_instance_init (SkkContext * self) {
	GeeArrayList* _tmp0_;
	GeeLinkedList* _tmp1_;
	GeeHashMap* _tmp2_;
	gchar* _tmp3_;
	self->priv = SKK_CONTEXT_GET_PRIVATE (self);
	_tmp0_ = gee_array_list_new (SKK_TYPE_DICT, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->_dictionaries = (GeeList*) _tmp0_;
	_tmp1_ = gee_linked_list_new (SKK_TYPE_STATE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->state_stack = _tmp1_;
	_tmp2_ = gee_hash_map_new (G_TYPE_GTYPE, NULL, NULL, SKK_TYPE_STATE_HANDLER, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	self->priv->handlers = (GeeMap*) _tmp2_;
	_tmp3_ = g_strdup ("");
	self->priv->_preedit = _tmp3_;
	self->priv->preedit_underline_offset = (guint) 0;
	self->priv->preedit_underline_nchars = (guint) 0;
}


static void skk_context_finalize (GObject* obj) {
	SkkContext * self;
	GeeList* _tmp0_;
	self = SKK_CONTEXT (obj);
	_tmp0_ = self->priv->_dictionaries;
	gee_collection_clear ((GeeCollection*) _tmp0_);
	_g_object_unref0 (self->priv->_dictionaries);
	_g_object_unref0 (self->priv->_candidates);
	_g_object_unref0 (self->priv->state_stack);
	_g_object_unref0 (self->priv->handlers);
	_g_free0 (self->priv->_preedit);
	G_OBJECT_CLASS (skk_context_parent_class)->finalize (obj);
}


/**
     * Main entry point of libskk.
     *
     * Context represents an input context with support for SKK
     * kana-kanji conversion method.
     */
GType skk_context_get_type (void) {
	static volatile gsize skk_context_type_id__volatile = 0;
	if (g_once_init_enter (&skk_context_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SkkContextClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) skk_context_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SkkContext), 0, (GInstanceInitFunc) skk_context_instance_init, NULL };
		GType skk_context_type_id;
		skk_context_type_id = g_type_register_static (G_TYPE_OBJECT, "SkkContext", &g_define_type_info, 0);
		g_once_init_leave (&skk_context_type_id__volatile, skk_context_type_id);
	}
	return skk_context_type_id__volatile;
}


static void _vala_skk_context_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SkkContext * self;
	self = SKK_CONTEXT (object);
	switch (property_id) {
		case SKK_CONTEXT_CANDIDATES:
		g_value_set_object (value, skk_context_get_candidates (self));
		break;
		case SKK_CONTEXT_INPUT_MODE:
		g_value_set_enum (value, skk_context_get_input_mode (self));
		break;
		case SKK_CONTEXT_AUTO_START_HENKAN_KEYWORDS:
		{
			int length;
			g_value_set_boxed (value, skk_context_get_auto_start_henkan_keywords (self, &length));
		}
		break;
		case SKK_CONTEXT_EGG_LIKE_NEWLINE:
		g_value_set_boolean (value, skk_context_get_egg_like_newline (self));
		break;
		case SKK_CONTEXT_PERIOD_STYLE:
		g_value_set_enum (value, skk_context_get_period_style (self));
		break;
		case SKK_CONTEXT_TYPING_RULE:
		g_value_set_object (value, skk_context_get_typing_rule (self));
		break;
		case SKK_CONTEXT_KEY_EVENT_FILTER:
		g_value_take_object (value, skk_context_get_key_event_filter (self));
		break;
		case SKK_CONTEXT_PREEDIT:
		g_value_set_string (value, skk_context_get_preedit (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_skk_context_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SkkContext * self;
	self = SKK_CONTEXT (object);
	switch (property_id) {
		case SKK_CONTEXT_INPUT_MODE:
		skk_context_set_input_mode (self, g_value_get_enum (value));
		break;
		case SKK_CONTEXT_AUTO_START_HENKAN_KEYWORDS:
		{
			gpointer boxed;
			boxed = g_value_get_boxed (value);
			skk_context_set_auto_start_henkan_keywords (self, boxed, g_strv_length (boxed));
		}
		break;
		case SKK_CONTEXT_EGG_LIKE_NEWLINE:
		skk_context_set_egg_like_newline (self, g_value_get_boolean (value));
		break;
		case SKK_CONTEXT_PERIOD_STYLE:
		skk_context_set_period_style (self, g_value_get_enum (value));
		break;
		case SKK_CONTEXT_TYPING_RULE:
		skk_context_set_typing_rule (self, g_value_get_object (value));
		break;
		case SKK_CONTEXT_PREEDIT:
		skk_context_set_preedit (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



