/* skk-1.0.vapi generated by valac 0.14.0, do not modify. */

namespace Skk {
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class Candidate : GLib.Object {
		public Candidate (string midasi, bool okuri, string text, string? annotation = null, string? output = null);
		public string to_string ();
		public string? annotation { get; set; }
		public string midasi { get; private set; }
		public bool okuri { get; private set; }
		public string output { get; set; }
		public string text { get; set; }
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class CandidateList : GLib.Object {
		public CandidateList (uint page_start = 4, uint page_size = 7);
		public bool cursor_down ();
		public bool cursor_up ();
		public new Skk.Candidate @get (int index = -1);
		public uint get_page_start_cursor_pos ();
		public bool next ();
		public bool page_down ();
		public bool page_up ();
		public bool previous ();
		public void select (int index = -1);
		public int cursor_pos { get; set; }
		public uint page_size { get; set; }
		public uint page_start { get; set; }
		public bool page_visible { get; }
		public int size { get; }
		public signal void populated ();
		public signal void selected (Skk.Candidate candidate);
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class CdbDict : Skk.Dict {
		public CdbDict (string path, string encoding = "EUC-JP") throws GLib.Error;
		public override string[] complete (string midasi);
		public override Skk.Candidate[] lookup (string midasi, bool okuri = false);
		public override void reload () throws GLib.Error;
		public override bool read_only { get; }
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class Context : GLib.Object {
		public Context (Skk.Dict[] dictionaries);
		public void clear_output ();
		public string get_output ();
		public void get_preedit_underline (out uint offset, out uint nchars);
		public string peek_output ();
		public string poll_output ();
		public bool process_key_event (Skk.KeyEvent key);
		public bool process_key_events (string keyseq);
		public void reset ();
		public void save_dictionaries () throws GLib.Error;
		public string[] auto_start_henkan_keywords { get; set; }
		public Skk.CandidateList candidates { get; }
		public Skk.Dict[] dictionaries { owned get; set; }
		public bool egg_like_newline { get; set; }
		public Skk.InputMode input_mode { get; set; }
		public Skk.KeyEventFilter key_event_filter { owned get; }
		public Skk.PeriodStyle period_style { get; set; }
		[CCode (notify = false)]
		public string preedit { get; private set; }
		public Skk.Rule typing_rule { get; set; }
		public signal bool delete_surrounding_text (int offset, uint nchars);
		public signal bool retrieve_surrounding_text (out string text, out uint cursor_pos);
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public abstract class Dict : GLib.Object {
		public Dict ();
		public abstract string[] complete (string midasi);
		protected string join_candidates (Skk.Candidate[] candidates);
		public abstract Skk.Candidate[] lookup (string midasi, bool okuri = false);
		public virtual bool purge_candidate (Skk.Candidate candidate);
		public abstract void reload () throws GLib.Error;
		public virtual void save () throws GLib.Error;
		public virtual bool select_candidate (Skk.Candidate candidate);
		protected Skk.Candidate[] split_candidates (string midasi, bool okuri, string line);
		public abstract bool read_only { get; }
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class EmptyDict : Skk.Dict {
		public EmptyDict ();
		public override string[] complete (string midasi);
		public override Skk.Candidate[] lookup (string midasi, bool okuri = false);
		public override void reload () throws GLib.Error;
		public override bool read_only { get; }
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class FileDict : Skk.Dict {
		public FileDict (string path, string encoding = "EUC-JP") throws GLib.Error;
		public override string[] complete (string midasi);
		public override Skk.Candidate[] lookup (string midasi, bool okuri = false);
		public override void reload () throws GLib.Error;
		public override bool read_only { get; }
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class KanaKanConverter : GLib.Object {
		public KanaKanConverter (Skk.KanaKanDict dict, Skk.KanaKanScoreMap map);
		public string convert (string kana);
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class KanaKanDict : GLib.Object {
		public KanaKanDict (string path) throws GLib.Error, GLib.IOError;
		public void add (string pron, string word);
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class KanaKanScoreMap : GLib.Object {
		public KanaKanScoreMap (string path, Skk.KanaKanDict dict) throws GLib.Error, GLib.IOError;
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class KeyEvent {
		public KeyEvent (string? name, unichar code, Skk.ModifierType modifiers);
		public bool base_equal (Skk.KeyEvent key);
		public Skk.KeyEvent copy ();
		public KeyEvent.from_string (string key);
		public string to_string ();
		public unichar code { get; private set; }
		public Skk.ModifierType modifiers { get; set; }
		public string? name { get; private set; }
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public abstract class KeyEventFilter : GLib.Object {
		public KeyEventFilter ();
		public abstract Skk.KeyEvent? filter_key_event (Skk.KeyEvent key);
		public virtual void reset ();
		public signal void forwarded (Skk.KeyEvent key);
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class NicolaKeyEventFilter : Skk.KeyEventFilter {
		public Skk.GetTime get_time_func;
		public int64 maxwait;
		public int64 overlap;
		public string[] special_doubles;
		public int64 timeout;
		public NicolaKeyEventFilter ();
		public override Skk.KeyEvent? filter_key_event (Skk.KeyEvent key);
		public override void reset ();
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class RomKanaConverter : GLib.Object {
		public RomKanaConverter ();
		public bool append (unichar uc);
		public void append_text (string text);
		public bool can_consume (unichar uc, bool preedit_only = false, bool no_carryover = true);
		public bool @delete ();
		public void output_nn_if_any ();
		public void reset ();
		public Skk.KanaMode kana_mode { get; set; }
		public string output { get; internal set; }
		public Skk.PeriodStyle period_style { get; set; }
		public string preedit { get; }
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class Rule : GLib.Object {
		public Rule (string name) throws Skk.RuleParseError;
		public static Skk.RuleMetadata? find_rule (string name);
		public static Skk.RuleMetadata[] list ();
		public Skk.RuleMetadata metadata { get; private set; }
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class SimpleKeyEventFilter : Skk.KeyEventFilter {
		public SimpleKeyEventFilter ();
		public override Skk.KeyEvent? filter_key_event (Skk.KeyEvent key);
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class SkkServ : Skk.Dict {
		public SkkServ (string host, uint16 port = 1178, string encoding = "EUC-JP") throws GLib.Error;
		public override string[] complete (string midasi);
		public override Skk.Candidate[] lookup (string midasi, bool okuri = false);
		public override void reload ();
		public override bool read_only { get; }
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public class UserDict : Skk.Dict {
		public UserDict (string path, string encoding = "UTF-8") throws GLib.Error;
		public override string[] complete (string midasi);
		public override Skk.Candidate[] lookup (string midasi, bool okuri = false);
		public override bool purge_candidate (Skk.Candidate candidate);
		public override void reload () throws GLib.Error;
		public override void save () throws GLib.Error;
		public override bool select_candidate (Skk.Candidate candidate);
		public override bool read_only { get; }
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public struct RuleMetadata {
		public string base_dir;
		public string name;
		public string label;
		public string description;
		public string filter;
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public enum InputMode {
		HIRAGANA,
		KATAKANA,
		HANKAKU_KATAKANA,
		LATIN,
		WIDE_LATIN,
		LAST,
		DEFAULT
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public enum KanaMode {
		HIRAGANA,
		KATAKANA,
		HANKAKU_KATAKANA
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public enum ModifierType {
		NONE,
		SHIFT_MASK,
		LOCK_MASK,
		CONTROL_MASK,
		MOD1_MASK,
		MOD2_MASK,
		MOD3_MASK,
		MOD4_MASK,
		MOD5_MASK,
		LSHIFT_MASK,
		RSHIFT_MASK,
		USLEEP_MASK,
		SUPER_MASK,
		HYPER_MASK,
		META_MASK,
		RELEASE_MASK
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public enum PeriodStyle {
		JA_JA,
		EN_EN,
		JA_EN,
		EN_JA
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public errordomain RuleParseError {
		FAILED
	}
	[CCode (cheader_filename = "libskk/libskk.h")]
	public delegate int64 GetTime ();
	[CCode (cheader_filename = "libskk/libskk.h")]
	public static void init ();
}
