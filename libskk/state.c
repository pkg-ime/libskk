/* state.c generated by valac 0.14.0, the Vala compiler
 * generated from state.vala, do not modify */

/* -*- coding: utf-8 -*-*/
/*
 * Copyright (C) 2011 Daiki Ueno <ueno@unixuser.org>
 * Copyright (C) 2011 Red Hat, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <glib/gi18n-lib.h>


#define SKK_TYPE_STATE (skk_state_get_type ())
#define SKK_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_STATE, SkkState))
#define SKK_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_STATE, SkkStateClass))
#define SKK_IS_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_STATE))
#define SKK_IS_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_STATE))
#define SKK_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_STATE, SkkStateClass))

typedef struct _SkkState SkkState;
typedef struct _SkkStateClass SkkStateClass;
typedef struct _SkkStatePrivate SkkStatePrivate;

#define SKK_TYPE_DICT (skk_dict_get_type ())
#define SKK_DICT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_DICT, SkkDict))
#define SKK_DICT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_DICT, SkkDictClass))
#define SKK_IS_DICT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_DICT))
#define SKK_IS_DICT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_DICT))
#define SKK_DICT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_DICT, SkkDictClass))

typedef struct _SkkDict SkkDict;
typedef struct _SkkDictClass SkkDictClass;

#define SKK_TYPE_CANDIDATE_LIST (skk_candidate_list_get_type ())
#define SKK_CANDIDATE_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_CANDIDATE_LIST, SkkCandidateList))
#define SKK_CANDIDATE_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_CANDIDATE_LIST, SkkCandidateListClass))
#define SKK_IS_CANDIDATE_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_CANDIDATE_LIST))
#define SKK_IS_CANDIDATE_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_CANDIDATE_LIST))
#define SKK_CANDIDATE_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_CANDIDATE_LIST, SkkCandidateListClass))

typedef struct _SkkCandidateList SkkCandidateList;
typedef struct _SkkCandidateListClass SkkCandidateListClass;

#define SKK_TYPE_ROM_KANA_CONVERTER (skk_rom_kana_converter_get_type ())
#define SKK_ROM_KANA_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_ROM_KANA_CONVERTER, SkkRomKanaConverter))
#define SKK_ROM_KANA_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_ROM_KANA_CONVERTER, SkkRomKanaConverterClass))
#define SKK_IS_ROM_KANA_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_ROM_KANA_CONVERTER))
#define SKK_IS_ROM_KANA_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_ROM_KANA_CONVERTER))
#define SKK_ROM_KANA_CONVERTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_ROM_KANA_CONVERTER, SkkRomKanaConverterClass))

typedef struct _SkkRomKanaConverter SkkRomKanaConverter;
typedef struct _SkkRomKanaConverterClass SkkRomKanaConverterClass;

#define SKK_TYPE_UNICODE_STRING (skk_unicode_string_get_type ())
#define SKK_UNICODE_STRING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_UNICODE_STRING, SkkUnicodeString))
#define SKK_UNICODE_STRING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_UNICODE_STRING, SkkUnicodeStringClass))
#define SKK_IS_UNICODE_STRING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_UNICODE_STRING))
#define SKK_IS_UNICODE_STRING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_UNICODE_STRING))
#define SKK_UNICODE_STRING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_UNICODE_STRING, SkkUnicodeStringClass))

typedef struct _SkkUnicodeString SkkUnicodeString;
typedef struct _SkkUnicodeStringClass SkkUnicodeStringClass;

#define SKK_TYPE_KANA_MODE (skk_kana_mode_get_type ())

#define SKK_TYPE_INPUT_MODE (skk_input_mode_get_type ())

#define SKK_TYPE_RULE (skk_rule_get_type ())
#define SKK_RULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_RULE, SkkRule))
#define SKK_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_RULE, SkkRuleClass))
#define SKK_IS_RULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_RULE))
#define SKK_IS_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_RULE))
#define SKK_RULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_RULE, SkkRuleClass))

typedef struct _SkkRule SkkRule;
typedef struct _SkkRuleClass SkkRuleClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))

#define SKK_TYPE_KEY_EVENT (skk_key_event_get_type ())
#define SKK_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_KEY_EVENT, SkkKeyEvent))
#define SKK_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_KEY_EVENT, SkkKeyEventClass))
#define SKK_IS_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_KEY_EVENT))
#define SKK_IS_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_KEY_EVENT))
#define SKK_KEY_EVENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_KEY_EVENT, SkkKeyEventClass))

typedef struct _SkkKeyEvent SkkKeyEvent;
typedef struct _SkkKeyEventClass SkkKeyEventClass;
typedef struct _SkkRulePrivate SkkRulePrivate;

#define SKK_TYPE_MAP_FILE (skk_map_file_get_type ())
#define SKK_MAP_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_MAP_FILE, SkkMapFile))
#define SKK_MAP_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_MAP_FILE, SkkMapFileClass))
#define SKK_IS_MAP_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_MAP_FILE))
#define SKK_IS_MAP_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_MAP_FILE))
#define SKK_MAP_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_MAP_FILE, SkkMapFileClass))

typedef struct _SkkMapFile SkkMapFile;
typedef struct _SkkMapFileClass SkkMapFileClass;

#define SKK_TYPE_KEYMAP_MAP_FILE (skk_keymap_map_file_get_type ())
#define SKK_KEYMAP_MAP_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_KEYMAP_MAP_FILE, SkkKeymapMapFile))
#define SKK_KEYMAP_MAP_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_KEYMAP_MAP_FILE, SkkKeymapMapFileClass))
#define SKK_IS_KEYMAP_MAP_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_KEYMAP_MAP_FILE))
#define SKK_IS_KEYMAP_MAP_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_KEYMAP_MAP_FILE))
#define SKK_KEYMAP_MAP_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_KEYMAP_MAP_FILE, SkkKeymapMapFileClass))

typedef struct _SkkKeymapMapFile SkkKeymapMapFile;
typedef struct _SkkKeymapMapFileClass SkkKeymapMapFileClass;

#define SKK_TYPE_ROM_KANA_MAP_FILE (skk_rom_kana_map_file_get_type ())
#define SKK_ROM_KANA_MAP_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_ROM_KANA_MAP_FILE, SkkRomKanaMapFile))
#define SKK_ROM_KANA_MAP_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_ROM_KANA_MAP_FILE, SkkRomKanaMapFileClass))
#define SKK_IS_ROM_KANA_MAP_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_ROM_KANA_MAP_FILE))
#define SKK_IS_ROM_KANA_MAP_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_ROM_KANA_MAP_FILE))
#define SKK_ROM_KANA_MAP_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_ROM_KANA_MAP_FILE, SkkRomKanaMapFileClass))

typedef struct _SkkRomKanaMapFile SkkRomKanaMapFile;
typedef struct _SkkRomKanaMapFileClass SkkRomKanaMapFileClass;
typedef struct _SkkMapFilePrivate SkkMapFilePrivate;
typedef struct _SkkKeymapMapFilePrivate SkkKeymapMapFilePrivate;

#define SKK_TYPE_KEYMAP (skk_keymap_get_type ())
#define SKK_KEYMAP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_KEYMAP, SkkKeymap))
#define SKK_KEYMAP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_KEYMAP, SkkKeymapClass))
#define SKK_IS_KEYMAP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_KEYMAP))
#define SKK_IS_KEYMAP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_KEYMAP))
#define SKK_KEYMAP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_KEYMAP, SkkKeymapClass))

typedef struct _SkkKeymap SkkKeymap;
typedef struct _SkkKeymapClass SkkKeymapClass;

#define SKK_TYPE_CANDIDATE (skk_candidate_get_type ())
#define SKK_CANDIDATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_CANDIDATE, SkkCandidate))
#define SKK_CANDIDATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_CANDIDATE, SkkCandidateClass))
#define SKK_IS_CANDIDATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_CANDIDATE))
#define SKK_IS_CANDIDATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_CANDIDATE))
#define SKK_CANDIDATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_CANDIDATE, SkkCandidateClass))

typedef struct _SkkCandidate SkkCandidate;
typedef struct _SkkCandidateClass SkkCandidateClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define SKK_TYPE_STATE_HANDLER (skk_state_handler_get_type ())
#define SKK_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_STATE_HANDLER, SkkStateHandler))
#define SKK_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_STATE_HANDLER, SkkStateHandlerClass))
#define SKK_IS_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_STATE_HANDLER))
#define SKK_IS_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_STATE_HANDLER))
#define SKK_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_STATE_HANDLER, SkkStateHandlerClass))

typedef struct _SkkStateHandler SkkStateHandler;
typedef struct _SkkStateHandlerClass SkkStateHandlerClass;

#define SKK_TYPE_NONE_STATE_HANDLER (skk_none_state_handler_get_type ())
#define SKK_NONE_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_NONE_STATE_HANDLER, SkkNoneStateHandler))
#define SKK_NONE_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_NONE_STATE_HANDLER, SkkNoneStateHandlerClass))
#define SKK_IS_NONE_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_NONE_STATE_HANDLER))
#define SKK_IS_NONE_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_NONE_STATE_HANDLER))
#define SKK_NONE_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_NONE_STATE_HANDLER, SkkNoneStateHandlerClass))

typedef struct _SkkNoneStateHandler SkkNoneStateHandler;
typedef struct _SkkNoneStateHandlerClass SkkNoneStateHandlerClass;

#define SKK_TYPE_KEY_EVENT_FILTER (skk_key_event_filter_get_type ())
#define SKK_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_KEY_EVENT_FILTER, SkkKeyEventFilter))
#define SKK_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_KEY_EVENT_FILTER, SkkKeyEventFilterClass))
#define SKK_IS_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_KEY_EVENT_FILTER))
#define SKK_IS_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_KEY_EVENT_FILTER))
#define SKK_KEY_EVENT_FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_KEY_EVENT_FILTER, SkkKeyEventFilterClass))

typedef struct _SkkKeyEventFilter SkkKeyEventFilter;
typedef struct _SkkKeyEventFilterClass SkkKeyEventFilterClass;
#define _g_match_info_free0(var) ((var == NULL) ? NULL : (var = (g_match_info_free (var), NULL)))

#define SKK_TYPE_EXPR_READER (skk_expr_reader_get_type ())
#define SKK_EXPR_READER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_EXPR_READER, SkkExprReader))
#define SKK_EXPR_READER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_EXPR_READER, SkkExprReaderClass))
#define SKK_IS_EXPR_READER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_EXPR_READER))
#define SKK_IS_EXPR_READER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_EXPR_READER))
#define SKK_EXPR_READER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_EXPR_READER, SkkExprReaderClass))

typedef struct _SkkExprReader SkkExprReader;
typedef struct _SkkExprReaderClass SkkExprReaderClass;

#define SKK_TYPE_EXPR_NODE (skk_expr_node_get_type ())
#define SKK_EXPR_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_EXPR_NODE, SkkExprNode))
#define SKK_EXPR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_EXPR_NODE, SkkExprNodeClass))
#define SKK_IS_EXPR_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_EXPR_NODE))
#define SKK_IS_EXPR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_EXPR_NODE))
#define SKK_EXPR_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_EXPR_NODE, SkkExprNodeClass))

typedef struct _SkkExprNode SkkExprNode;
typedef struct _SkkExprNodeClass SkkExprNodeClass;

#define SKK_TYPE_EXPR_EVALUATOR (skk_expr_evaluator_get_type ())
#define SKK_EXPR_EVALUATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_EXPR_EVALUATOR, SkkExprEvaluator))
#define SKK_EXPR_EVALUATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_EXPR_EVALUATOR, SkkExprEvaluatorClass))
#define SKK_IS_EXPR_EVALUATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_EXPR_EVALUATOR))
#define SKK_IS_EXPR_EVALUATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_EXPR_EVALUATOR))
#define SKK_EXPR_EVALUATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_EXPR_EVALUATOR, SkkExprEvaluatorClass))

typedef struct _SkkExprEvaluator SkkExprEvaluator;
typedef struct _SkkExprEvaluatorClass SkkExprEvaluatorClass;
#define _skk_expr_node_unref0(var) ((var == NULL) ? NULL : (var = (skk_expr_node_unref (var), NULL)))

#define SKK_TYPE_NUMERIC_CONVERSION_TYPE (skk_numeric_conversion_type_get_type ())

#define SKK_TYPE_PERIOD_STYLE (skk_period_style_get_type ())
typedef struct _SkkStateHandlerPrivate SkkStateHandlerPrivate;
typedef struct _SkkNoneStateHandlerPrivate SkkNoneStateHandlerPrivate;

#define SKK_TYPE_ENTRY (skk_entry_get_type ())
typedef struct _SkkEntry SkkEntry;
typedef struct _SkkUnicodeStringPrivate SkkUnicodeStringPrivate;

#define SKK_TYPE_START_STATE_HANDLER (skk_start_state_handler_get_type ())
#define SKK_START_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_START_STATE_HANDLER, SkkStartStateHandler))
#define SKK_START_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_START_STATE_HANDLER, SkkStartStateHandlerClass))
#define SKK_IS_START_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_START_STATE_HANDLER))
#define SKK_IS_START_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_START_STATE_HANDLER))
#define SKK_START_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_START_STATE_HANDLER, SkkStartStateHandlerClass))

typedef struct _SkkStartStateHandler SkkStartStateHandler;
typedef struct _SkkStartStateHandlerClass SkkStartStateHandlerClass;

#define SKK_TYPE_MODIFIER_TYPE (skk_modifier_type_get_type ())

#define SKK_TYPE_ABBREV_STATE_HANDLER (skk_abbrev_state_handler_get_type ())
#define SKK_ABBREV_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_ABBREV_STATE_HANDLER, SkkAbbrevStateHandler))
#define SKK_ABBREV_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_ABBREV_STATE_HANDLER, SkkAbbrevStateHandlerClass))
#define SKK_IS_ABBREV_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_ABBREV_STATE_HANDLER))
#define SKK_IS_ABBREV_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_ABBREV_STATE_HANDLER))
#define SKK_ABBREV_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_ABBREV_STATE_HANDLER, SkkAbbrevStateHandlerClass))

typedef struct _SkkAbbrevStateHandler SkkAbbrevStateHandler;
typedef struct _SkkAbbrevStateHandlerClass SkkAbbrevStateHandlerClass;

#define SKK_TYPE_KUTEN_STATE_HANDLER (skk_kuten_state_handler_get_type ())
#define SKK_KUTEN_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_KUTEN_STATE_HANDLER, SkkKutenStateHandler))
#define SKK_KUTEN_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_KUTEN_STATE_HANDLER, SkkKutenStateHandlerClass))
#define SKK_IS_KUTEN_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_KUTEN_STATE_HANDLER))
#define SKK_IS_KUTEN_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_KUTEN_STATE_HANDLER))
#define SKK_KUTEN_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_KUTEN_STATE_HANDLER, SkkKutenStateHandlerClass))

typedef struct _SkkKutenStateHandler SkkKutenStateHandler;
typedef struct _SkkKutenStateHandlerClass SkkKutenStateHandlerClass;
typedef struct _SkkKutenStateHandlerPrivate SkkKutenStateHandlerPrivate;

#define SKK_TYPE_ENCODING_CONVERTER (skk_encoding_converter_get_type ())
#define SKK_ENCODING_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_ENCODING_CONVERTER, SkkEncodingConverter))
#define SKK_ENCODING_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_ENCODING_CONVERTER, SkkEncodingConverterClass))
#define SKK_IS_ENCODING_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_ENCODING_CONVERTER))
#define SKK_IS_ENCODING_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_ENCODING_CONVERTER))
#define SKK_ENCODING_CONVERTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_ENCODING_CONVERTER, SkkEncodingConverterClass))

typedef struct _SkkEncodingConverter SkkEncodingConverter;
typedef struct _SkkEncodingConverterClass SkkEncodingConverterClass;
#define _skk_encoding_converter_unref0(var) ((var == NULL) ? NULL : (var = (skk_encoding_converter_unref (var), NULL)))
typedef struct _SkkAbbrevStateHandlerPrivate SkkAbbrevStateHandlerPrivate;

#define SKK_TYPE_SELECT_STATE_HANDLER (skk_select_state_handler_get_type ())
#define SKK_SELECT_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SKK_TYPE_SELECT_STATE_HANDLER, SkkSelectStateHandler))
#define SKK_SELECT_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SKK_TYPE_SELECT_STATE_HANDLER, SkkSelectStateHandlerClass))
#define SKK_IS_SELECT_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SKK_TYPE_SELECT_STATE_HANDLER))
#define SKK_IS_SELECT_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SKK_TYPE_SELECT_STATE_HANDLER))
#define SKK_SELECT_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SKK_TYPE_SELECT_STATE_HANDLER, SkkSelectStateHandlerClass))

typedef struct _SkkSelectStateHandler SkkSelectStateHandler;
typedef struct _SkkSelectStateHandlerClass SkkSelectStateHandlerClass;
typedef struct _SkkStartStateHandlerPrivate SkkStartStateHandlerPrivate;
#define _skk_key_event_unref0(var) ((var == NULL) ? NULL : (var = (skk_key_event_unref (var), NULL)))
typedef struct _SkkSelectStateHandlerPrivate SkkSelectStateHandlerPrivate;

struct _SkkState {
	GObject parent_instance;
	SkkStatePrivate * priv;
	GType handler_type;
	GeeArrayList* dictionaries;
	SkkCandidateList* candidates;
	SkkRomKanaConverter* rom_kana_converter;
	SkkRomKanaConverter* okuri_rom_kana_converter;
	gboolean okuri;
	gchar* midasi;
	GString* output;
	GString* abbrev;
	GString* kuten;
	GeeIterator* completion_iterator;
	gchar** auto_start_henkan_keywords;
	gint auto_start_henkan_keywords_length1;
	gint _auto_start_henkan_keywords_size_;
	gchar* auto_start_henkan_keyword;
	gboolean egg_like_newline;
	SkkUnicodeString* surrounding_text;
	guint surrounding_end;
};

struct _SkkStateClass {
	GObjectClass parent_class;
};

typedef enum  {
	SKK_KANA_MODE_HIRAGANA,
	SKK_KANA_MODE_KATAKANA,
	SKK_KANA_MODE_HANKAKU_KATAKANA
} SkkKanaMode;

typedef enum  {
	SKK_INPUT_MODE_HIRAGANA = SKK_KANA_MODE_HIRAGANA,
	SKK_INPUT_MODE_KATAKANA = SKK_KANA_MODE_KATAKANA,
	SKK_INPUT_MODE_HANKAKU_KATAKANA = SKK_KANA_MODE_HANKAKU_KATAKANA,
	SKK_INPUT_MODE_LATIN,
	SKK_INPUT_MODE_WIDE_LATIN,
	SKK_INPUT_MODE_LAST,
	SKK_INPUT_MODE_DEFAULT = SKK_INPUT_MODE_HIRAGANA
} SkkInputMode;

struct _SkkStatePrivate {
	SkkInputMode _input_mode;
	GeeArrayList* completion;
	SkkRule* _typing_rule;
	GRegex* numeric_regex;
	GRegex* numeric_ref_regex;
};

struct _SkkRule {
	GObject parent_instance;
	SkkRulePrivate * priv;
	SkkKeymapMapFile** keymaps;
	gint keymaps_length1;
	gint _keymaps_size_;
	SkkRomKanaMapFile* rom_kana;
};

struct _SkkRuleClass {
	GObjectClass parent_class;
};

struct _SkkMapFile {
	GObject parent_instance;
	SkkMapFilePrivate * priv;
};

struct _SkkMapFileClass {
	GObjectClass parent_class;
};

struct _SkkKeymapMapFile {
	SkkMapFile parent_instance;
	SkkKeymapMapFilePrivate * priv;
	SkkKeymap* keymap;
};

struct _SkkKeymapMapFileClass {
	SkkMapFileClass parent_class;
};

typedef enum  {
	SKK_RULE_PARSE_ERROR_FAILED
} SkkRuleParseError;
#define SKK_RULE_PARSE_ERROR skk_rule_parse_error_quark ()
typedef enum  {
	SKK_NUMERIC_CONVERSION_TYPE_LATIN,
	SKK_NUMERIC_CONVERSION_TYPE_WIDE_LATIN,
	SKK_NUMERIC_CONVERSION_TYPE_KANJI_NUMERAL,
	SKK_NUMERIC_CONVERSION_TYPE_KANJI,
	SKK_NUMERIC_CONVERSION_TYPE_RECONVERT,
	SKK_NUMERIC_CONVERSION_TYPE_DAIJI,
	SKK_NUMERIC_CONVERSION_TYPE_SHOGI
} SkkNumericConversionType;

typedef enum  {
	SKK_PERIOD_STYLE_JA_JA,
	SKK_PERIOD_STYLE_EN_EN,
	SKK_PERIOD_STYLE_JA_EN,
	SKK_PERIOD_STYLE_EN_JA
} SkkPeriodStyle;

typedef gboolean (*SkkCommandHandler) (SkkState* state, void* user_data);
struct _SkkStateHandler {
	GObject parent_instance;
	SkkStateHandlerPrivate * priv;
};

struct _SkkStateHandlerClass {
	GObjectClass parent_class;
	gboolean (*process_key_event) (SkkStateHandler* self, SkkState* state, SkkKeyEvent** key);
	gchar* (*get_preedit) (SkkStateHandler* self, SkkState* state, guint* underline_offset, guint* underline_nchars);
	gchar* (*get_output) (SkkStateHandler* self, SkkState* state);
};

struct _SkkNoneStateHandler {
	SkkStateHandler parent_instance;
	SkkNoneStateHandlerPrivate * priv;
};

struct _SkkNoneStateHandlerClass {
	SkkStateHandlerClass parent_class;
};

struct _SkkEntry {
	gpointer key;
	gpointer value;
};

struct _SkkUnicodeString {
	GObject parent_instance;
	SkkUnicodeStringPrivate * priv;
	gint length;
};

struct _SkkUnicodeStringClass {
	GObjectClass parent_class;
};

typedef enum  {
	SKK_MODIFIER_TYPE_NONE = 0,
	SKK_MODIFIER_TYPE_SHIFT_MASK = 1 << 0,
	SKK_MODIFIER_TYPE_LOCK_MASK = 1 << 1,
	SKK_MODIFIER_TYPE_CONTROL_MASK = 1 << 2,
	SKK_MODIFIER_TYPE_MOD1_MASK = 1 << 3,
	SKK_MODIFIER_TYPE_MOD2_MASK = 1 << 4,
	SKK_MODIFIER_TYPE_MOD3_MASK = 1 << 5,
	SKK_MODIFIER_TYPE_MOD4_MASK = 1 << 6,
	SKK_MODIFIER_TYPE_MOD5_MASK = 1 << 7,
	SKK_MODIFIER_TYPE_LSHIFT_MASK = 1 << 22,
	SKK_MODIFIER_TYPE_RSHIFT_MASK = 1 << 23,
	SKK_MODIFIER_TYPE_USLEEP_MASK = 1 << 24,
	SKK_MODIFIER_TYPE_SUPER_MASK = 1 << 26,
	SKK_MODIFIER_TYPE_HYPER_MASK = 1 << 27,
	SKK_MODIFIER_TYPE_META_MASK = 1 << 28,
	SKK_MODIFIER_TYPE_RELEASE_MASK = 1 << 30
} SkkModifierType;

struct _SkkKutenStateHandler {
	SkkStateHandler parent_instance;
	SkkKutenStateHandlerPrivate * priv;
};

struct _SkkKutenStateHandlerClass {
	SkkStateHandlerClass parent_class;
};

struct _SkkKutenStateHandlerPrivate {
	SkkEncodingConverter* converter;
};

struct _SkkAbbrevStateHandler {
	SkkStateHandler parent_instance;
	SkkAbbrevStateHandlerPrivate * priv;
};

struct _SkkAbbrevStateHandlerClass {
	SkkStateHandlerClass parent_class;
};

struct _SkkStartStateHandler {
	SkkStateHandler parent_instance;
	SkkStartStateHandlerPrivate * priv;
};

struct _SkkStartStateHandlerClass {
	SkkStateHandlerClass parent_class;
};

struct _SkkSelectStateHandler {
	SkkStateHandler parent_instance;
	SkkSelectStateHandlerPrivate * priv;
};

struct _SkkSelectStateHandlerClass {
	SkkStateHandlerClass parent_class;
};


static gpointer skk_state_parent_class = NULL;
static gpointer skk_state_handler_parent_class = NULL;
static gpointer skk_none_state_handler_parent_class = NULL;
static gpointer skk_kuten_state_handler_parent_class = NULL;
static gpointer skk_abbrev_state_handler_parent_class = NULL;
static gpointer skk_start_state_handler_parent_class = NULL;
static gpointer skk_select_state_handler_parent_class = NULL;

GType skk_state_get_type (void) G_GNUC_CONST;
GType skk_dict_get_type (void) G_GNUC_CONST;
GType skk_candidate_list_get_type (void) G_GNUC_CONST;
GType skk_rom_kana_converter_get_type (void) G_GNUC_CONST;
GType skk_unicode_string_get_type (void) G_GNUC_CONST;
GType skk_kana_mode_get_type (void) G_GNUC_CONST;
GType skk_input_mode_get_type (void) G_GNUC_CONST;
GType skk_rule_get_type (void) G_GNUC_CONST;
#define SKK_STATE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SKK_TYPE_STATE, SkkStatePrivate))
enum  {
	SKK_STATE_DUMMY_PROPERTY,
	SKK_STATE_INPUT_MODE,
	SKK_STATE_PERIOD_STYLE,
	SKK_STATE_TYPING_RULE
};
void skk_state_reset (SkkState* self);
gpointer skk_key_event_ref (gpointer instance);
void skk_key_event_unref (gpointer instance);
GParamSpec* skk_param_spec_key_event (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void skk_value_set_key_event (GValue* value, gpointer v_object);
void skk_value_take_key_event (GValue* value, gpointer v_object);
gpointer skk_value_get_key_event (const GValue* value);
GType skk_key_event_get_type (void) G_GNUC_CONST;
gchar* skk_state_lookup_key (SkkState* self, SkkKeyEvent* key);
GType skk_map_file_get_type (void) G_GNUC_CONST;
GType skk_keymap_map_file_get_type (void) G_GNUC_CONST;
GType skk_rom_kana_map_file_get_type (void) G_GNUC_CONST;
SkkInputMode skk_state_get_input_mode (SkkState* self);
GType skk_keymap_get_type (void) G_GNUC_CONST;
gchar* skk_keymap_lookup_key (SkkKeymap* self, SkkKeyEvent* key);
SkkKeyEvent* skk_state_where_is (SkkState* self, const gchar* command);
SkkKeyEvent* skk_keymap_where_is (SkkKeymap* self, const gchar* command);
SkkState* skk_state_new (GeeArrayList* dictionaries);
SkkState* skk_state_construct (GType object_type, GeeArrayList* dictionaries);
SkkCandidateList* skk_candidate_list_new (guint page_start, guint page_size);
SkkCandidateList* skk_candidate_list_construct (GType object_type, guint page_start, guint page_size);
GType skk_candidate_get_type (void) G_GNUC_CONST;
static void skk_state_candidate_selected (SkkState* self, SkkCandidate* c);
static void _skk_state_candidate_selected_skk_candidate_list_selected (SkkCandidateList* _sender, SkkCandidate* candidate, gpointer self);
SkkRomKanaConverter* skk_rom_kana_converter_new (void);
SkkRomKanaConverter* skk_rom_kana_converter_construct (GType object_type);
static gchar** _vala_array_dup2 (gchar** self, int length);
GQuark skk_rule_parse_error_quark (void);
SkkRule* skk_rule_new (const gchar* name, GError** error);
SkkRule* skk_rule_construct (GType object_type, const gchar* name, GError** error);
const gchar* skk_candidate_get_output (SkkCandidate* self);
const gchar* skk_rom_kana_converter_get_output (SkkRomKanaConverter* self);
void skk_state_output_surrounding_text (SkkState* self);
gchar* skk_unicode_string_substring (SkkUnicodeString* self, glong offset, glong len);
GType skk_state_handler_get_type (void) G_GNUC_CONST;
GType skk_none_state_handler_get_type (void) G_GNUC_CONST;
void skk_rom_kana_converter_reset (SkkRomKanaConverter* self);
GType skk_key_event_filter_get_type (void) G_GNUC_CONST;
SkkKeyEventFilter* skk_rule_get_filter (SkkRule* self);
void skk_key_event_filter_reset (SkkKeyEventFilter* self);
void skk_candidate_list_clear (SkkCandidateList* self);
void skk_state_cancel_okuri (SkkState* self);
void skk_rom_kana_converter_set_output (SkkRomKanaConverter* self, const gchar* value);
static gchar* skk_state_extract_numerics (SkkState* self, const gchar* midasi, gint** numerics, int* numerics_length1);
static gchar* skk_state_expand_expr (SkkState* self, const gchar* text);
SkkExprReader* skk_expr_reader_new (void);
SkkExprReader* skk_expr_reader_construct (GType object_type);
GType skk_expr_reader_get_type (void) G_GNUC_CONST;
gpointer skk_expr_node_ref (gpointer instance);
void skk_expr_node_unref (gpointer instance);
GParamSpec* skk_param_spec_expr_node (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void skk_value_set_expr_node (GValue* value, gpointer v_object);
void skk_value_take_expr_node (GValue* value, gpointer v_object);
gpointer skk_value_get_expr_node (const GValue* value);
GType skk_expr_node_get_type (void) G_GNUC_CONST;
SkkExprNode* skk_expr_reader_read_expr (SkkExprReader* self, const gchar* expr, gint* index);
SkkExprEvaluator* skk_expr_evaluator_new (void);
SkkExprEvaluator* skk_expr_evaluator_construct (GType object_type);
GType skk_expr_evaluator_get_type (void) G_GNUC_CONST;
gchar* skk_expr_evaluator_eval (SkkExprEvaluator* self, SkkExprNode* node);
static gchar* skk_state_expand_numeric_references (SkkState* self, const gchar* text, gint* numerics, int numerics_length1);
GType skk_numeric_conversion_type_get_type (void) G_GNUC_CONST;
gchar* skk_util_get_numeric (gint numeric, SkkNumericConversionType type);
void skk_state_lookup (SkkState* self, const gchar* midasi, gboolean okuri);
void skk_candidate_list_add_candidates_start (SkkCandidateList* self);
static void skk_state_lookup_internal (SkkState* self, const gchar* midasi, gint* numerics, int numerics_length1, gboolean okuri);
void skk_candidate_list_add_candidates_end (SkkCandidateList* self);
SkkCandidate** skk_dict_lookup (SkkDict* self, const gchar* midasi, gboolean okuri, int* result_length1);
const gchar* skk_candidate_get_text (SkkCandidate* self);
void skk_candidate_set_output (SkkCandidate* self, const gchar* value);
const gchar* skk_candidate_get_annotation (SkkCandidate* self);
void skk_candidate_set_annotation (SkkCandidate* self, const gchar* value);
void skk_candidate_list_add_candidates (SkkCandidateList* self, SkkCandidate** array, int array_length1);
void skk_state_purge_candidate (SkkState* self, SkkCandidate* candidate);
gboolean skk_dict_get_read_only (SkkDict* self);
gboolean skk_dict_purge_candidate (SkkDict* self, SkkCandidate* candidate);
void skk_state_completion_start (SkkState* self, const gchar* midasi);
gchar** skk_dict_complete (SkkDict* self, const gchar* midasi, int* result_length1);
gchar* skk_state_get_yomi (SkkState* self);
const gchar* skk_rom_kana_converter_get_preedit (SkkRomKanaConverter* self);
void skk_state_set_input_mode (SkkState* self, SkkInputMode value);
void skk_rom_kana_converter_set_kana_mode (SkkRomKanaConverter* self, SkkKanaMode value);
GType skk_period_style_get_type (void) G_GNUC_CONST;
SkkPeriodStyle skk_state_get_period_style (SkkState* self);
SkkPeriodStyle skk_rom_kana_converter_get_period_style (SkkRomKanaConverter* self);
void skk_state_set_period_style (SkkState* self, SkkPeriodStyle value);
void skk_rom_kana_converter_set_period_style (SkkRomKanaConverter* self, SkkPeriodStyle value);
SkkRule* skk_state_get_typing_rule (SkkState* self);
void skk_state_set_typing_rule (SkkState* self, SkkRule* value);
void skk_rom_kana_converter_set_rule (SkkRomKanaConverter* self, SkkRomKanaMapFile* value);
static void g_cclosure_user_marshal_BOOLEAN__VOID (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_BOOLEAN__STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__STRING_BOOLEAN (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_BOOLEAN__POINTER_POINTER (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_BOOLEAN__INT_UINT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void skk_state_finalize (GObject* obj);
static void _vala_skk_state_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_skk_state_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
enum  {
	SKK_STATE_HANDLER_DUMMY_PROPERTY
};
gboolean skk_state_handler_process_key_event (SkkStateHandler* self, SkkState* state, SkkKeyEvent** key);
static gboolean skk_state_handler_real_process_key_event (SkkStateHandler* self, SkkState* state, SkkKeyEvent** key);
gchar* skk_state_handler_get_preedit (SkkStateHandler* self, SkkState* state, guint* underline_offset, guint* underline_nchars);
static gchar* skk_state_handler_real_get_preedit (SkkStateHandler* self, SkkState* state, guint* underline_offset, guint* underline_nchars);
gchar* skk_state_handler_get_output (SkkStateHandler* self, SkkState* state);
static gchar* skk_state_handler_real_get_output (SkkStateHandler* self, SkkState* state);
SkkStateHandler* skk_state_handler_construct (GType object_type);
enum  {
	SKK_NONE_STATE_HANDLER_DUMMY_PROPERTY
};
GType skk_entry_get_type (void) G_GNUC_CONST;
SkkEntry* skk_entry_dup (const SkkEntry* self);
void skk_entry_free (SkkEntry* self);
void skk_entry_copy (const SkkEntry* self, SkkEntry* dest);
void skk_entry_destroy (SkkEntry* self);
static gboolean skk_none_state_handler_real_process_key_event (SkkStateHandler* base, SkkState* state, SkkKeyEvent** key);
SkkUnicodeString* skk_unicode_string_new (const gchar* str);
SkkUnicodeString* skk_unicode_string_construct (GType object_type, const gchar* str);
GType skk_start_state_handler_get_type (void) G_GNUC_CONST;
GType skk_modifier_type_get_type (void) G_GNUC_CONST;
SkkModifierType skk_key_event_get_modifiers (SkkKeyEvent* self);
gboolean skk_rom_kana_converter_can_consume (SkkRomKanaConverter* self, gunichar uc, gboolean preedit_only, gboolean no_carryover);
gunichar skk_key_event_get_code (SkkKeyEvent* self);
gboolean skk_rom_kana_converter_delete (SkkRomKanaConverter* self);
GType skk_abbrev_state_handler_get_type (void) G_GNUC_CONST;
GType skk_kuten_state_handler_get_type (void) G_GNUC_CONST;
gchar* skk_util_convert_by_input_mode (const gchar* str, SkkInputMode input_mode);
gboolean skk_rom_kana_converter_append (SkkRomKanaConverter* self, gunichar uc);
gunichar skk_util_get_wide_latin_char (gchar c);
static gchar* skk_none_state_handler_real_get_preedit (SkkStateHandler* base, SkkState* state, guint* underline_offset, guint* underline_nchars);
SkkNoneStateHandler* skk_none_state_handler_new (void);
SkkNoneStateHandler* skk_none_state_handler_construct (GType object_type);
gpointer skk_encoding_converter_ref (gpointer instance);
void skk_encoding_converter_unref (gpointer instance);
GParamSpec* skk_param_spec_encoding_converter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void skk_value_set_encoding_converter (GValue* value, gpointer v_object);
void skk_value_take_encoding_converter (GValue* value, gpointer v_object);
gpointer skk_value_get_encoding_converter (const GValue* value);
GType skk_encoding_converter_get_type (void) G_GNUC_CONST;
#define SKK_KUTEN_STATE_HANDLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SKK_TYPE_KUTEN_STATE_HANDLER, SkkKutenStateHandlerPrivate))
enum  {
	SKK_KUTEN_STATE_HANDLER_DUMMY_PROPERTY
};
SkkKutenStateHandler* skk_kuten_state_handler_new (void);
SkkKutenStateHandler* skk_kuten_state_handler_construct (GType object_type);
SkkEncodingConverter* skk_encoding_converter_new (const gchar* encoding, GError** error);
SkkEncodingConverter* skk_encoding_converter_construct (GType object_type, const gchar* encoding, GError** error);
static gint skk_kuten_state_handler_hex_char_to_int (SkkKutenStateHandler* self, gchar hex);
static gchar* skk_kuten_state_handler_parse_hex (SkkKutenStateHandler* self, const gchar* hex);
static gboolean skk_kuten_state_handler_real_process_key_event (SkkStateHandler* base, SkkState* state, SkkKeyEvent** key);
gchar* skk_encoding_converter_decode (SkkEncodingConverter* self, const gchar* external_str, GError** error);
static gchar* skk_kuten_state_handler_real_get_preedit (SkkStateHandler* base, SkkState* state, guint* underline_offset, guint* underline_nchars);
static void skk_kuten_state_handler_finalize (GObject* obj);
enum  {
	SKK_ABBREV_STATE_HANDLER_DUMMY_PROPERTY
};
static gboolean skk_abbrev_state_handler_real_process_key_event (SkkStateHandler* base, SkkState* state, SkkKeyEvent** key);
GType skk_select_state_handler_get_type (void) G_GNUC_CONST;
gchar* skk_util_get_wide_latin (const gchar* latin);
static gchar* skk_abbrev_state_handler_real_get_preedit (SkkStateHandler* base, SkkState* state, guint* underline_offset, guint* underline_nchars);
SkkAbbrevStateHandler* skk_abbrev_state_handler_new (void);
SkkAbbrevStateHandler* skk_abbrev_state_handler_construct (GType object_type);
enum  {
	SKK_START_STATE_HANDLER_DUMMY_PROPERTY
};
static gboolean skk_start_state_handler_real_process_key_event (SkkStateHandler* base, SkkState* state, SkkKeyEvent** key);
void skk_rom_kana_converter_output_nn_if_any (SkkRomKanaConverter* self);
static gboolean skk_start_state_handler_check_auto_conversion (SkkStartStateHandler* self, SkkState* state, SkkKeyEvent* key);
static gchar* skk_start_state_handler_real_get_preedit (SkkStateHandler* base, SkkState* state, guint* underline_offset, guint* underline_nchars);
SkkStartStateHandler* skk_start_state_handler_new (void);
SkkStartStateHandler* skk_start_state_handler_construct (GType object_type);
enum  {
	SKK_SELECT_STATE_HANDLER_DUMMY_PROPERTY
};
static gboolean skk_select_state_handler_real_process_key_event (SkkStateHandler* base, SkkState* state, SkkKeyEvent** key);
gboolean skk_candidate_list_previous (SkkCandidateList* self);
SkkCandidate* skk_candidate_list_get (SkkCandidateList* self, gint index);
gint skk_candidate_list_get_cursor_pos (SkkCandidateList* self);
gchar* skk_util_get_okurigana_prefix (const gchar* okurigana);
gchar* skk_util_get_hiragana (const gchar* kana);
gint skk_candidate_list_get_size (SkkCandidateList* self);
gboolean skk_candidate_list_next (SkkCandidateList* self);
void skk_candidate_list_select (SkkCandidateList* self, gint index);
static gchar* skk_select_state_handler_real_get_preedit (SkkStateHandler* base, SkkState* state, guint* underline_offset, guint* underline_nchars);
SkkSelectStateHandler* skk_select_state_handler_new (void);
SkkSelectStateHandler* skk_select_state_handler_construct (GType object_type);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

const gchar* SKK_AUTO_START_HENKAN_KEYWORDS[28] = {"を", "、", "。", "．", "，", "？", "」", "！", "；", "：", ")", ";", ":", "）", "”", "】", "』", "》", "〉", "｝", "］", "〕", "}", "]", "?", ".", ",", "!"};
static const SkkEntry SKK_NONE_STATE_HANDLER_input_mode_commands[5] = {{"set-input-mode-hiragana", SKK_INPUT_MODE_HIRAGANA}, {"set-input-mode-katakana", SKK_INPUT_MODE_KATAKANA}, {"set-input-mode-hankaku-katakana", SKK_INPUT_MODE_HANKAKU_KATAKANA}, {"set-input-mode-latin", SKK_INPUT_MODE_LATIN}, {"set-input-mode-wide-latin", SKK_INPUT_MODE_WIDE_LATIN}};
static const SkkEntry SKK_START_STATE_HANDLER_end_preedit_commands[3] = {{"set-input-mode-hiragana", SKK_INPUT_MODE_HIRAGANA}, {"set-input-mode-katakana", SKK_INPUT_MODE_KATAKANA}, {"set-input-mode-hankaku-katakana", SKK_INPUT_MODE_HANKAKU_KATAKANA}};

static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


gchar* skk_state_lookup_key (SkkState* self, SkkKeyEvent* key) {
	gchar* result = NULL;
	SkkRule* _tmp0_;
	SkkKeymapMapFile** _tmp1_;
	gint _tmp1__length1;
	SkkInputMode _tmp2_;
	SkkInputMode _tmp3_;
	SkkKeymapMapFile* _tmp4_;
	SkkKeymap* _tmp5_;
	SkkKeymap* _tmp6_;
	SkkKeymap* keymap;
	SkkKeyEvent* _tmp7_;
	gchar* _tmp8_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = self->priv->_typing_rule;
	_tmp1_ = _tmp0_->keymaps;
	_tmp1__length1 = _tmp0_->keymaps_length1;
	_tmp2_ = skk_state_get_input_mode (self);
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp1_[_tmp3_];
	_tmp5_ = _tmp4_->keymap;
	_tmp6_ = _g_object_ref0 (_tmp5_);
	keymap = _tmp6_;
	g_return_val_if_fail (keymap != NULL, NULL);
	_tmp7_ = key;
	_tmp8_ = skk_keymap_lookup_key (keymap, _tmp7_);
	result = _tmp8_;
	_g_object_unref0 (keymap);
	return result;
}


SkkKeyEvent* skk_state_where_is (SkkState* self, const gchar* command) {
	SkkKeyEvent* result = NULL;
	SkkRule* _tmp0_;
	SkkKeymapMapFile** _tmp1_;
	gint _tmp1__length1;
	SkkInputMode _tmp2_;
	SkkInputMode _tmp3_;
	SkkKeymapMapFile* _tmp4_;
	SkkKeymap* _tmp5_;
	SkkKeymap* _tmp6_;
	SkkKeymap* keymap;
	const gchar* _tmp7_;
	SkkKeyEvent* _tmp8_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (command != NULL, NULL);
	_tmp0_ = self->priv->_typing_rule;
	_tmp1_ = _tmp0_->keymaps;
	_tmp1__length1 = _tmp0_->keymaps_length1;
	_tmp2_ = skk_state_get_input_mode (self);
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp1_[_tmp3_];
	_tmp5_ = _tmp4_->keymap;
	_tmp6_ = _g_object_ref0 (_tmp5_);
	keymap = _tmp6_;
	g_return_val_if_fail (keymap != NULL, NULL);
	_tmp7_ = command;
	_tmp8_ = skk_keymap_where_is (keymap, _tmp7_);
	result = _tmp8_;
	_g_object_unref0 (keymap);
	return result;
}


static void _skk_state_candidate_selected_skk_candidate_list_selected (SkkCandidateList* _sender, SkkCandidate* candidate, gpointer self) {
	skk_state_candidate_selected (self, candidate);
}


static gchar** _vala_array_dup2 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


SkkState* skk_state_construct (GType object_type, GeeArrayList* dictionaries) {
	SkkState * self = NULL;
	GeeArrayList* _tmp0_;
	GeeArrayList* _tmp1_;
	SkkCandidateList* _tmp2_;
	SkkCandidateList* _tmp3_;
	SkkRomKanaConverter* _tmp4_;
	SkkRomKanaConverter* _tmp5_;
	gchar** _tmp6_;
	gint _tmp6__length1;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (dictionaries != NULL, NULL);
	self = (SkkState*) g_object_new (object_type, NULL);
	_tmp0_ = dictionaries;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->dictionaries);
	self->dictionaries = _tmp1_;
	_tmp2_ = skk_candidate_list_new ((guint) 4, (guint) 7);
	_g_object_unref0 (self->candidates);
	self->candidates = _tmp2_;
	_tmp3_ = self->candidates;
	g_signal_connect_object (_tmp3_, "selected", (GCallback) _skk_state_candidate_selected_skk_candidate_list_selected, self, 0);
	_tmp4_ = skk_rom_kana_converter_new ();
	_g_object_unref0 (self->rom_kana_converter);
	self->rom_kana_converter = _tmp4_;
	_tmp5_ = skk_rom_kana_converter_new ();
	_g_object_unref0 (self->okuri_rom_kana_converter);
	self->okuri_rom_kana_converter = _tmp5_;
	_tmp6_ = (SKK_AUTO_START_HENKAN_KEYWORDS != NULL) ? _vala_array_dup2 (SKK_AUTO_START_HENKAN_KEYWORDS, G_N_ELEMENTS (SKK_AUTO_START_HENKAN_KEYWORDS)) : ((gpointer) SKK_AUTO_START_HENKAN_KEYWORDS);
	_tmp6__length1 = G_N_ELEMENTS (SKK_AUTO_START_HENKAN_KEYWORDS);
	self->auto_start_henkan_keywords = (_vala_array_free (self->auto_start_henkan_keywords, self->auto_start_henkan_keywords_length1, (GDestroyNotify) g_free), NULL);
	self->auto_start_henkan_keywords = _tmp6_;
	self->auto_start_henkan_keywords_length1 = _tmp6__length1;
	self->_auto_start_henkan_keywords_size_ = self->auto_start_henkan_keywords_length1;
	{
		SkkRule* _tmp7_;
		SkkRule* _tmp8_;
		_tmp7_ = skk_rule_new ("default", &_inner_error_);
		_tmp8_ = _tmp7_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == SKK_RULE_PARSE_ERROR) {
				goto __catch25_skk_rule_parse_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_object_unref0 (self->priv->_typing_rule);
		self->priv->_typing_rule = _tmp8_;
	}
	goto __finally25;
	__catch25_skk_rule_parse_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally25:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	{
		GRegex* _tmp9_;
		GRegex* _tmp10_;
		_tmp9_ = g_regex_new ("[0-9]+", 0, 0, &_inner_error_);
		_tmp10_ = _tmp9_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch26_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (self->priv->numeric_regex);
		self->priv->numeric_regex = _tmp10_;
	}
	goto __finally26;
	__catch26_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally26:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	{
		GRegex* _tmp11_;
		GRegex* _tmp12_;
		_tmp11_ = g_regex_new ("#([0-9])", 0, 0, &_inner_error_);
		_tmp12_ = _tmp11_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch27_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (self->priv->numeric_ref_regex);
		self->priv->numeric_ref_regex = _tmp12_;
	}
	goto __finally27;
	__catch27_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally27:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	skk_state_reset (self);
	return self;
}


SkkState* skk_state_new (GeeArrayList* dictionaries) {
	return skk_state_construct (SKK_TYPE_STATE, dictionaries);
}


static void skk_state_candidate_selected (SkkState* self, SkkCandidate* c) {
	GString* _tmp0_;
	SkkCandidate* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	SkkInputMode _tmp12_;
	SkkInputMode _tmp13_;
	SkkInputMode _mode;
	g_return_if_fail (self != NULL);
	g_return_if_fail (c != NULL);
	_tmp0_ = self->output;
	_tmp1_ = c;
	_tmp2_ = skk_candidate_get_output (_tmp1_);
	_tmp3_ = _tmp2_;
	g_string_append (_tmp0_, _tmp3_);
	_tmp4_ = self->auto_start_henkan_keyword;
	if (_tmp4_ != NULL) {
		GString* _tmp5_;
		const gchar* _tmp6_;
		_tmp5_ = self->output;
		_tmp6_ = self->auto_start_henkan_keyword;
		g_string_append (_tmp5_, _tmp6_);
	} else {
		gboolean _tmp7_;
		_tmp7_ = self->okuri;
		if (_tmp7_) {
			GString* _tmp8_;
			SkkRomKanaConverter* _tmp9_;
			const gchar* _tmp10_;
			const gchar* _tmp11_;
			_tmp8_ = self->output;
			_tmp9_ = self->okuri_rom_kana_converter;
			_tmp10_ = skk_rom_kana_converter_get_output (_tmp9_);
			_tmp11_ = _tmp10_;
			g_string_append (_tmp8_, _tmp11_);
		}
	}
	_tmp12_ = skk_state_get_input_mode (self);
	_tmp13_ = _tmp12_;
	_mode = _tmp13_;
	skk_state_reset (self);
	self->priv->_input_mode = _mode;
}


void skk_state_output_surrounding_text (SkkState* self) {
	SkkUnicodeString* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->surrounding_text;
	if (_tmp0_ != NULL) {
		GString* _tmp1_;
		SkkUnicodeString* _tmp2_;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		_tmp1_ = self->output;
		_tmp2_ = self->surrounding_text;
		_tmp3_ = skk_unicode_string_substring (_tmp2_, (glong) 0, (glong) (-1));
		_tmp4_ = _tmp3_;
		g_string_append (_tmp1_, _tmp4_);
		_g_free0 (_tmp4_);
	}
}


void skk_state_reset (SkkState* self) {
	SkkRomKanaConverter* _tmp0_;
	SkkRomKanaConverter* _tmp1_;
	SkkRule* _tmp2_;
	SkkKeyEventFilter* _tmp3_ = NULL;
	SkkKeyEventFilter* _tmp4_;
	GeeArrayList* _tmp5_;
	SkkCandidateList* _tmp6_;
	GString* _tmp7_;
	GString* _tmp8_;
	g_return_if_fail (self != NULL);
	self->handler_type = SKK_TYPE_NONE_STATE_HANDLER;
	_tmp0_ = self->rom_kana_converter;
	skk_rom_kana_converter_reset (_tmp0_);
	_tmp1_ = self->okuri_rom_kana_converter;
	skk_rom_kana_converter_reset (_tmp1_);
	self->okuri = FALSE;
	_tmp2_ = self->priv->_typing_rule;
	_tmp3_ = skk_rule_get_filter (_tmp2_);
	_tmp4_ = _tmp3_;
	skk_key_event_filter_reset (_tmp4_);
	_g_object_unref0 (_tmp4_);
	_g_object_unref0 (self->completion_iterator);
	self->completion_iterator = NULL;
	_tmp5_ = self->priv->completion;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp5_);
	_tmp6_ = self->candidates;
	skk_candidate_list_clear (_tmp6_);
	_tmp7_ = self->abbrev;
	g_string_erase (_tmp7_, (gssize) 0, (gssize) (-1));
	_tmp8_ = self->kuten;
	g_string_erase (_tmp8_, (gssize) 0, (gssize) (-1));
	_g_free0 (self->auto_start_henkan_keyword);
	self->auto_start_henkan_keyword = NULL;
	_g_object_unref0 (self->surrounding_text);
	self->surrounding_text = NULL;
	self->surrounding_end = (guint) 0;
}


void skk_state_cancel_okuri (SkkState* self) {
	SkkRomKanaConverter* _tmp0_;
	SkkRomKanaConverter* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	SkkRomKanaConverter* _tmp4_;
	const gchar* _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	SkkRomKanaConverter* _tmp9_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->rom_kana_converter;
	_tmp1_ = self->rom_kana_converter;
	_tmp2_ = skk_rom_kana_converter_get_output (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = self->okuri_rom_kana_converter;
	_tmp5_ = skk_rom_kana_converter_get_output (_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = g_strconcat (_tmp3_, _tmp6_, NULL);
	_tmp8_ = _tmp7_;
	skk_rom_kana_converter_set_output (_tmp1_, _tmp8_);
	_g_free0 (_tmp8_);
	_tmp9_ = self->okuri_rom_kana_converter;
	skk_rom_kana_converter_reset (_tmp9_);
	self->okuri = FALSE;
}


static gchar* string_slice (const gchar* self, glong start, glong end) {
	gchar* result = NULL;
	gint _tmp0_;
	gint _tmp1_;
	glong string_length;
	glong _tmp2_;
	glong _tmp5_;
	gboolean _tmp8_ = FALSE;
	glong _tmp9_;
	gboolean _tmp12_;
	gboolean _tmp13_ = FALSE;
	glong _tmp14_;
	gboolean _tmp17_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	string_length = (glong) _tmp1_;
	_tmp2_ = start;
	if (_tmp2_ < ((glong) 0)) {
		glong _tmp3_;
		glong _tmp4_;
		_tmp3_ = string_length;
		_tmp4_ = start;
		start = _tmp3_ + _tmp4_;
	}
	_tmp5_ = end;
	if (_tmp5_ < ((glong) 0)) {
		glong _tmp6_;
		glong _tmp7_;
		_tmp6_ = string_length;
		_tmp7_ = end;
		end = _tmp6_ + _tmp7_;
	}
	_tmp9_ = start;
	if (_tmp9_ >= ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		_tmp10_ = start;
		_tmp11_ = string_length;
		_tmp8_ = _tmp10_ <= _tmp11_;
	} else {
		_tmp8_ = FALSE;
	}
	_tmp12_ = _tmp8_;
	g_return_val_if_fail (_tmp12_, NULL);
	_tmp14_ = end;
	if (_tmp14_ >= ((glong) 0)) {
		glong _tmp15_;
		glong _tmp16_;
		_tmp15_ = end;
		_tmp16_ = string_length;
		_tmp13_ = _tmp15_ <= _tmp16_;
	} else {
		_tmp13_ = FALSE;
	}
	_tmp17_ = _tmp13_;
	g_return_val_if_fail (_tmp17_, NULL);
	_tmp18_ = start;
	_tmp19_ = end;
	g_return_val_if_fail (_tmp18_ <= _tmp19_, NULL);
	_tmp20_ = start;
	_tmp21_ = end;
	_tmp22_ = start;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) (_tmp21_ - _tmp22_));
	result = _tmp23_;
	return result;
}


static gchar* skk_state_extract_numerics (SkkState* self, const gchar* midasi, gint** numerics, int* numerics_length1) {
	gint* _vala_numerics = NULL;
	int _vala_numerics_length1 = 0;
	gchar* result = NULL;
	GMatchInfo* info;
	gint start_pos;
	GeeArrayList* _tmp0_;
	GeeArrayList* numeric_list;
	GString* _tmp1_;
	GString* builder;
	GeeArrayList* _tmp25_;
	gint _tmp26_ = 0;
	gpointer* _tmp27_ = NULL;
	GString* _tmp28_;
	const gchar* _tmp29_;
	gint _tmp30_;
	const gchar* _tmp31_;
	gint _tmp32_;
	gint _tmp33_;
	gchar* _tmp34_ = NULL;
	gchar* _tmp35_;
	GString* _tmp36_;
	const gchar* _tmp37_;
	gchar* _tmp38_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (midasi != NULL, NULL);
	info = NULL;
	start_pos = 0;
	_tmp0_ = gee_array_list_new (G_TYPE_INT, NULL, NULL, NULL);
	numeric_list = _tmp0_;
	_tmp1_ = g_string_new ("");
	builder = _tmp1_;
	while (TRUE) {
		GMatchInfo* _tmp9_;
		gchar* _tmp10_ = NULL;
		gchar* numeric;
		gint match_start_pos = 0;
		gint match_end_pos = 0;
		GMatchInfo* _tmp11_;
		gint _tmp12_ = 0;
		gint _tmp13_ = 0;
		GeeArrayList* _tmp14_;
		const gchar* _tmp15_;
		gint _tmp16_ = 0;
		GString* _tmp17_;
		const gchar* _tmp18_;
		gint _tmp19_;
		gint _tmp20_;
		gchar* _tmp21_ = NULL;
		gchar* _tmp22_;
		GString* _tmp23_;
		gint _tmp24_;
		{
			GRegex* _tmp2_;
			const gchar* _tmp3_;
			gint _tmp4_;
			GMatchInfo* _tmp5_ = NULL;
			gboolean _tmp6_ = FALSE;
			gboolean _tmp7_;
			_tmp2_ = self->priv->numeric_regex;
			_tmp3_ = midasi;
			_tmp4_ = start_pos;
			_tmp6_ = g_regex_match_full (_tmp2_, _tmp3_, (gssize) (-1), _tmp4_, 0, &_tmp5_, &_inner_error_);
			_g_match_info_free0 (info);
			info = _tmp5_;
			_tmp7_ = _tmp6_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_REGEX_ERROR) {
					goto __catch28_g_regex_error;
				}
				_g_string_free0 (builder);
				_g_object_unref0 (numeric_list);
				_g_match_info_free0 (info);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
			if (!_tmp7_) {
				break;
			}
		}
		goto __finally28;
		__catch28_g_regex_error:
		{
			GError* e = NULL;
			const gchar* _tmp8_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp8_ = midasi;
			g_return_val_if_reached (_tmp8_);
			_g_error_free0 (e);
		}
		__finally28:
		if (_inner_error_ != NULL) {
			_g_string_free0 (builder);
			_g_object_unref0 (numeric_list);
			_g_match_info_free0 (info);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp9_ = info;
		_tmp10_ = g_match_info_fetch (_tmp9_, 0);
		numeric = _tmp10_;
		_tmp11_ = info;
		g_match_info_fetch_pos (_tmp11_, 0, &_tmp12_, &_tmp13_);
		match_start_pos = _tmp12_;
		match_end_pos = _tmp13_;
		_tmp14_ = numeric_list;
		_tmp15_ = numeric;
		_tmp16_ = atoi (_tmp15_);
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp14_, GINT_TO_POINTER (_tmp16_));
		_tmp17_ = builder;
		_tmp18_ = midasi;
		_tmp19_ = start_pos;
		_tmp20_ = match_start_pos;
		_tmp21_ = string_slice (_tmp18_, (glong) _tmp19_, (glong) _tmp20_);
		_tmp22_ = _tmp21_;
		g_string_append (_tmp17_, _tmp22_);
		_g_free0 (_tmp22_);
		_tmp23_ = builder;
		g_string_append (_tmp23_, "#");
		_tmp24_ = match_end_pos;
		start_pos = _tmp24_;
		_g_free0 (numeric);
	}
	_tmp25_ = numeric_list;
	_tmp27_ = gee_abstract_collection_to_array ((GeeAbstractCollection*) _tmp25_, &_tmp26_);
	_vala_numerics = (g_free (_vala_numerics), NULL);
	_vala_numerics = _tmp27_;
	_vala_numerics_length1 = _tmp26_;
	_tmp28_ = builder;
	_tmp29_ = midasi;
	_tmp30_ = start_pos;
	_tmp31_ = midasi;
	_tmp32_ = strlen (_tmp31_);
	_tmp33_ = _tmp32_;
	_tmp34_ = string_slice (_tmp29_, (glong) _tmp30_, (glong) _tmp33_);
	_tmp35_ = _tmp34_;
	g_string_append (_tmp28_, _tmp35_);
	_g_free0 (_tmp35_);
	_tmp36_ = builder;
	_tmp37_ = _tmp36_->str;
	_tmp38_ = g_strdup (_tmp37_);
	result = _tmp38_;
	_g_string_free0 (builder);
	_g_object_unref0 (numeric_list);
	_g_match_info_free0 (info);
	if (numerics) {
		*numerics = _vala_numerics;
	} else {
		_vala_numerics = (g_free (_vala_numerics), NULL);
	}
	if (numerics_length1) {
		*numerics_length1 = _vala_numerics_length1;
	}
	return result;
}


static gchar* skk_state_expand_expr (SkkState* self, const gchar* text) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp11_;
	gchar* _tmp12_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (text != NULL, NULL);
	_tmp0_ = text;
	_tmp1_ = g_str_has_prefix (_tmp0_, "(");
	if (_tmp1_) {
		SkkExprReader* _tmp2_;
		SkkExprReader* reader;
		gint index;
		SkkExprReader* _tmp3_;
		const gchar* _tmp4_;
		SkkExprNode* _tmp5_ = NULL;
		SkkExprNode* node;
		SkkExprEvaluator* _tmp6_;
		SkkExprEvaluator* evaluator;
		SkkExprEvaluator* _tmp7_;
		SkkExprNode* _tmp8_;
		gchar* _tmp9_ = NULL;
		gchar* _text;
		const gchar* _tmp10_;
		_tmp2_ = skk_expr_reader_new ();
		reader = _tmp2_;
		index = 0;
		_tmp3_ = reader;
		_tmp4_ = text;
		_tmp5_ = skk_expr_reader_read_expr (_tmp3_, _tmp4_, &index);
		node = _tmp5_;
		_tmp6_ = skk_expr_evaluator_new ();
		evaluator = _tmp6_;
		_tmp7_ = evaluator;
		_tmp8_ = node;
		_tmp9_ = skk_expr_evaluator_eval (_tmp7_, _tmp8_);
		_text = _tmp9_;
		_tmp10_ = _text;
		if (_tmp10_ != NULL) {
			result = _text;
			_g_object_unref0 (evaluator);
			_skk_expr_node_unref0 (node);
			_g_object_unref0 (reader);
			return result;
		}
		_g_free0 (_text);
		_g_object_unref0 (evaluator);
		_skk_expr_node_unref0 (node);
		_g_object_unref0 (reader);
	}
	_tmp11_ = text;
	_tmp12_ = g_strdup (_tmp11_);
	result = _tmp12_;
	return result;
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_;
	gchar _tmp1_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


static gchar* skk_state_expand_numeric_references (SkkState* self, const gchar* text, gint* numerics, int numerics_length1) {
	gchar* result = NULL;
	GString* _tmp0_;
	GString* builder;
	GMatchInfo* info;
	gint start_pos;
	GString* _tmp35_;
	const gchar* _tmp36_;
	gint _tmp37_;
	const gchar* _tmp38_;
	gint _tmp39_;
	gint _tmp40_;
	gchar* _tmp41_ = NULL;
	gchar* _tmp42_;
	GString* _tmp43_;
	const gchar* _tmp44_;
	gchar* _tmp45_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (text != NULL, NULL);
	_tmp0_ = g_string_new ("");
	builder = _tmp0_;
	info = NULL;
	start_pos = 0;
	{
		gint numeric_index;
		numeric_index = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				gint* _tmp5_;
				gint _tmp5__length1;
				gint match_start_pos = 0;
				gint match_end_pos = 0;
				GMatchInfo* _tmp12_;
				gint _tmp13_ = 0;
				gint _tmp14_ = 0;
				GString* _tmp15_;
				const gchar* _tmp16_;
				gint _tmp17_;
				gint _tmp18_;
				gchar* _tmp19_ = NULL;
				gchar* _tmp20_;
				GMatchInfo* _tmp21_;
				gchar* _tmp22_ = NULL;
				gchar* type;
				const gchar* _tmp23_;
				gchar _tmp24_ = '\0';
				gint _tmp34_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = numeric_index;
					numeric_index = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = numeric_index;
				_tmp5_ = numerics;
				_tmp5__length1 = numerics_length1;
				if (!(_tmp4_ < _tmp5__length1)) {
					break;
				}
				{
					GRegex* _tmp6_;
					const gchar* _tmp7_;
					gint _tmp8_;
					GMatchInfo* _tmp9_ = NULL;
					gboolean _tmp10_ = FALSE;
					gboolean _tmp11_;
					_tmp6_ = self->priv->numeric_ref_regex;
					_tmp7_ = text;
					_tmp8_ = start_pos;
					_tmp10_ = g_regex_match_full (_tmp6_, _tmp7_, (gssize) (-1), _tmp8_, 0, &_tmp9_, &_inner_error_);
					_g_match_info_free0 (info);
					info = _tmp9_;
					_tmp11_ = _tmp10_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == G_REGEX_ERROR) {
							goto __catch29_g_regex_error;
						}
						_g_match_info_free0 (info);
						_g_string_free0 (builder);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
					if (!_tmp11_) {
						break;
					}
				}
				goto __finally29;
				__catch29_g_regex_error:
				{
					GError* e = NULL;
					e = _inner_error_;
					_inner_error_ = NULL;
					g_return_if_reached ();
					_g_error_free0 (e);
				}
				__finally29:
				if (_inner_error_ != NULL) {
					_g_match_info_free0 (info);
					_g_string_free0 (builder);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
				_tmp12_ = info;
				g_match_info_fetch_pos (_tmp12_, 0, &_tmp13_, &_tmp14_);
				match_start_pos = _tmp13_;
				match_end_pos = _tmp14_;
				_tmp15_ = builder;
				_tmp16_ = text;
				_tmp17_ = start_pos;
				_tmp18_ = match_start_pos;
				_tmp19_ = string_slice (_tmp16_, (glong) _tmp17_, (glong) _tmp18_);
				_tmp20_ = _tmp19_;
				g_string_append (_tmp15_, _tmp20_);
				_g_free0 (_tmp20_);
				_tmp21_ = info;
				_tmp22_ = g_match_info_fetch (_tmp21_, 1);
				type = _tmp22_;
				_tmp23_ = type;
				_tmp24_ = string_get (_tmp23_, (glong) 0);
				switch (_tmp24_) {
					case '0':
					case '1':
					case '2':
					case '3':
					case '5':
					{
						GString* _tmp25_;
						gint* _tmp26_;
						gint _tmp26__length1;
						gint _tmp27_;
						gint _tmp28_;
						const gchar* _tmp29_;
						gchar _tmp30_ = '\0';
						gchar* _tmp31_ = NULL;
						gchar* _tmp32_;
						_tmp25_ = builder;
						_tmp26_ = numerics;
						_tmp26__length1 = numerics_length1;
						_tmp27_ = numeric_index;
						_tmp28_ = _tmp26_[_tmp27_];
						_tmp29_ = type;
						_tmp30_ = string_get (_tmp29_, (glong) 0);
						_tmp31_ = skk_util_get_numeric (_tmp28_, (SkkNumericConversionType) (_tmp30_ - '0'));
						_tmp32_ = _tmp31_;
						g_string_append (_tmp25_, _tmp32_);
						_g_free0 (_tmp32_);
						break;
					}
					case '4':
					case '9':
					{
						break;
					}
					default:
					{
						const gchar* _tmp33_;
						_tmp33_ = type;
						g_warning ("state.vala:285: unknown numeric conversion type: %s", _tmp33_);
						break;
					}
				}
				_tmp34_ = match_end_pos;
				start_pos = _tmp34_;
				_g_free0 (type);
			}
		}
	}
	_tmp35_ = builder;
	_tmp36_ = text;
	_tmp37_ = start_pos;
	_tmp38_ = text;
	_tmp39_ = strlen (_tmp38_);
	_tmp40_ = _tmp39_;
	_tmp41_ = string_slice (_tmp36_, (glong) _tmp37_, (glong) _tmp40_);
	_tmp42_ = _tmp41_;
	g_string_append (_tmp35_, _tmp42_);
	_g_free0 (_tmp42_);
	_tmp43_ = builder;
	_tmp44_ = _tmp43_->str;
	_tmp45_ = g_strdup (_tmp44_);
	result = _tmp45_;
	_g_match_info_free0 (info);
	_g_string_free0 (builder);
	return result;
}


void skk_state_lookup (SkkState* self, const gchar* midasi, gboolean okuri) {
	SkkCandidateList* _tmp0_;
	SkkCandidateList* _tmp1_;
	gint* _tmp2_ = NULL;
	gint* numerics;
	gint numerics_length1;
	gint _numerics_size_;
	const gchar* _tmp3_;
	gint* _tmp4_;
	gint _tmp4__length1;
	gboolean _tmp5_;
	const gchar* _tmp6_;
	gint* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	gchar* _tmp9_ = NULL;
	gchar* numeric_midasi;
	gint* _tmp10_;
	gint _tmp10__length1;
	gboolean _tmp11_;
	SkkCandidateList* _tmp12_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (midasi != NULL);
	_tmp0_ = self->candidates;
	skk_candidate_list_clear (_tmp0_);
	_tmp1_ = self->candidates;
	skk_candidate_list_add_candidates_start (_tmp1_);
	_tmp2_ = g_new0 (gint, 0);
	numerics = _tmp2_;
	numerics_length1 = 0;
	_numerics_size_ = numerics_length1;
	_tmp3_ = midasi;
	_tmp4_ = numerics;
	_tmp4__length1 = numerics_length1;
	_tmp5_ = okuri;
	skk_state_lookup_internal (self, _tmp3_, _tmp4_, _tmp4__length1, _tmp5_);
	_tmp6_ = midasi;
	_tmp9_ = skk_state_extract_numerics (self, _tmp6_, &_tmp7_, &_tmp8_);
	numerics = (g_free (numerics), NULL);
	numerics = _tmp7_;
	numerics_length1 = _tmp8_;
	_numerics_size_ = numerics_length1;
	numeric_midasi = _tmp9_;
	_tmp10_ = numerics;
	_tmp10__length1 = numerics_length1;
	_tmp11_ = okuri;
	skk_state_lookup_internal (self, numeric_midasi, _tmp10_, _tmp10__length1, _tmp11_);
	_tmp12_ = self->candidates;
	skk_candidate_list_add_candidates_end (_tmp12_);
	_g_free0 (numeric_midasi);
	numerics = (g_free (numerics), NULL);
}


static void skk_state_lookup_internal (SkkState* self, const gchar* midasi, gint* numerics, int numerics_length1, gboolean okuri) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (midasi != NULL);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _tmp1_;
		GeeArrayList* _dict_list;
		GeeArrayList* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		gint _dict_size;
		gint _dict_index;
		_tmp0_ = self->dictionaries;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_dict_list = _tmp1_;
		_tmp2_ = _dict_list;
		_tmp3_ = gee_collection_get_size ((GeeCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_dict_size = _tmp4_;
		_dict_index = -1;
		while (TRUE) {
			gint _tmp5_;
			gint _tmp6_;
			gint _tmp7_;
			GeeArrayList* _tmp8_;
			gint _tmp9_;
			gpointer _tmp10_ = NULL;
			SkkDict* dict;
			SkkDict* _tmp11_;
			const gchar* _tmp12_;
			gboolean _tmp13_;
			gint _tmp14_ = 0;
			SkkCandidate** _tmp15_ = NULL;
			SkkCandidate** _candidates;
			gint _candidates_length1;
			gint __candidates_size_;
			SkkCandidate** _tmp16_;
			gint _tmp16__length1;
			SkkCandidateList* _tmp38_;
			SkkCandidate** _tmp39_;
			gint _tmp39__length1;
			_tmp5_ = _dict_index;
			_dict_index = _tmp5_ + 1;
			_tmp6_ = _dict_index;
			_tmp7_ = _dict_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _dict_list;
			_tmp9_ = _dict_index;
			_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _tmp9_);
			dict = (SkkDict*) _tmp10_;
			_tmp11_ = dict;
			_tmp12_ = midasi;
			_tmp13_ = okuri;
			_tmp15_ = skk_dict_lookup (_tmp11_, _tmp12_, _tmp13_, &_tmp14_);
			_candidates = _tmp15_;
			_candidates_length1 = _tmp14_;
			__candidates_size_ = _candidates_length1;
			_tmp16_ = _candidates;
			_tmp16__length1 = _candidates_length1;
			{
				SkkCandidate** candidate_collection = NULL;
				gint candidate_collection_length1 = 0;
				gint _candidate_collection_size_ = 0;
				gint candidate_it = 0;
				candidate_collection = _tmp16_;
				candidate_collection_length1 = _tmp16__length1;
				for (candidate_it = 0; candidate_it < _tmp16__length1; candidate_it = candidate_it + 1) {
					SkkCandidate* _tmp17_;
					SkkCandidate* candidate = NULL;
					_tmp17_ = _g_object_ref0 (candidate_collection[candidate_it]);
					candidate = _tmp17_;
					{
						SkkCandidate* _tmp18_;
						const gchar* _tmp19_;
						const gchar* _tmp20_;
						gchar* _tmp21_;
						gchar* text;
						const gchar* _tmp22_;
						gchar* _tmp23_ = NULL;
						const gchar* _tmp24_;
						gint* _tmp25_;
						gint _tmp25__length1;
						gchar* _tmp26_ = NULL;
						SkkCandidate* _tmp27_;
						const gchar* _tmp28_;
						SkkCandidate* _tmp29_;
						const gchar* _tmp30_;
						const gchar* _tmp31_;
						_tmp18_ = candidate;
						_tmp19_ = skk_candidate_get_text (_tmp18_);
						_tmp20_ = _tmp19_;
						_tmp21_ = g_strdup (_tmp20_);
						text = _tmp21_;
						_tmp22_ = text;
						_tmp23_ = skk_state_expand_expr (self, _tmp22_);
						_g_free0 (text);
						text = _tmp23_;
						_tmp24_ = text;
						_tmp25_ = numerics;
						_tmp25__length1 = numerics_length1;
						_tmp26_ = skk_state_expand_numeric_references (self, _tmp24_, _tmp25_, _tmp25__length1);
						_g_free0 (text);
						text = _tmp26_;
						_tmp27_ = candidate;
						_tmp28_ = text;
						skk_candidate_set_output (_tmp27_, _tmp28_);
						_tmp29_ = candidate;
						_tmp30_ = skk_candidate_get_annotation (_tmp29_);
						_tmp31_ = _tmp30_;
						if (_tmp31_ != NULL) {
							SkkCandidate* _tmp32_;
							SkkCandidate* _tmp33_;
							const gchar* _tmp34_;
							const gchar* _tmp35_;
							gchar* _tmp36_ = NULL;
							gchar* _tmp37_;
							_tmp32_ = candidate;
							_tmp33_ = candidate;
							_tmp34_ = skk_candidate_get_annotation (_tmp33_);
							_tmp35_ = _tmp34_;
							_tmp36_ = skk_state_expand_expr (self, _tmp35_);
							_tmp37_ = _tmp36_;
							skk_candidate_set_annotation (_tmp32_, _tmp37_);
							_g_free0 (_tmp37_);
						}
						_g_free0 (text);
						_g_object_unref0 (candidate);
					}
				}
			}
			_tmp38_ = self->candidates;
			_tmp39_ = _candidates;
			_tmp39__length1 = _candidates_length1;
			skk_candidate_list_add_candidates (_tmp38_, _tmp39_, _tmp39__length1);
			_candidates = (_vala_array_free (_candidates, _candidates_length1, (GDestroyNotify) g_object_unref), NULL);
			_g_object_unref0 (dict);
		}
		_g_object_unref0 (_dict_list);
	}
}


void skk_state_purge_candidate (SkkState* self, SkkCandidate* candidate) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (candidate != NULL);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _tmp1_;
		GeeArrayList* _dict_list;
		GeeArrayList* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		gint _dict_size;
		gint _dict_index;
		_tmp0_ = self->dictionaries;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_dict_list = _tmp1_;
		_tmp2_ = _dict_list;
		_tmp3_ = gee_collection_get_size ((GeeCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_dict_size = _tmp4_;
		_dict_index = -1;
		while (TRUE) {
			gint _tmp5_;
			gint _tmp6_;
			gint _tmp7_;
			GeeArrayList* _tmp8_;
			gint _tmp9_;
			gpointer _tmp10_ = NULL;
			SkkDict* dict;
			SkkDict* _tmp11_;
			gboolean _tmp12_;
			gboolean _tmp13_;
			_tmp5_ = _dict_index;
			_dict_index = _tmp5_ + 1;
			_tmp6_ = _dict_index;
			_tmp7_ = _dict_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _dict_list;
			_tmp9_ = _dict_index;
			_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _tmp9_);
			dict = (SkkDict*) _tmp10_;
			_tmp11_ = dict;
			_tmp12_ = skk_dict_get_read_only (_tmp11_);
			_tmp13_ = _tmp12_;
			if (!_tmp13_) {
				SkkDict* _tmp14_;
				SkkCandidate* _tmp15_;
				_tmp14_ = dict;
				_tmp15_ = candidate;
				skk_dict_purge_candidate (_tmp14_, _tmp15_);
			}
			_g_object_unref0 (dict);
		}
		_g_object_unref0 (_dict_list);
	}
}


void skk_state_completion_start (SkkState* self, const gchar* midasi) {
	GeeArrayList* _tmp20_;
	GeeIterator* _tmp21_ = NULL;
	GeeIterator* _tmp22_;
	gboolean _tmp23_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (midasi != NULL);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _tmp1_;
		GeeArrayList* _dict_list;
		GeeArrayList* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		gint _dict_size;
		gint _dict_index;
		_tmp0_ = self->dictionaries;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_dict_list = _tmp1_;
		_tmp2_ = _dict_list;
		_tmp3_ = gee_collection_get_size ((GeeCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_dict_size = _tmp4_;
		_dict_index = -1;
		while (TRUE) {
			gint _tmp5_;
			gint _tmp6_;
			gint _tmp7_;
			GeeArrayList* _tmp8_;
			gint _tmp9_;
			gpointer _tmp10_ = NULL;
			SkkDict* dict;
			SkkDict* _tmp11_;
			const gchar* _tmp12_;
			gint _tmp13_ = 0;
			gchar** _tmp14_ = NULL;
			gchar** _completion;
			gint _completion_length1;
			gint __completion_size_;
			gchar** _tmp15_;
			gint _tmp15__length1;
			GeeArrayList* _tmp19_;
			_tmp5_ = _dict_index;
			_dict_index = _tmp5_ + 1;
			_tmp6_ = _dict_index;
			_tmp7_ = _dict_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _dict_list;
			_tmp9_ = _dict_index;
			_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _tmp9_);
			dict = (SkkDict*) _tmp10_;
			_tmp11_ = dict;
			_tmp12_ = midasi;
			_tmp14_ = skk_dict_complete (_tmp11_, _tmp12_, &_tmp13_);
			_completion = _tmp14_;
			_completion_length1 = _tmp13_;
			__completion_size_ = _completion_length1;
			_tmp15_ = _completion;
			_tmp15__length1 = _completion_length1;
			{
				gchar** word_collection = NULL;
				gint word_collection_length1 = 0;
				gint _word_collection_size_ = 0;
				gint word_it = 0;
				word_collection = _tmp15_;
				word_collection_length1 = _tmp15__length1;
				for (word_it = 0; word_it < _tmp15__length1; word_it = word_it + 1) {
					gchar* _tmp16_;
					gchar* word = NULL;
					_tmp16_ = g_strdup (word_collection[word_it]);
					word = _tmp16_;
					{
						GeeArrayList* _tmp17_;
						const gchar* _tmp18_;
						_tmp17_ = self->priv->completion;
						_tmp18_ = word;
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp17_, _tmp18_);
						_g_free0 (word);
					}
				}
			}
			_tmp19_ = self->priv->completion;
			gee_list_sort ((GeeList*) _tmp19_, NULL);
			_completion = (_vala_array_free (_completion, _completion_length1, (GDestroyNotify) g_free), NULL);
			_g_object_unref0 (dict);
		}
		_g_object_unref0 (_dict_list);
	}
	_tmp20_ = self->priv->completion;
	_tmp21_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp20_);
	_g_object_unref0 (self->completion_iterator);
	self->completion_iterator = _tmp21_;
	_tmp22_ = self->completion_iterator;
	_tmp23_ = gee_iterator_first (_tmp22_);
	if (!_tmp23_) {
		_g_object_unref0 (self->completion_iterator);
		self->completion_iterator = NULL;
	}
}


gchar* skk_state_get_yomi (SkkState* self) {
	gchar* result = NULL;
	GString* _tmp0_;
	GString* builder;
	GString* _tmp1_;
	gssize _tmp2_;
	GString* _tmp28_;
	const gchar* _tmp29_;
	gchar* _tmp30_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_string_new ("");
	builder = _tmp0_;
	_tmp1_ = self->abbrev;
	_tmp2_ = _tmp1_->len;
	if (_tmp2_ > ((gssize) 0)) {
		GString* _tmp3_;
		GString* _tmp4_;
		const gchar* _tmp5_;
		_tmp3_ = builder;
		_tmp4_ = self->abbrev;
		_tmp5_ = _tmp4_->str;
		g_string_append (_tmp3_, _tmp5_);
	} else {
		gboolean _tmp6_;
		_tmp6_ = self->okuri;
		if (_tmp6_) {
			GString* _tmp7_;
			SkkRomKanaConverter* _tmp8_;
			const gchar* _tmp9_;
			const gchar* _tmp10_;
			GString* _tmp11_;
			GString* _tmp12_;
			SkkRomKanaConverter* _tmp13_;
			const gchar* _tmp14_;
			const gchar* _tmp15_;
			GString* _tmp16_;
			SkkRomKanaConverter* _tmp17_;
			const gchar* _tmp18_;
			const gchar* _tmp19_;
			_tmp7_ = builder;
			_tmp8_ = self->rom_kana_converter;
			_tmp9_ = skk_rom_kana_converter_get_output (_tmp8_);
			_tmp10_ = _tmp9_;
			g_string_append (_tmp7_, _tmp10_);
			_tmp11_ = builder;
			g_string_append (_tmp11_, "*");
			_tmp12_ = builder;
			_tmp13_ = self->okuri_rom_kana_converter;
			_tmp14_ = skk_rom_kana_converter_get_output (_tmp13_);
			_tmp15_ = _tmp14_;
			g_string_append (_tmp12_, _tmp15_);
			_tmp16_ = builder;
			_tmp17_ = self->okuri_rom_kana_converter;
			_tmp18_ = skk_rom_kana_converter_get_preedit (_tmp17_);
			_tmp19_ = _tmp18_;
			g_string_append (_tmp16_, _tmp19_);
		} else {
			GString* _tmp20_;
			SkkRomKanaConverter* _tmp21_;
			const gchar* _tmp22_;
			const gchar* _tmp23_;
			GString* _tmp24_;
			SkkRomKanaConverter* _tmp25_;
			const gchar* _tmp26_;
			const gchar* _tmp27_;
			_tmp20_ = builder;
			_tmp21_ = self->rom_kana_converter;
			_tmp22_ = skk_rom_kana_converter_get_output (_tmp21_);
			_tmp23_ = _tmp22_;
			g_string_append (_tmp20_, _tmp23_);
			_tmp24_ = builder;
			_tmp25_ = self->rom_kana_converter;
			_tmp26_ = skk_rom_kana_converter_get_preedit (_tmp25_);
			_tmp27_ = _tmp26_;
			g_string_append (_tmp24_, _tmp27_);
		}
	}
	_tmp28_ = builder;
	_tmp29_ = _tmp28_->str;
	_tmp30_ = g_strdup (_tmp29_);
	result = _tmp30_;
	_g_string_free0 (builder);
	return result;
}


SkkInputMode skk_state_get_input_mode (SkkState* self) {
	SkkInputMode result;
	SkkInputMode _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_input_mode;
	result = _tmp0_;
	return result;
}


void skk_state_set_input_mode (SkkState* self, SkkInputMode value) {
	GString* _tmp0_;
	SkkRomKanaConverter* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	SkkInputMode _tmp4_;
	SkkInputMode last_input_mode;
	SkkInputMode _tmp5_;
	SkkInputMode _tmp6_;
	SkkInputMode _tmp11_;
	SkkInputMode _tmp12_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->output;
	_tmp1_ = self->rom_kana_converter;
	_tmp2_ = skk_rom_kana_converter_get_output (_tmp1_);
	_tmp3_ = _tmp2_;
	g_string_append (_tmp0_, _tmp3_);
	_tmp4_ = self->priv->_input_mode;
	last_input_mode = _tmp4_;
	skk_state_reset (self);
	_tmp5_ = value;
	self->priv->_input_mode = _tmp5_;
	_tmp6_ = self->priv->_input_mode;
	switch (_tmp6_) {
		case SKK_INPUT_MODE_HIRAGANA:
		case SKK_INPUT_MODE_KATAKANA:
		case SKK_INPUT_MODE_HANKAKU_KATAKANA:
		{
			SkkRomKanaConverter* _tmp7_;
			SkkInputMode _tmp8_;
			SkkRomKanaConverter* _tmp9_;
			SkkInputMode _tmp10_;
			_tmp7_ = self->rom_kana_converter;
			_tmp8_ = value;
			skk_rom_kana_converter_set_kana_mode (_tmp7_, (SkkKanaMode) _tmp8_);
			_tmp9_ = self->okuri_rom_kana_converter;
			_tmp10_ = value;
			skk_rom_kana_converter_set_kana_mode (_tmp9_, (SkkKanaMode) _tmp10_);
			break;
		}
		default:
		{
			break;
		}
	}
	_tmp11_ = self->priv->_input_mode;
	_tmp12_ = last_input_mode;
	if (_tmp11_ != _tmp12_) {
		g_object_notify ((GObject*) self, "input-mode");
	}
}


SkkPeriodStyle skk_state_get_period_style (SkkState* self) {
	SkkPeriodStyle result;
	SkkRomKanaConverter* _tmp0_;
	SkkPeriodStyle _tmp1_;
	SkkPeriodStyle _tmp2_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->rom_kana_converter;
	_tmp1_ = skk_rom_kana_converter_get_period_style (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


void skk_state_set_period_style (SkkState* self, SkkPeriodStyle value) {
	SkkRomKanaConverter* _tmp0_;
	SkkPeriodStyle _tmp1_;
	SkkRomKanaConverter* _tmp2_;
	SkkPeriodStyle _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->rom_kana_converter;
	_tmp1_ = value;
	skk_rom_kana_converter_set_period_style (_tmp0_, _tmp1_);
	_tmp2_ = self->okuri_rom_kana_converter;
	_tmp3_ = value;
	skk_rom_kana_converter_set_period_style (_tmp2_, _tmp3_);
	g_object_notify ((GObject *) self, "period-style");
}


SkkRule* skk_state_get_typing_rule (SkkState* self) {
	SkkRule* result;
	SkkRule* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_typing_rule;
	result = _tmp0_;
	return result;
}


void skk_state_set_typing_rule (SkkState* self, SkkRule* value) {
	SkkRule* _tmp0_;
	SkkRule* _tmp1_;
	SkkRomKanaConverter* _tmp2_;
	SkkRule* _tmp3_;
	SkkRomKanaMapFile* _tmp4_;
	SkkRomKanaConverter* _tmp5_;
	SkkRule* _tmp6_;
	SkkRomKanaMapFile* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_typing_rule);
	self->priv->_typing_rule = _tmp1_;
	_tmp2_ = self->rom_kana_converter;
	_tmp3_ = self->priv->_typing_rule;
	_tmp4_ = _tmp3_->rom_kana;
	skk_rom_kana_converter_set_rule (_tmp2_, _tmp4_);
	_tmp5_ = self->okuri_rom_kana_converter;
	_tmp6_ = self->priv->_typing_rule;
	_tmp7_ = _tmp6_->rom_kana;
	skk_rom_kana_converter_set_rule (_tmp5_, _tmp7_);
	g_object_notify ((GObject *) self, "typing-rule");
}


static void g_cclosure_user_marshal_BOOLEAN__VOID (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef gboolean (*GMarshalFunc_BOOLEAN__VOID) (gpointer data1, gpointer data2);
	register GMarshalFunc_BOOLEAN__VOID callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	gboolean v_return;
	cc = (GCClosure *) closure;
	g_return_if_fail (return_value != NULL);
	g_return_if_fail (n_param_values == 1);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_BOOLEAN__VOID) (marshal_data ? marshal_data : cc->callback);
	v_return = callback (data1, data2);
	g_value_set_boolean (return_value, v_return);
}


static void g_cclosure_user_marshal_BOOLEAN__STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef gboolean (*GMarshalFunc_BOOLEAN__STRING) (gpointer data1, const char* arg_1, gpointer data2);
	register GMarshalFunc_BOOLEAN__STRING callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	gboolean v_return;
	cc = (GCClosure *) closure;
	g_return_if_fail (return_value != NULL);
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_BOOLEAN__STRING) (marshal_data ? marshal_data : cc->callback);
	v_return = callback (data1, g_value_get_string (param_values + 1), data2);
	g_value_set_boolean (return_value, v_return);
}


static void g_cclosure_user_marshal_VOID__STRING_BOOLEAN (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_BOOLEAN) (gpointer data1, const char* arg_1, gboolean arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_BOOLEAN callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_BOOLEAN) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_boolean (param_values + 2), data2);
}


static void g_cclosure_user_marshal_BOOLEAN__POINTER_POINTER (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef gboolean (*GMarshalFunc_BOOLEAN__POINTER_POINTER) (gpointer data1, gpointer arg_1, gpointer arg_2, gpointer data2);
	register GMarshalFunc_BOOLEAN__POINTER_POINTER callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	gboolean v_return;
	cc = (GCClosure *) closure;
	g_return_if_fail (return_value != NULL);
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_BOOLEAN__POINTER_POINTER) (marshal_data ? marshal_data : cc->callback);
	v_return = callback (data1, g_value_get_pointer (param_values + 1), g_value_get_pointer (param_values + 2), data2);
	g_value_set_boolean (return_value, v_return);
}


static void g_cclosure_user_marshal_BOOLEAN__INT_UINT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef gboolean (*GMarshalFunc_BOOLEAN__INT_UINT) (gpointer data1, gint arg_1, guint arg_2, gpointer data2);
	register GMarshalFunc_BOOLEAN__INT_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	gboolean v_return;
	cc = (GCClosure *) closure;
	g_return_if_fail (return_value != NULL);
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_BOOLEAN__INT_UINT) (marshal_data ? marshal_data : cc->callback);
	v_return = callback (data1, g_value_get_int (param_values + 1), g_value_get_uint (param_values + 2), data2);
	g_value_set_boolean (return_value, v_return);
}


static void skk_state_class_init (SkkStateClass * klass) {
	skk_state_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SkkStatePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_skk_state_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_skk_state_set_property;
	G_OBJECT_CLASS (klass)->finalize = skk_state_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_STATE_INPUT_MODE, g_param_spec_enum ("input-mode", "input-mode", "input-mode", SKK_TYPE_INPUT_MODE, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_STATE_PERIOD_STYLE, g_param_spec_enum ("period-style", "period-style", "period-style", SKK_TYPE_PERIOD_STYLE, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SKK_STATE_TYPING_RULE, g_param_spec_object ("typing-rule", "typing-rule", "typing-rule", SKK_TYPE_RULE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_signal_new ("recursive_edit_abort", SKK_TYPE_STATE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_BOOLEAN__VOID, G_TYPE_BOOLEAN, 0);
	g_signal_new ("recursive_edit_end", SKK_TYPE_STATE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_BOOLEAN__STRING, G_TYPE_BOOLEAN, 1, G_TYPE_STRING);
	g_signal_new ("recursive_edit_start", SKK_TYPE_STATE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_BOOLEAN, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_BOOLEAN);
	g_signal_new ("retrieve_surrounding_text", SKK_TYPE_STATE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_BOOLEAN__POINTER_POINTER, G_TYPE_BOOLEAN, 2, G_TYPE_POINTER, G_TYPE_POINTER);
	g_signal_new ("delete_surrounding_text", SKK_TYPE_STATE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_BOOLEAN__INT_UINT, G_TYPE_BOOLEAN, 2, G_TYPE_INT, G_TYPE_UINT);
}


static void skk_state_instance_init (SkkState * self) {
	GString* _tmp0_;
	GString* _tmp1_;
	GString* _tmp2_;
	GeeArrayList* _tmp3_;
	self->priv = SKK_STATE_GET_PRIVATE (self);
	_tmp0_ = g_string_new ("");
	self->output = _tmp0_;
	_tmp1_ = g_string_new ("");
	self->abbrev = _tmp1_;
	_tmp2_ = g_string_new ("");
	self->kuten = _tmp2_;
	_tmp3_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	self->priv->completion = _tmp3_;
	self->auto_start_henkan_keyword = NULL;
	self->egg_like_newline = FALSE;
}


static void skk_state_finalize (GObject* obj) {
	SkkState * self;
	self = SKK_STATE (obj);
	skk_state_reset (self);
	_g_object_unref0 (self->dictionaries);
	_g_object_unref0 (self->candidates);
	_g_object_unref0 (self->rom_kana_converter);
	_g_object_unref0 (self->okuri_rom_kana_converter);
	_g_free0 (self->midasi);
	_g_string_free0 (self->output);
	_g_string_free0 (self->abbrev);
	_g_string_free0 (self->kuten);
	_g_object_unref0 (self->priv->completion);
	_g_object_unref0 (self->completion_iterator);
	self->auto_start_henkan_keywords = (_vala_array_free (self->auto_start_henkan_keywords, self->auto_start_henkan_keywords_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (self->auto_start_henkan_keyword);
	_g_object_unref0 (self->priv->_typing_rule);
	_g_regex_unref0 (self->priv->numeric_regex);
	_g_regex_unref0 (self->priv->numeric_ref_regex);
	_g_object_unref0 (self->surrounding_text);
	G_OBJECT_CLASS (skk_state_parent_class)->finalize (obj);
}


GType skk_state_get_type (void) {
	static volatile gsize skk_state_type_id__volatile = 0;
	if (g_once_init_enter (&skk_state_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SkkStateClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) skk_state_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SkkState), 0, (GInstanceInitFunc) skk_state_instance_init, NULL };
		GType skk_state_type_id;
		skk_state_type_id = g_type_register_static (G_TYPE_OBJECT, "SkkState", &g_define_type_info, 0);
		g_once_init_leave (&skk_state_type_id__volatile, skk_state_type_id);
	}
	return skk_state_type_id__volatile;
}


static void _vala_skk_state_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SkkState * self;
	self = SKK_STATE (object);
	switch (property_id) {
		case SKK_STATE_INPUT_MODE:
		g_value_set_enum (value, skk_state_get_input_mode (self));
		break;
		case SKK_STATE_PERIOD_STYLE:
		g_value_set_enum (value, skk_state_get_period_style (self));
		break;
		case SKK_STATE_TYPING_RULE:
		g_value_set_object (value, skk_state_get_typing_rule (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_skk_state_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SkkState * self;
	self = SKK_STATE (object);
	switch (property_id) {
		case SKK_STATE_INPUT_MODE:
		skk_state_set_input_mode (self, g_value_get_enum (value));
		break;
		case SKK_STATE_PERIOD_STYLE:
		skk_state_set_period_style (self, g_value_get_enum (value));
		break;
		case SKK_STATE_TYPING_RULE:
		skk_state_set_typing_rule (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static gboolean skk_state_handler_real_process_key_event (SkkStateHandler* self, SkkState* state, SkkKeyEvent** key) {
	g_critical ("Type `%s' does not implement abstract method `skk_state_handler_process_key_event'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return FALSE;
}


gboolean skk_state_handler_process_key_event (SkkStateHandler* self, SkkState* state, SkkKeyEvent** key) {
	g_return_val_if_fail (self != NULL, FALSE);
	return SKK_STATE_HANDLER_GET_CLASS (self)->process_key_event (self, state, key);
}


static gchar* skk_state_handler_real_get_preedit (SkkStateHandler* self, SkkState* state, guint* underline_offset, guint* underline_nchars) {
	g_critical ("Type `%s' does not implement abstract method `skk_state_handler_get_preedit'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


gchar* skk_state_handler_get_preedit (SkkStateHandler* self, SkkState* state, guint* underline_offset, guint* underline_nchars) {
	g_return_val_if_fail (self != NULL, NULL);
	return SKK_STATE_HANDLER_GET_CLASS (self)->get_preedit (self, state, underline_offset, underline_nchars);
}


static gchar* skk_state_handler_real_get_output (SkkStateHandler* self, SkkState* state) {
	gchar* result = NULL;
	SkkState* _tmp0_;
	GString* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	g_return_val_if_fail (state != NULL, NULL);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->output;
	_tmp2_ = _tmp1_->str;
	_tmp3_ = g_strdup (_tmp2_);
	result = _tmp3_;
	return result;
}


gchar* skk_state_handler_get_output (SkkStateHandler* self, SkkState* state) {
	g_return_val_if_fail (self != NULL, NULL);
	return SKK_STATE_HANDLER_GET_CLASS (self)->get_output (self, state);
}


SkkStateHandler* skk_state_handler_construct (GType object_type) {
	SkkStateHandler * self = NULL;
	self = (SkkStateHandler*) g_object_new (object_type, NULL);
	return self;
}


static void skk_state_handler_class_init (SkkStateHandlerClass * klass) {
	skk_state_handler_parent_class = g_type_class_peek_parent (klass);
	SKK_STATE_HANDLER_CLASS (klass)->process_key_event = skk_state_handler_real_process_key_event;
	SKK_STATE_HANDLER_CLASS (klass)->get_preedit = skk_state_handler_real_get_preedit;
	SKK_STATE_HANDLER_CLASS (klass)->get_output = skk_state_handler_real_get_output;
}


static void skk_state_handler_instance_init (SkkStateHandler * self) {
}


GType skk_state_handler_get_type (void) {
	static volatile gsize skk_state_handler_type_id__volatile = 0;
	if (g_once_init_enter (&skk_state_handler_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SkkStateHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) skk_state_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SkkStateHandler), 0, (GInstanceInitFunc) skk_state_handler_instance_init, NULL };
		GType skk_state_handler_type_id;
		skk_state_handler_type_id = g_type_register_static (G_TYPE_OBJECT, "SkkStateHandler", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&skk_state_handler_type_id__volatile, skk_state_handler_type_id);
	}
	return skk_state_handler_type_id__volatile;
}


static gint string_index_of_nth_char (const gchar* self, glong c) {
	gint result = 0;
	glong _tmp0_;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = c;
	_tmp1_ = g_utf8_offset_to_pointer (self, _tmp0_);
	result = (gint) (_tmp1_ - ((gchar*) self));
	return result;
}


static gboolean skk_none_state_handler_real_process_key_event (SkkStateHandler* base, SkkState* state, SkkKeyEvent** key) {
	SkkNoneStateHandler * self;
	gboolean result = FALSE;
	SkkState* _tmp0_;
	SkkKeyEvent* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* command;
	const gchar* _tmp3_;
	gboolean _tmp62_ = FALSE;
	gboolean _tmp63_ = FALSE;
	const gchar* _tmp64_;
	gboolean _tmp67_;
	gboolean _tmp94_;
	const gchar* _tmp101_;
	SkkState* _tmp118_;
	SkkInputMode _tmp119_;
	SkkInputMode _tmp120_;
	self = (SkkNoneStateHandler*) base;
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = *key;
	_tmp2_ = skk_state_lookup_key (_tmp0_, _tmp1_);
	command = _tmp2_;
	_tmp3_ = command;
	if (g_strcmp0 (_tmp3_, "abort") == 0) {
		gboolean retval = FALSE;
		SkkState* _tmp4_;
		SkkRomKanaConverter* _tmp5_;
		const gchar* _tmp6_;
		const gchar* _tmp7_;
		gint _tmp8_;
		gint _tmp9_;
		SkkState* _tmp12_;
		_tmp4_ = state;
		_tmp5_ = _tmp4_->rom_kana_converter;
		_tmp6_ = skk_rom_kana_converter_get_preedit (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp8_ = strlen (_tmp7_);
		_tmp9_ = _tmp8_;
		if (_tmp9_ > 0) {
			retval = TRUE;
		} else {
			SkkState* _tmp10_;
			gboolean _tmp11_ = FALSE;
			_tmp10_ = state;
			g_signal_emit_by_name (_tmp10_, "recursive-edit-abort", &_tmp11_);
			retval = _tmp11_;
		}
		_tmp12_ = state;
		skk_state_reset (_tmp12_);
		result = retval;
		_g_free0 (command);
		return result;
	} else {
		gboolean _tmp13_ = FALSE;
		const gchar* _tmp14_;
		gboolean _tmp16_;
		_tmp14_ = command;
		if (g_strcmp0 (_tmp14_, "commit") == 0) {
			_tmp13_ = TRUE;
		} else {
			const gchar* _tmp15_;
			_tmp15_ = command;
			_tmp13_ = g_strcmp0 (_tmp15_, "commit-unhandled") == 0;
		}
		_tmp16_ = _tmp13_;
		if (_tmp16_) {
			gboolean retval = FALSE;
			SkkState* _tmp17_;
			SkkRomKanaConverter* _tmp18_;
			const gchar* _tmp19_;
			const gchar* _tmp20_;
			gint _tmp21_;
			gint _tmp22_;
			SkkState* _tmp35_;
			_tmp17_ = state;
			_tmp18_ = _tmp17_->rom_kana_converter;
			_tmp19_ = skk_rom_kana_converter_get_preedit (_tmp18_);
			_tmp20_ = _tmp19_;
			_tmp21_ = strlen (_tmp20_);
			_tmp22_ = _tmp21_;
			if (_tmp22_ > 0) {
				retval = TRUE;
			} else {
				SkkState* _tmp23_;
				GString* _tmp24_;
				const gchar* _tmp25_;
				gint _tmp26_;
				gint _tmp27_;
				_tmp23_ = state;
				_tmp24_ = _tmp23_->output;
				_tmp25_ = _tmp24_->str;
				_tmp26_ = strlen (_tmp25_);
				_tmp27_ = _tmp26_;
				if (_tmp27_ == 0) {
					SkkState* _tmp28_;
					gboolean _tmp29_ = FALSE;
					_tmp28_ = state;
					g_signal_emit_by_name (_tmp28_, "recursive-edit-abort", &_tmp29_);
					retval = _tmp29_;
				} else {
					SkkState* _tmp30_;
					SkkState* _tmp31_;
					GString* _tmp32_;
					const gchar* _tmp33_;
					gboolean _tmp34_ = FALSE;
					_tmp30_ = state;
					_tmp31_ = state;
					_tmp32_ = _tmp31_->output;
					_tmp33_ = _tmp32_->str;
					g_signal_emit_by_name (_tmp30_, "recursive-edit-end", _tmp33_, &_tmp34_);
					retval = _tmp34_;
				}
			}
			_tmp35_ = state;
			skk_state_reset (_tmp35_);
			result = retval;
			_g_free0 (command);
			return result;
		} else {
			gboolean _tmp36_ = FALSE;
			const gchar* _tmp37_;
			gboolean _tmp39_;
			_tmp37_ = command;
			if (g_strcmp0 (_tmp37_, "start-preedit") == 0) {
				_tmp36_ = TRUE;
			} else {
				const gchar* _tmp38_;
				_tmp38_ = command;
				_tmp36_ = g_strcmp0 (_tmp38_, "start-preedit-kana") == 0;
			}
			_tmp39_ = _tmp36_;
			if (_tmp39_) {
				gchar* text = NULL;
				guint cursor_pos = 0U;
				SkkState* _tmp40_;
				gchar* _tmp41_ = NULL;
				guint _tmp42_ = 0U;
				gboolean _tmp43_ = FALSE;
				SkkState* _tmp61_;
				_tmp40_ = state;
				g_signal_emit_by_name (_tmp40_, "retrieve-surrounding-text", &_tmp41_, &_tmp42_, &_tmp43_);
				_g_free0 (text);
				text = _tmp41_;
				cursor_pos = _tmp42_;
				if (_tmp43_) {
					SkkState* _tmp44_;
					const gchar* _tmp45_;
					const gchar* _tmp46_;
					guint _tmp47_;
					gint _tmp48_ = 0;
					const gchar* _tmp49_;
					gint _tmp50_;
					gint _tmp51_;
					gchar* _tmp52_ = NULL;
					gchar* _tmp53_;
					SkkUnicodeString* _tmp54_;
					SkkState* _tmp55_;
					SkkState* _tmp56_;
					SkkState* _tmp57_;
					SkkUnicodeString* _tmp58_;
					gint _tmp59_;
					gboolean _tmp60_ = FALSE;
					_tmp44_ = state;
					_tmp45_ = text;
					_tmp46_ = text;
					_tmp47_ = cursor_pos;
					_tmp48_ = string_index_of_nth_char (_tmp46_, (glong) _tmp47_);
					_tmp49_ = text;
					_tmp50_ = strlen (_tmp49_);
					_tmp51_ = _tmp50_;
					_tmp52_ = string_slice (_tmp45_, (glong) _tmp48_, (glong) _tmp51_);
					_tmp53_ = _tmp52_;
					_tmp54_ = skk_unicode_string_new (_tmp53_);
					_g_object_unref0 (_tmp44_->surrounding_text);
					_tmp44_->surrounding_text = _tmp54_;
					_g_free0 (_tmp53_);
					_tmp55_ = state;
					_tmp55_->surrounding_end = (guint) 0;
					_tmp56_ = state;
					_tmp57_ = state;
					_tmp58_ = _tmp57_->surrounding_text;
					_tmp59_ = _tmp58_->length;
					g_signal_emit_by_name (_tmp56_, "delete-surrounding-text", 0, (guint) _tmp59_, &_tmp60_);
				}
				_tmp61_ = state;
				_tmp61_->handler_type = SKK_TYPE_START_STATE_HANDLER;
				result = TRUE;
				_g_free0 (text);
				_g_free0 (command);
				return result;
			}
		}
	}
	_tmp64_ = command;
	if (_tmp64_ != NULL) {
		const gchar* _tmp65_;
		gboolean _tmp66_ = FALSE;
		_tmp65_ = command;
		_tmp66_ = g_str_has_prefix (_tmp65_, "set-input-mode-");
		_tmp63_ = _tmp66_;
	} else {
		_tmp63_ = FALSE;
	}
	_tmp67_ = _tmp63_;
	if (_tmp67_) {
		gboolean _tmp68_ = FALSE;
		gboolean _tmp69_ = FALSE;
		gboolean _tmp70_ = FALSE;
		gboolean _tmp71_ = FALSE;
		SkkState* _tmp72_;
		SkkInputMode _tmp73_;
		SkkInputMode _tmp74_;
		gboolean _tmp78_;
		gboolean _tmp82_;
		gboolean _tmp86_;
		gboolean _tmp93_;
		_tmp72_ = state;
		_tmp73_ = skk_state_get_input_mode (_tmp72_);
		_tmp74_ = _tmp73_;
		if (_tmp74_ == SKK_INPUT_MODE_HIRAGANA) {
			_tmp71_ = TRUE;
		} else {
			SkkState* _tmp75_;
			SkkInputMode _tmp76_;
			SkkInputMode _tmp77_;
			_tmp75_ = state;
			_tmp76_ = skk_state_get_input_mode (_tmp75_);
			_tmp77_ = _tmp76_;
			_tmp71_ = _tmp77_ == SKK_INPUT_MODE_KATAKANA;
		}
		_tmp78_ = _tmp71_;
		if (_tmp78_) {
			_tmp70_ = TRUE;
		} else {
			SkkState* _tmp79_;
			SkkInputMode _tmp80_;
			SkkInputMode _tmp81_;
			_tmp79_ = state;
			_tmp80_ = skk_state_get_input_mode (_tmp79_);
			_tmp81_ = _tmp80_;
			_tmp70_ = _tmp81_ == SKK_INPUT_MODE_HANKAKU_KATAKANA;
		}
		_tmp82_ = _tmp70_;
		if (_tmp82_) {
			SkkKeyEvent* _tmp83_;
			SkkModifierType _tmp84_;
			SkkModifierType _tmp85_;
			_tmp83_ = *key;
			_tmp84_ = skk_key_event_get_modifiers (_tmp83_);
			_tmp85_ = _tmp84_;
			_tmp69_ = _tmp85_ == 0;
		} else {
			_tmp69_ = FALSE;
		}
		_tmp86_ = _tmp69_;
		if (_tmp86_) {
			SkkState* _tmp87_;
			SkkRomKanaConverter* _tmp88_;
			SkkKeyEvent* _tmp89_;
			gunichar _tmp90_;
			gunichar _tmp91_;
			gboolean _tmp92_ = FALSE;
			_tmp87_ = state;
			_tmp88_ = _tmp87_->rom_kana_converter;
			_tmp89_ = *key;
			_tmp90_ = skk_key_event_get_code (_tmp89_);
			_tmp91_ = _tmp90_;
			_tmp92_ = skk_rom_kana_converter_can_consume (_tmp88_, _tmp91_, FALSE, TRUE);
			_tmp68_ = _tmp92_;
		} else {
			_tmp68_ = FALSE;
		}
		_tmp93_ = _tmp68_;
		_tmp62_ = !_tmp93_;
	} else {
		_tmp62_ = FALSE;
	}
	_tmp94_ = _tmp62_;
	if (_tmp94_) {
		{
			SkkEntry* entry_collection = NULL;
			gint entry_collection_length1 = 0;
			gint _entry_collection_size_ = 0;
			gint entry_it = 0;
			entry_collection = SKK_NONE_STATE_HANDLER_input_mode_commands;
			entry_collection_length1 = G_N_ELEMENTS (SKK_NONE_STATE_HANDLER_input_mode_commands);
			for (entry_it = 0; entry_it < G_N_ELEMENTS (SKK_NONE_STATE_HANDLER_input_mode_commands); entry_it = entry_it + 1) {
				SkkEntry entry = {0};
				entry = entry_collection[entry_it];
				{
					SkkEntry _tmp95_;
					gconstpointer _tmp96_;
					const gchar* _tmp97_;
					_tmp95_ = entry;
					_tmp96_ = _tmp95_.key;
					_tmp97_ = command;
					if (g_strcmp0 ((const gchar*) _tmp96_, _tmp97_) == 0) {
						SkkState* _tmp98_;
						SkkEntry _tmp99_;
						gconstpointer _tmp100_;
						_tmp98_ = state;
						_tmp99_ = entry;
						_tmp100_ = _tmp99_.value;
						skk_state_set_input_mode (_tmp98_, GPOINTER_TO_INT (_tmp100_));
						result = TRUE;
						_g_free0 (command);
						return result;
					}
				}
			}
		}
	}
	_tmp101_ = command;
	if (g_strcmp0 (_tmp101_, "delete") == 0) {
		SkkState* _tmp102_;
		SkkRomKanaConverter* _tmp103_;
		gboolean _tmp104_ = FALSE;
		SkkState* _tmp105_;
		GString* _tmp106_;
		gssize _tmp107_;
		_tmp102_ = state;
		_tmp103_ = _tmp102_->rom_kana_converter;
		_tmp104_ = skk_rom_kana_converter_delete (_tmp103_);
		if (_tmp104_) {
			result = TRUE;
			_g_free0 (command);
			return result;
		}
		_tmp105_ = state;
		_tmp106_ = _tmp105_->output;
		_tmp107_ = _tmp106_->len;
		if (_tmp107_ > ((gssize) 0)) {
			SkkState* _tmp108_;
			GString* _tmp109_;
			SkkState* _tmp110_;
			GString* _tmp111_;
			const gchar* _tmp112_;
			SkkState* _tmp113_;
			GString* _tmp114_;
			const gchar* _tmp115_;
			gint _tmp116_ = 0;
			gint _tmp117_ = 0;
			_tmp108_ = state;
			_tmp109_ = _tmp108_->output;
			_tmp110_ = state;
			_tmp111_ = _tmp110_->output;
			_tmp112_ = _tmp111_->str;
			_tmp113_ = state;
			_tmp114_ = _tmp113_->output;
			_tmp115_ = _tmp114_->str;
			_tmp116_ = g_utf8_strlen (_tmp115_, (gssize) (-1));
			_tmp117_ = string_index_of_nth_char (_tmp112_, (glong) (_tmp116_ - 1));
			g_string_truncate (_tmp109_, (gsize) _tmp117_);
			result = TRUE;
			_g_free0 (command);
			return result;
		}
		result = FALSE;
		_g_free0 (command);
		return result;
	}
	_tmp118_ = state;
	_tmp119_ = skk_state_get_input_mode (_tmp118_);
	_tmp120_ = _tmp119_;
	switch (_tmp120_) {
		case SKK_INPUT_MODE_HIRAGANA:
		case SKK_INPUT_MODE_KATAKANA:
		case SKK_INPUT_MODE_HANKAKU_KATAKANA:
		{
			gboolean _tmp121_ = FALSE;
			gboolean _tmp122_ = FALSE;
			SkkKeyEvent* _tmp123_;
			SkkModifierType _tmp124_;
			SkkModifierType _tmp125_;
			gboolean _tmp130_;
			gboolean _tmp135_;
			gboolean _tmp152_ = FALSE;
			const gchar* _tmp153_;
			gboolean _tmp156_;
			SkkKeyEvent* _tmp173_;
			SkkModifierType _tmp174_;
			SkkModifierType _tmp175_;
			_tmp123_ = *key;
			_tmp124_ = skk_key_event_get_modifiers (_tmp123_);
			_tmp125_ = _tmp124_;
			if (_tmp125_ == 0) {
				SkkKeyEvent* _tmp126_;
				gunichar _tmp127_;
				gunichar _tmp128_;
				gboolean _tmp129_ = FALSE;
				_tmp126_ = *key;
				_tmp127_ = skk_key_event_get_code (_tmp126_);
				_tmp128_ = _tmp127_;
				_tmp129_ = g_unichar_isalpha (_tmp128_);
				_tmp122_ = _tmp129_;
			} else {
				_tmp122_ = FALSE;
			}
			_tmp130_ = _tmp122_;
			if (_tmp130_) {
				SkkKeyEvent* _tmp131_;
				gunichar _tmp132_;
				gunichar _tmp133_;
				gboolean _tmp134_ = FALSE;
				_tmp131_ = *key;
				_tmp132_ = skk_key_event_get_code (_tmp131_);
				_tmp133_ = _tmp132_;
				_tmp134_ = g_unichar_isupper (_tmp133_);
				_tmp121_ = _tmp134_;
			} else {
				_tmp121_ = FALSE;
			}
			_tmp135_ = _tmp121_;
			if (_tmp135_) {
				SkkState* _tmp136_;
				_tmp136_ = state;
				_tmp136_->handler_type = SKK_TYPE_START_STATE_HANDLER;
				result = FALSE;
				_g_free0 (command);
				return result;
			} else {
				gboolean _tmp137_ = FALSE;
				SkkKeyEvent* _tmp138_;
				SkkModifierType _tmp139_;
				SkkModifierType _tmp140_;
				gboolean _tmp147_;
				_tmp138_ = *key;
				_tmp139_ = skk_key_event_get_modifiers (_tmp138_);
				_tmp140_ = _tmp139_;
				if (_tmp140_ == 0) {
					SkkState* _tmp141_;
					SkkRomKanaConverter* _tmp142_;
					SkkKeyEvent* _tmp143_;
					gunichar _tmp144_;
					gunichar _tmp145_;
					gboolean _tmp146_ = FALSE;
					_tmp141_ = state;
					_tmp142_ = _tmp141_->rom_kana_converter;
					_tmp143_ = *key;
					_tmp144_ = skk_key_event_get_code (_tmp143_);
					_tmp145_ = _tmp144_;
					_tmp146_ = skk_rom_kana_converter_can_consume (_tmp142_, _tmp145_, TRUE, TRUE);
					_tmp137_ = !_tmp146_;
				} else {
					_tmp137_ = FALSE;
				}
				_tmp147_ = _tmp137_;
				if (_tmp147_) {
					const gchar* _tmp148_;
					_tmp148_ = command;
					if (g_strcmp0 (_tmp148_, "abbrev") == 0) {
						SkkState* _tmp149_;
						_tmp149_ = state;
						_tmp149_->handler_type = SKK_TYPE_ABBREV_STATE_HANDLER;
						result = TRUE;
						_g_free0 (command);
						return result;
					} else {
						const gchar* _tmp150_;
						_tmp150_ = command;
						if (g_strcmp0 (_tmp150_, "kuten") == 0) {
							SkkState* _tmp151_;
							_tmp151_ = state;
							_tmp151_->handler_type = SKK_TYPE_KUTEN_STATE_HANDLER;
							result = TRUE;
							_g_free0 (command);
							return result;
						}
					}
				}
			}
			_tmp153_ = command;
			if (_tmp153_ != NULL) {
				const gchar* _tmp154_;
				gboolean _tmp155_ = FALSE;
				_tmp154_ = command;
				_tmp155_ = g_str_has_prefix (_tmp154_, "insert-kana-");
				_tmp152_ = _tmp155_;
			} else {
				_tmp152_ = FALSE;
			}
			_tmp156_ = _tmp152_;
			if (_tmp156_) {
				const gchar* _tmp157_;
				gint _tmp158_;
				gint _tmp159_;
				const gchar* _tmp160_;
				gint _tmp161_;
				gint _tmp162_;
				gchar* _tmp163_ = NULL;
				gchar* _tmp164_;
				SkkState* _tmp165_;
				SkkInputMode _tmp166_;
				SkkInputMode _tmp167_;
				gchar* _tmp168_ = NULL;
				gchar* _tmp169_;
				gchar* kana;
				SkkState* _tmp170_;
				GString* _tmp171_;
				const gchar* _tmp172_;
				_tmp157_ = command;
				_tmp158_ = strlen ("insert-kana-");
				_tmp159_ = _tmp158_;
				_tmp160_ = command;
				_tmp161_ = strlen (_tmp160_);
				_tmp162_ = _tmp161_;
				_tmp163_ = string_slice (_tmp157_, (glong) _tmp159_, (glong) _tmp162_);
				_tmp164_ = _tmp163_;
				_tmp165_ = state;
				_tmp166_ = skk_state_get_input_mode (_tmp165_);
				_tmp167_ = _tmp166_;
				_tmp168_ = skk_util_convert_by_input_mode (_tmp164_, _tmp167_);
				_tmp169_ = _tmp168_;
				_g_free0 (_tmp164_);
				kana = _tmp169_;
				_tmp170_ = state;
				_tmp171_ = _tmp170_->output;
				_tmp172_ = kana;
				g_string_append (_tmp171_, _tmp172_);
				result = TRUE;
				_g_free0 (kana);
				_g_free0 (command);
				return result;
			}
			_tmp173_ = *key;
			_tmp174_ = skk_key_event_get_modifiers (_tmp173_);
			_tmp175_ = _tmp174_;
			if (_tmp175_ == 0) {
				SkkState* _tmp176_;
				SkkRomKanaConverter* _tmp177_;
				SkkKeyEvent* _tmp178_;
				gunichar _tmp179_;
				gunichar _tmp180_;
				gboolean _tmp181_ = FALSE;
				_tmp176_ = state;
				_tmp177_ = _tmp176_->rom_kana_converter;
				_tmp178_ = *key;
				_tmp179_ = skk_key_event_get_code (_tmp178_);
				_tmp180_ = _tmp179_;
				_tmp181_ = skk_rom_kana_converter_append (_tmp177_, _tmp180_);
				if (_tmp181_) {
					SkkState* _tmp182_;
					GString* _tmp183_;
					SkkState* _tmp184_;
					SkkRomKanaConverter* _tmp185_;
					const gchar* _tmp186_;
					const gchar* _tmp187_;
					SkkState* _tmp188_;
					SkkRomKanaConverter* _tmp189_;
					_tmp182_ = state;
					_tmp183_ = _tmp182_->output;
					_tmp184_ = state;
					_tmp185_ = _tmp184_->rom_kana_converter;
					_tmp186_ = skk_rom_kana_converter_get_output (_tmp185_);
					_tmp187_ = _tmp186_;
					g_string_append (_tmp183_, _tmp187_);
					_tmp188_ = state;
					_tmp189_ = _tmp188_->rom_kana_converter;
					skk_rom_kana_converter_set_output (_tmp189_, "");
					result = TRUE;
					_g_free0 (command);
					return result;
				} else {
					gboolean _tmp190_ = FALSE;
					SkkKeyEvent* _tmp191_;
					gunichar _tmp192_;
					gunichar _tmp193_;
					gboolean _tmp197_;
					_tmp191_ = *key;
					_tmp192_ = skk_key_event_get_code (_tmp191_);
					_tmp193_ = _tmp192_;
					if (((gunichar) 0x20) <= _tmp193_) {
						SkkKeyEvent* _tmp194_;
						gunichar _tmp195_;
						gunichar _tmp196_;
						_tmp194_ = *key;
						_tmp195_ = skk_key_event_get_code (_tmp194_);
						_tmp196_ = _tmp195_;
						_tmp190_ = _tmp196_ <= ((gunichar) 0x7F);
					} else {
						_tmp190_ = FALSE;
					}
					_tmp197_ = _tmp190_;
					if (_tmp197_) {
						SkkState* _tmp198_;
						GString* _tmp199_;
						SkkKeyEvent* _tmp200_;
						gunichar _tmp201_;
						gunichar _tmp202_;
						SkkState* _tmp203_;
						SkkRomKanaConverter* _tmp204_;
						_tmp198_ = state;
						_tmp199_ = _tmp198_->output;
						_tmp200_ = *key;
						_tmp201_ = skk_key_event_get_code (_tmp200_);
						_tmp202_ = _tmp201_;
						g_string_append_c (_tmp199_, (gchar) _tmp202_);
						_tmp203_ = state;
						_tmp204_ = _tmp203_->rom_kana_converter;
						skk_rom_kana_converter_set_output (_tmp204_, "");
						result = TRUE;
						_g_free0 (command);
						return result;
					} else {
						SkkState* _tmp205_;
						SkkRomKanaConverter* _tmp206_;
						_tmp205_ = state;
						_tmp206_ = _tmp205_->rom_kana_converter;
						skk_rom_kana_converter_set_output (_tmp206_, "");
						result = FALSE;
						_g_free0 (command);
						return result;
					}
				}
			}
			break;
		}
		case SKK_INPUT_MODE_LATIN:
		{
			gboolean _tmp207_ = FALSE;
			gboolean _tmp208_ = FALSE;
			SkkKeyEvent* _tmp209_;
			SkkModifierType _tmp210_;
			SkkModifierType _tmp211_;
			gboolean _tmp215_;
			gboolean _tmp219_;
			_tmp209_ = *key;
			_tmp210_ = skk_key_event_get_modifiers (_tmp209_);
			_tmp211_ = _tmp210_;
			if (_tmp211_ == 0) {
				SkkKeyEvent* _tmp212_;
				gunichar _tmp213_;
				gunichar _tmp214_;
				_tmp212_ = *key;
				_tmp213_ = skk_key_event_get_code (_tmp212_);
				_tmp214_ = _tmp213_;
				_tmp208_ = ((gunichar) 0x20) <= _tmp214_;
			} else {
				_tmp208_ = FALSE;
			}
			_tmp215_ = _tmp208_;
			if (_tmp215_) {
				SkkKeyEvent* _tmp216_;
				gunichar _tmp217_;
				gunichar _tmp218_;
				_tmp216_ = *key;
				_tmp217_ = skk_key_event_get_code (_tmp216_);
				_tmp218_ = _tmp217_;
				_tmp207_ = _tmp218_ <= ((gunichar) 0x7F);
			} else {
				_tmp207_ = FALSE;
			}
			_tmp219_ = _tmp207_;
			if (_tmp219_) {
				SkkState* _tmp220_;
				GString* _tmp221_;
				SkkKeyEvent* _tmp222_;
				gunichar _tmp223_;
				gunichar _tmp224_;
				_tmp220_ = state;
				_tmp221_ = _tmp220_->output;
				_tmp222_ = *key;
				_tmp223_ = skk_key_event_get_code (_tmp222_);
				_tmp224_ = _tmp223_;
				g_string_append_c (_tmp221_, (gchar) _tmp224_);
				result = TRUE;
				_g_free0 (command);
				return result;
			}
			break;
		}
		case SKK_INPUT_MODE_WIDE_LATIN:
		{
			gboolean _tmp225_ = FALSE;
			gboolean _tmp226_ = FALSE;
			SkkKeyEvent* _tmp227_;
			SkkModifierType _tmp228_;
			SkkModifierType _tmp229_;
			gboolean _tmp233_;
			gboolean _tmp237_;
			_tmp227_ = *key;
			_tmp228_ = skk_key_event_get_modifiers (_tmp227_);
			_tmp229_ = _tmp228_;
			if (_tmp229_ == 0) {
				SkkKeyEvent* _tmp230_;
				gunichar _tmp231_;
				gunichar _tmp232_;
				_tmp230_ = *key;
				_tmp231_ = skk_key_event_get_code (_tmp230_);
				_tmp232_ = _tmp231_;
				_tmp226_ = ((gunichar) 0x20) <= _tmp232_;
			} else {
				_tmp226_ = FALSE;
			}
			_tmp233_ = _tmp226_;
			if (_tmp233_) {
				SkkKeyEvent* _tmp234_;
				gunichar _tmp235_;
				gunichar _tmp236_;
				_tmp234_ = *key;
				_tmp235_ = skk_key_event_get_code (_tmp234_);
				_tmp236_ = _tmp235_;
				_tmp225_ = _tmp236_ <= ((gunichar) 0x7F);
			} else {
				_tmp225_ = FALSE;
			}
			_tmp237_ = _tmp225_;
			if (_tmp237_) {
				SkkState* _tmp238_;
				GString* _tmp239_;
				SkkKeyEvent* _tmp240_;
				gunichar _tmp241_;
				gunichar _tmp242_;
				gunichar _tmp243_ = 0U;
				_tmp238_ = state;
				_tmp239_ = _tmp238_->output;
				_tmp240_ = *key;
				_tmp241_ = skk_key_event_get_code (_tmp240_);
				_tmp242_ = _tmp241_;
				_tmp243_ = skk_util_get_wide_latin_char ((gchar) _tmp242_);
				g_string_append_unichar (_tmp239_, _tmp243_);
				result = TRUE;
				_g_free0 (command);
				return result;
			}
			break;
		}
		default:
		break;
	}
	result = FALSE;
	_g_free0 (command);
	return result;
}


static gchar* skk_none_state_handler_real_get_preedit (SkkStateHandler* base, SkkState* state, guint* underline_offset, guint* underline_nchars) {
	SkkNoneStateHandler * self;
	guint _vala_underline_offset = 0U;
	guint _vala_underline_nchars = 0U;
	gchar* result = NULL;
	GString* _tmp0_;
	GString* builder;
	SkkState* _tmp1_;
	SkkRomKanaConverter* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	self = (SkkNoneStateHandler*) base;
	g_return_val_if_fail (state != NULL, NULL);
	_tmp0_ = g_string_new ("");
	builder = _tmp0_;
	_tmp1_ = state;
	_tmp2_ = _tmp1_->rom_kana_converter;
	_tmp3_ = skk_rom_kana_converter_get_preedit (_tmp2_);
	_tmp4_ = _tmp3_;
	g_string_append (builder, _tmp4_);
	_vala_underline_nchars = (guint) 0;
	_vala_underline_offset = _vala_underline_nchars;
	_tmp5_ = builder->str;
	_tmp6_ = g_strdup (_tmp5_);
	result = _tmp6_;
	_g_string_free0 (builder);
	if (underline_offset) {
		*underline_offset = _vala_underline_offset;
	}
	if (underline_nchars) {
		*underline_nchars = _vala_underline_nchars;
	}
	return result;
}


SkkNoneStateHandler* skk_none_state_handler_construct (GType object_type) {
	SkkNoneStateHandler * self = NULL;
	self = (SkkNoneStateHandler*) skk_state_handler_construct (object_type);
	return self;
}


SkkNoneStateHandler* skk_none_state_handler_new (void) {
	return skk_none_state_handler_construct (SKK_TYPE_NONE_STATE_HANDLER);
}


static void skk_none_state_handler_class_init (SkkNoneStateHandlerClass * klass) {
	skk_none_state_handler_parent_class = g_type_class_peek_parent (klass);
	SKK_STATE_HANDLER_CLASS (klass)->process_key_event = skk_none_state_handler_real_process_key_event;
	SKK_STATE_HANDLER_CLASS (klass)->get_preedit = skk_none_state_handler_real_get_preedit;
}


static void skk_none_state_handler_instance_init (SkkNoneStateHandler * self) {
}


GType skk_none_state_handler_get_type (void) {
	static volatile gsize skk_none_state_handler_type_id__volatile = 0;
	if (g_once_init_enter (&skk_none_state_handler_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SkkNoneStateHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) skk_none_state_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SkkNoneStateHandler), 0, (GInstanceInitFunc) skk_none_state_handler_instance_init, NULL };
		GType skk_none_state_handler_type_id;
		skk_none_state_handler_type_id = g_type_register_static (SKK_TYPE_STATE_HANDLER, "SkkNoneStateHandler", &g_define_type_info, 0);
		g_once_init_leave (&skk_none_state_handler_type_id__volatile, skk_none_state_handler_type_id);
	}
	return skk_none_state_handler_type_id__volatile;
}


SkkKutenStateHandler* skk_kuten_state_handler_construct (GType object_type) {
	SkkKutenStateHandler * self = NULL;
	GError * _inner_error_ = NULL;
	self = (SkkKutenStateHandler*) skk_state_handler_construct (object_type);
	{
		SkkEncodingConverter* _tmp0_;
		SkkEncodingConverter* _tmp1_;
		_tmp0_ = skk_encoding_converter_new ("EUC-JP", &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			goto __catch30_g_error;
		}
		_skk_encoding_converter_unref0 (self->priv->converter);
		self->priv->converter = _tmp1_;
	}
	goto __finally30;
	__catch30_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_skk_encoding_converter_unref0 (self->priv->converter);
		self->priv->converter = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally30:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


SkkKutenStateHandler* skk_kuten_state_handler_new (void) {
	return skk_kuten_state_handler_construct (SKK_TYPE_KUTEN_STATE_HANDLER);
}


static gint skk_kuten_state_handler_hex_char_to_int (SkkKutenStateHandler* self, gchar hex) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	gchar _tmp1_;
	gboolean _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp1_ = hex;
	if ('0' <= _tmp1_) {
		gchar _tmp2_;
		_tmp2_ = hex;
		_tmp0_ = _tmp2_ <= '9';
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		gchar _tmp4_;
		_tmp4_ = hex;
		result = (gint) (_tmp4_ - '0');
		return result;
	} else {
		gboolean _tmp5_ = FALSE;
		gchar _tmp6_;
		gchar _tmp7_ = '\0';
		gboolean _tmp10_;
		_tmp6_ = hex;
		_tmp7_ = g_ascii_tolower (_tmp6_);
		if ('a' <= _tmp7_) {
			gchar _tmp8_;
			gchar _tmp9_ = '\0';
			_tmp8_ = hex;
			_tmp9_ = g_ascii_tolower (_tmp8_);
			_tmp5_ = _tmp9_ <= 'f';
		} else {
			_tmp5_ = FALSE;
		}
		_tmp10_ = _tmp5_;
		if (_tmp10_) {
			gchar _tmp11_;
			_tmp11_ = hex;
			result = (_tmp11_ - 'a') + 10;
			return result;
		}
	}
	result = -1;
	return result;
}


static gchar* skk_kuten_state_handler_parse_hex (SkkKutenStateHandler* self, const gchar* hex) {
	gchar* result = NULL;
	GString* _tmp0_;
	GString* builder;
	GString* _tmp18_;
	const gchar* _tmp19_;
	gchar* _tmp20_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (hex != NULL, NULL);
	_tmp0_ = g_string_new ("");
	builder = _tmp0_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				const gchar* _tmp5_;
				gint _tmp6_;
				gint _tmp7_;
				const gchar* _tmp8_;
				gint _tmp9_;
				gchar _tmp10_ = '\0';
				gint _tmp11_ = 0;
				const gchar* _tmp12_;
				gint _tmp13_;
				gchar _tmp14_ = '\0';
				gint _tmp15_ = 0;
				gint c;
				GString* _tmp16_;
				gint _tmp17_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 2;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = hex;
				_tmp6_ = strlen (_tmp5_);
				_tmp7_ = _tmp6_;
				if (!(_tmp4_ < (_tmp7_ - 1))) {
					break;
				}
				_tmp8_ = hex;
				_tmp9_ = i;
				_tmp10_ = string_get (_tmp8_, (glong) _tmp9_);
				_tmp11_ = skk_kuten_state_handler_hex_char_to_int (self, _tmp10_);
				_tmp12_ = hex;
				_tmp13_ = i;
				_tmp14_ = string_get (_tmp12_, (glong) (_tmp13_ + 1));
				_tmp15_ = skk_kuten_state_handler_hex_char_to_int (self, _tmp14_);
				c = (_tmp11_ << 4) | _tmp15_;
				_tmp16_ = builder;
				_tmp17_ = c;
				g_string_append_c (_tmp16_, (gchar) _tmp17_);
			}
		}
	}
	_tmp18_ = builder;
	_tmp19_ = _tmp18_->str;
	_tmp20_ = g_strdup (_tmp19_);
	result = _tmp20_;
	_g_string_free0 (builder);
	return result;
}


static gboolean skk_kuten_state_handler_real_process_key_event (SkkStateHandler* base, SkkState* state, SkkKeyEvent** key) {
	SkkKutenStateHandler * self;
	gboolean result = FALSE;
	SkkState* _tmp0_;
	SkkKeyEvent* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* command;
	const gchar* _tmp3_;
	GError * _inner_error_ = NULL;
	self = (SkkKutenStateHandler*) base;
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = *key;
	_tmp2_ = skk_state_lookup_key (_tmp0_, _tmp1_);
	command = _tmp2_;
	_tmp3_ = command;
	if (g_strcmp0 (_tmp3_, "abort") == 0) {
		SkkState* _tmp4_;
		_tmp4_ = state;
		skk_state_reset (_tmp4_);
		result = TRUE;
		_g_free0 (command);
		return result;
	} else {
		gboolean _tmp5_ = FALSE;
		const gchar* _tmp6_;
		gboolean _tmp15_;
		_tmp6_ = command;
		if (g_strcmp0 (_tmp6_, "commit-unhandled") == 0) {
			gboolean _tmp7_ = FALSE;
			SkkState* _tmp8_;
			GString* _tmp9_;
			gssize _tmp10_;
			gboolean _tmp14_;
			_tmp8_ = state;
			_tmp9_ = _tmp8_->kuten;
			_tmp10_ = _tmp9_->len;
			if (_tmp10_ == ((gssize) 4)) {
				_tmp7_ = TRUE;
			} else {
				SkkState* _tmp11_;
				GString* _tmp12_;
				gssize _tmp13_;
				_tmp11_ = state;
				_tmp12_ = _tmp11_->kuten;
				_tmp13_ = _tmp12_->len;
				_tmp7_ = _tmp13_ == ((gssize) 6);
			}
			_tmp14_ = _tmp7_;
			_tmp5_ = _tmp14_;
		} else {
			_tmp5_ = FALSE;
		}
		_tmp15_ = _tmp5_;
		if (_tmp15_) {
			SkkEncodingConverter* _tmp16_;
			SkkState* _tmp31_;
			_tmp16_ = self->priv->converter;
			if (_tmp16_ != NULL) {
				SkkState* _tmp17_;
				GString* _tmp18_;
				const gchar* _tmp19_;
				gchar* _tmp20_ = NULL;
				gchar* euc;
				_tmp17_ = state;
				_tmp18_ = _tmp17_->kuten;
				_tmp19_ = _tmp18_->str;
				_tmp20_ = skk_kuten_state_handler_parse_hex (self, _tmp19_);
				euc = _tmp20_;
				{
					SkkEncodingConverter* _tmp21_;
					const gchar* _tmp22_;
					gchar* _tmp23_ = NULL;
					gchar* _tmp24_;
					SkkState* _tmp25_;
					GString* _tmp26_;
					gchar* _tmp27_;
					_tmp21_ = self->priv->converter;
					_tmp22_ = euc;
					_tmp23_ = skk_encoding_converter_decode (_tmp21_, _tmp22_, &_inner_error_);
					_tmp24_ = _tmp23_;
					if (_inner_error_ != NULL) {
						goto __catch31_g_error;
					}
					_tmp25_ = state;
					_tmp26_ = _tmp25_->output;
					_tmp27_ = _tmp24_;
					g_string_append (_tmp26_, _tmp27_);
					_g_free0 (_tmp27_);
				}
				goto __finally31;
				__catch31_g_error:
				{
					GError* e = NULL;
					const gchar* _tmp28_;
					GError* _tmp29_;
					const gchar* _tmp30_;
					e = _inner_error_;
					_inner_error_ = NULL;
					_tmp28_ = euc;
					_tmp29_ = e;
					_tmp30_ = _tmp29_->message;
					g_warning ("state.vala:598: can't decode %s in EUC-JP: %s", _tmp28_, _tmp30_);
					_g_error_free0 (e);
				}
				__finally31:
				if (_inner_error_ != NULL) {
					_g_free0 (euc);
					_g_free0 (command);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return FALSE;
				}
				_g_free0 (euc);
			}
			_tmp31_ = state;
			skk_state_reset (_tmp31_);
			result = TRUE;
			_g_free0 (command);
			return result;
		} else {
			gboolean _tmp32_ = FALSE;
			const gchar* _tmp33_;
			gboolean _tmp37_;
			_tmp33_ = command;
			if (g_strcmp0 (_tmp33_, "delete") == 0) {
				SkkState* _tmp34_;
				GString* _tmp35_;
				gssize _tmp36_;
				_tmp34_ = state;
				_tmp35_ = _tmp34_->kuten;
				_tmp36_ = _tmp35_->len;
				_tmp32_ = _tmp36_ > ((gssize) 0);
			} else {
				_tmp32_ = FALSE;
			}
			_tmp37_ = _tmp32_;
			if (_tmp37_) {
				SkkState* _tmp38_;
				GString* _tmp39_;
				SkkState* _tmp40_;
				GString* _tmp41_;
				gssize _tmp42_;
				_tmp38_ = state;
				_tmp39_ = _tmp38_->kuten;
				_tmp40_ = state;
				_tmp41_ = _tmp40_->kuten;
				_tmp42_ = _tmp41_->len;
				g_string_truncate (_tmp39_, (gsize) (_tmp42_ - 1));
				result = TRUE;
				_g_free0 (command);
				return result;
			} else {
				gboolean _tmp43_ = FALSE;
				gboolean _tmp44_ = FALSE;
				SkkKeyEvent* _tmp45_;
				SkkModifierType _tmp46_;
				SkkModifierType _tmp47_;
				gboolean _tmp76_;
				gboolean _tmp80_;
				_tmp45_ = *key;
				_tmp46_ = skk_key_event_get_modifiers (_tmp45_);
				_tmp47_ = _tmp46_;
				if (_tmp47_ == 0) {
					gboolean _tmp48_ = FALSE;
					gboolean _tmp49_ = FALSE;
					gboolean _tmp50_ = FALSE;
					SkkKeyEvent* _tmp51_;
					gunichar _tmp52_;
					gunichar _tmp53_;
					gboolean _tmp57_;
					gboolean _tmp66_;
					gboolean _tmp75_;
					_tmp51_ = *key;
					_tmp52_ = skk_key_event_get_code (_tmp51_);
					_tmp53_ = _tmp52_;
					if (((gunichar) 'a') <= _tmp53_) {
						SkkKeyEvent* _tmp54_;
						gunichar _tmp55_;
						gunichar _tmp56_;
						_tmp54_ = *key;
						_tmp55_ = skk_key_event_get_code (_tmp54_);
						_tmp56_ = _tmp55_;
						_tmp50_ = _tmp56_ <= ((gunichar) 'f');
					} else {
						_tmp50_ = FALSE;
					}
					_tmp57_ = _tmp50_;
					if (_tmp57_) {
						_tmp49_ = TRUE;
					} else {
						gboolean _tmp58_ = FALSE;
						SkkKeyEvent* _tmp59_;
						gunichar _tmp60_;
						gunichar _tmp61_;
						gboolean _tmp65_;
						_tmp59_ = *key;
						_tmp60_ = skk_key_event_get_code (_tmp59_);
						_tmp61_ = _tmp60_;
						if (((gunichar) 'A') <= _tmp61_) {
							SkkKeyEvent* _tmp62_;
							gunichar _tmp63_;
							gunichar _tmp64_;
							_tmp62_ = *key;
							_tmp63_ = skk_key_event_get_code (_tmp62_);
							_tmp64_ = _tmp63_;
							_tmp58_ = _tmp64_ <= ((gunichar) 'F');
						} else {
							_tmp58_ = FALSE;
						}
						_tmp65_ = _tmp58_;
						_tmp49_ = _tmp65_;
					}
					_tmp66_ = _tmp49_;
					if (_tmp66_) {
						_tmp48_ = TRUE;
					} else {
						gboolean _tmp67_ = FALSE;
						SkkKeyEvent* _tmp68_;
						gunichar _tmp69_;
						gunichar _tmp70_;
						gboolean _tmp74_;
						_tmp68_ = *key;
						_tmp69_ = skk_key_event_get_code (_tmp68_);
						_tmp70_ = _tmp69_;
						if (((gunichar) '0') <= _tmp70_) {
							SkkKeyEvent* _tmp71_;
							gunichar _tmp72_;
							gunichar _tmp73_;
							_tmp71_ = *key;
							_tmp72_ = skk_key_event_get_code (_tmp71_);
							_tmp73_ = _tmp72_;
							_tmp67_ = _tmp73_ <= ((gunichar) '9');
						} else {
							_tmp67_ = FALSE;
						}
						_tmp74_ = _tmp67_;
						_tmp48_ = _tmp74_;
					}
					_tmp75_ = _tmp48_;
					_tmp44_ = _tmp75_;
				} else {
					_tmp44_ = FALSE;
				}
				_tmp76_ = _tmp44_;
				if (_tmp76_) {
					SkkState* _tmp77_;
					GString* _tmp78_;
					gssize _tmp79_;
					_tmp77_ = state;
					_tmp78_ = _tmp77_->kuten;
					_tmp79_ = _tmp78_->len;
					_tmp43_ = _tmp79_ < ((gssize) 6);
				} else {
					_tmp43_ = FALSE;
				}
				_tmp80_ = _tmp43_;
				if (_tmp80_) {
					SkkState* _tmp81_;
					GString* _tmp82_;
					SkkKeyEvent* _tmp83_;
					gunichar _tmp84_;
					gunichar _tmp85_;
					_tmp81_ = state;
					_tmp82_ = _tmp81_->kuten;
					_tmp83_ = *key;
					_tmp84_ = skk_key_event_get_code (_tmp83_);
					_tmp85_ = _tmp84_;
					g_string_append_unichar (_tmp82_, _tmp85_);
					result = TRUE;
					_g_free0 (command);
					return result;
				}
			}
		}
	}
	result = TRUE;
	_g_free0 (command);
	return result;
}


static gchar* skk_kuten_state_handler_real_get_preedit (SkkStateHandler* base, SkkState* state, guint* underline_offset, guint* underline_nchars) {
	SkkKutenStateHandler * self;
	guint _vala_underline_offset = 0U;
	guint _vala_underline_nchars = 0U;
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	SkkState* _tmp1_;
	GString* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	self = (SkkKutenStateHandler*) base;
	g_return_val_if_fail (state != NULL, NULL);
	_vala_underline_nchars = (guint) 0;
	_vala_underline_offset = _vala_underline_nchars;
	_tmp0_ = _ ("Kuten([MM]KKTT) ");
	_tmp1_ = state;
	_tmp2_ = _tmp1_->kuten;
	_tmp3_ = _tmp2_->str;
	_tmp4_ = g_strconcat (_tmp0_, _tmp3_, NULL);
	result = _tmp4_;
	if (underline_offset) {
		*underline_offset = _vala_underline_offset;
	}
	if (underline_nchars) {
		*underline_nchars = _vala_underline_nchars;
	}
	return result;
}


static void skk_kuten_state_handler_class_init (SkkKutenStateHandlerClass * klass) {
	skk_kuten_state_handler_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SkkKutenStateHandlerPrivate));
	SKK_STATE_HANDLER_CLASS (klass)->process_key_event = skk_kuten_state_handler_real_process_key_event;
	SKK_STATE_HANDLER_CLASS (klass)->get_preedit = skk_kuten_state_handler_real_get_preedit;
	G_OBJECT_CLASS (klass)->finalize = skk_kuten_state_handler_finalize;
}


static void skk_kuten_state_handler_instance_init (SkkKutenStateHandler * self) {
	self->priv = SKK_KUTEN_STATE_HANDLER_GET_PRIVATE (self);
}


static void skk_kuten_state_handler_finalize (GObject* obj) {
	SkkKutenStateHandler * self;
	self = SKK_KUTEN_STATE_HANDLER (obj);
	_skk_encoding_converter_unref0 (self->priv->converter);
	G_OBJECT_CLASS (skk_kuten_state_handler_parent_class)->finalize (obj);
}


GType skk_kuten_state_handler_get_type (void) {
	static volatile gsize skk_kuten_state_handler_type_id__volatile = 0;
	if (g_once_init_enter (&skk_kuten_state_handler_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SkkKutenStateHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) skk_kuten_state_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SkkKutenStateHandler), 0, (GInstanceInitFunc) skk_kuten_state_handler_instance_init, NULL };
		GType skk_kuten_state_handler_type_id;
		skk_kuten_state_handler_type_id = g_type_register_static (SKK_TYPE_STATE_HANDLER, "SkkKutenStateHandler", &g_define_type_info, 0);
		g_once_init_leave (&skk_kuten_state_handler_type_id__volatile, skk_kuten_state_handler_type_id);
	}
	return skk_kuten_state_handler_type_id__volatile;
}


static gboolean skk_abbrev_state_handler_real_process_key_event (SkkStateHandler* base, SkkState* state, SkkKeyEvent** key) {
	SkkAbbrevStateHandler * self;
	gboolean result = FALSE;
	SkkState* _tmp0_;
	SkkKeyEvent* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* command;
	const gchar* _tmp3_;
	self = (SkkAbbrevStateHandler*) base;
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = *key;
	_tmp2_ = skk_state_lookup_key (_tmp0_, _tmp1_);
	command = _tmp2_;
	_tmp3_ = command;
	if (g_strcmp0 (_tmp3_, "abort") == 0) {
		SkkState* _tmp4_;
		_tmp4_ = state;
		skk_state_reset (_tmp4_);
		result = TRUE;
		_g_free0 (command);
		return result;
	} else {
		const gchar* _tmp5_;
		_tmp5_ = command;
		if (g_strcmp0 (_tmp5_, "next-candidate") == 0) {
			SkkState* _tmp6_;
			_tmp6_ = state;
			_tmp6_->handler_type = SKK_TYPE_SELECT_STATE_HANDLER;
			result = FALSE;
			_g_free0 (command);
			return result;
		} else {
			gboolean _tmp7_ = FALSE;
			SkkKeyEvent* _tmp8_;
			SkkModifierType _tmp9_;
			SkkModifierType _tmp10_;
			gboolean _tmp14_;
			_tmp8_ = *key;
			_tmp9_ = skk_key_event_get_modifiers (_tmp8_);
			_tmp10_ = _tmp9_;
			if ((_tmp10_ & SKK_MODIFIER_TYPE_CONTROL_MASK) != 0) {
				SkkKeyEvent* _tmp11_;
				gunichar _tmp12_;
				gunichar _tmp13_;
				_tmp11_ = *key;
				_tmp12_ = skk_key_event_get_code (_tmp11_);
				_tmp13_ = _tmp12_;
				_tmp7_ = _tmp13_ == ((gunichar) 'q');
			} else {
				_tmp7_ = FALSE;
			}
			_tmp14_ = _tmp7_;
			if (_tmp14_) {
				SkkState* _tmp15_;
				GString* _tmp16_;
				SkkState* _tmp17_;
				GString* _tmp18_;
				const gchar* _tmp19_;
				gchar* _tmp20_ = NULL;
				gchar* _tmp21_;
				SkkState* _tmp22_;
				_tmp15_ = state;
				_tmp16_ = _tmp15_->output;
				_tmp17_ = state;
				_tmp18_ = _tmp17_->abbrev;
				_tmp19_ = _tmp18_->str;
				_tmp20_ = skk_util_get_wide_latin (_tmp19_);
				_tmp21_ = _tmp20_;
				g_string_assign (_tmp16_, _tmp21_);
				_g_free0 (_tmp21_);
				_tmp22_ = state;
				skk_state_reset (_tmp22_);
				result = TRUE;
				_g_free0 (command);
				return result;
			} else {
				const gchar* _tmp23_;
				_tmp23_ = command;
				if (g_strcmp0 (_tmp23_, "delete") == 0) {
					SkkState* _tmp24_;
					GString* _tmp25_;
					gssize _tmp26_;
					_tmp24_ = state;
					_tmp25_ = _tmp24_->abbrev;
					_tmp26_ = _tmp25_->len;
					if (_tmp26_ > ((gssize) 0)) {
						SkkState* _tmp27_;
						GString* _tmp28_;
						SkkState* _tmp29_;
						GString* _tmp30_;
						gssize _tmp31_;
						_tmp27_ = state;
						_tmp28_ = _tmp27_->abbrev;
						_tmp29_ = state;
						_tmp30_ = _tmp29_->abbrev;
						_tmp31_ = _tmp30_->len;
						g_string_truncate (_tmp28_, (gsize) (_tmp31_ - 1));
					} else {
						SkkState* _tmp32_;
						_tmp32_ = state;
						skk_state_reset (_tmp32_);
					}
					result = TRUE;
					_g_free0 (command);
					return result;
				} else {
					gboolean _tmp33_ = FALSE;
					gboolean _tmp34_ = FALSE;
					SkkKeyEvent* _tmp35_;
					SkkModifierType _tmp36_;
					SkkModifierType _tmp37_;
					gboolean _tmp41_;
					gboolean _tmp45_;
					_tmp35_ = *key;
					_tmp36_ = skk_key_event_get_modifiers (_tmp35_);
					_tmp37_ = _tmp36_;
					if (_tmp37_ == 0) {
						SkkKeyEvent* _tmp38_;
						gunichar _tmp39_;
						gunichar _tmp40_;
						_tmp38_ = *key;
						_tmp39_ = skk_key_event_get_code (_tmp38_);
						_tmp40_ = _tmp39_;
						_tmp34_ = ((gunichar) 0x20) <= _tmp40_;
					} else {
						_tmp34_ = FALSE;
					}
					_tmp41_ = _tmp34_;
					if (_tmp41_) {
						SkkKeyEvent* _tmp42_;
						gunichar _tmp43_;
						gunichar _tmp44_;
						_tmp42_ = *key;
						_tmp43_ = skk_key_event_get_code (_tmp42_);
						_tmp44_ = _tmp43_;
						_tmp33_ = _tmp44_ <= ((gunichar) 0x7E);
					} else {
						_tmp33_ = FALSE;
					}
					_tmp45_ = _tmp33_;
					if (_tmp45_) {
						SkkState* _tmp46_;
						GString* _tmp47_;
						SkkKeyEvent* _tmp48_;
						gunichar _tmp49_;
						gunichar _tmp50_;
						_tmp46_ = state;
						_tmp47_ = _tmp46_->abbrev;
						_tmp48_ = *key;
						_tmp49_ = skk_key_event_get_code (_tmp48_);
						_tmp50_ = _tmp49_;
						g_string_append_unichar (_tmp47_, _tmp50_);
						result = TRUE;
						_g_free0 (command);
						return result;
					}
				}
			}
		}
	}
	result = TRUE;
	_g_free0 (command);
	return result;
}


static gchar* skk_abbrev_state_handler_real_get_preedit (SkkStateHandler* base, SkkState* state, guint* underline_offset, guint* underline_nchars) {
	SkkAbbrevStateHandler * self;
	guint _vala_underline_offset = 0U;
	guint _vala_underline_nchars = 0U;
	gchar* result = NULL;
	SkkState* _tmp0_;
	GString* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	self = (SkkAbbrevStateHandler*) base;
	g_return_val_if_fail (state != NULL, NULL);
	_vala_underline_nchars = (guint) 0;
	_vala_underline_offset = _vala_underline_nchars;
	_tmp0_ = state;
	_tmp1_ = _tmp0_->abbrev;
	_tmp2_ = _tmp1_->str;
	_tmp3_ = g_strconcat ("▽", _tmp2_, NULL);
	result = _tmp3_;
	if (underline_offset) {
		*underline_offset = _vala_underline_offset;
	}
	if (underline_nchars) {
		*underline_nchars = _vala_underline_nchars;
	}
	return result;
}


SkkAbbrevStateHandler* skk_abbrev_state_handler_construct (GType object_type) {
	SkkAbbrevStateHandler * self = NULL;
	self = (SkkAbbrevStateHandler*) skk_state_handler_construct (object_type);
	return self;
}


SkkAbbrevStateHandler* skk_abbrev_state_handler_new (void) {
	return skk_abbrev_state_handler_construct (SKK_TYPE_ABBREV_STATE_HANDLER);
}


static void skk_abbrev_state_handler_class_init (SkkAbbrevStateHandlerClass * klass) {
	skk_abbrev_state_handler_parent_class = g_type_class_peek_parent (klass);
	SKK_STATE_HANDLER_CLASS (klass)->process_key_event = skk_abbrev_state_handler_real_process_key_event;
	SKK_STATE_HANDLER_CLASS (klass)->get_preedit = skk_abbrev_state_handler_real_get_preedit;
}


static void skk_abbrev_state_handler_instance_init (SkkAbbrevStateHandler * self) {
}


GType skk_abbrev_state_handler_get_type (void) {
	static volatile gsize skk_abbrev_state_handler_type_id__volatile = 0;
	if (g_once_init_enter (&skk_abbrev_state_handler_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SkkAbbrevStateHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) skk_abbrev_state_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SkkAbbrevStateHandler), 0, (GInstanceInitFunc) skk_abbrev_state_handler_instance_init, NULL };
		GType skk_abbrev_state_handler_type_id;
		skk_abbrev_state_handler_type_id = g_type_register_static (SKK_TYPE_STATE_HANDLER, "SkkAbbrevStateHandler", &g_define_type_info, 0);
		g_once_init_leave (&skk_abbrev_state_handler_type_id__volatile, skk_abbrev_state_handler_type_id);
	}
	return skk_abbrev_state_handler_type_id__volatile;
}


static gboolean skk_start_state_handler_real_process_key_event (SkkStateHandler* base, SkkState* state, SkkKeyEvent** key) {
	SkkStartStateHandler * self;
	gboolean result = FALSE;
	SkkState* _tmp0_;
	SkkKeyEvent* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* command;
	const gchar* _tmp3_;
	const gchar* _tmp36_;
	gboolean _tmp240_ = FALSE;
	SkkKeyEvent* _tmp241_;
	SkkModifierType _tmp242_;
	SkkModifierType _tmp243_;
	gboolean _tmp248_;
	self = (SkkStartStateHandler*) base;
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = *key;
	_tmp2_ = skk_state_lookup_key (_tmp0_, _tmp1_);
	command = _tmp2_;
	_tmp3_ = command;
	if (g_strcmp0 (_tmp3_, "abort") == 0) {
		SkkState* _tmp4_;
		_tmp4_ = state;
		skk_state_reset (_tmp4_);
		result = TRUE;
		_g_free0 (command);
		return result;
	}
	{
		SkkEntry* entry_collection = NULL;
		gint entry_collection_length1 = 0;
		gint _entry_collection_size_ = 0;
		gint entry_it = 0;
		entry_collection = SKK_START_STATE_HANDLER_end_preedit_commands;
		entry_collection_length1 = G_N_ELEMENTS (SKK_START_STATE_HANDLER_end_preedit_commands);
		for (entry_it = 0; entry_it < G_N_ELEMENTS (SKK_START_STATE_HANDLER_end_preedit_commands); entry_it = entry_it + 1) {
			SkkEntry entry = {0};
			entry = entry_collection[entry_it];
			{
				SkkEntry _tmp5_;
				gconstpointer _tmp6_;
				const gchar* _tmp7_;
				_tmp5_ = entry;
				_tmp6_ = _tmp5_.key;
				_tmp7_ = command;
				if (g_strcmp0 ((const gchar*) _tmp6_, _tmp7_) == 0) {
					SkkState* _tmp8_;
					SkkRomKanaConverter* _tmp9_;
					SkkState* _tmp10_;
					GString* _tmp11_;
					SkkState* _tmp12_;
					SkkRomKanaConverter* _tmp13_;
					const gchar* _tmp14_;
					const gchar* _tmp15_;
					SkkEntry _tmp16_;
					gconstpointer _tmp17_;
					gchar* _tmp18_ = NULL;
					gchar* _tmp19_;
					SkkState* _tmp20_;
					SkkUnicodeString* _tmp21_;
					SkkState* _tmp30_;
					SkkRomKanaConverter* _tmp31_;
					SkkState* _tmp32_;
					SkkEntry _tmp33_;
					gconstpointer _tmp34_;
					SkkState* _tmp35_;
					_tmp8_ = state;
					_tmp9_ = _tmp8_->rom_kana_converter;
					skk_rom_kana_converter_output_nn_if_any (_tmp9_);
					_tmp10_ = state;
					_tmp11_ = _tmp10_->output;
					_tmp12_ = state;
					_tmp13_ = _tmp12_->rom_kana_converter;
					_tmp14_ = skk_rom_kana_converter_get_output (_tmp13_);
					_tmp15_ = _tmp14_;
					_tmp16_ = entry;
					_tmp17_ = _tmp16_.value;
					_tmp18_ = skk_util_convert_by_input_mode (_tmp15_, GPOINTER_TO_INT (_tmp17_));
					_tmp19_ = _tmp18_;
					g_string_assign (_tmp11_, _tmp19_);
					_g_free0 (_tmp19_);
					_tmp20_ = state;
					_tmp21_ = _tmp20_->surrounding_text;
					if (_tmp21_ != NULL) {
						SkkState* _tmp22_;
						GString* _tmp23_;
						SkkState* _tmp24_;
						SkkUnicodeString* _tmp25_;
						SkkState* _tmp26_;
						guint _tmp27_;
						gchar* _tmp28_ = NULL;
						gchar* _tmp29_;
						_tmp22_ = state;
						_tmp23_ = _tmp22_->output;
						_tmp24_ = state;
						_tmp25_ = _tmp24_->surrounding_text;
						_tmp26_ = state;
						_tmp27_ = _tmp26_->surrounding_end;
						_tmp28_ = skk_unicode_string_substring (_tmp25_, (glong) _tmp27_, (glong) (-1));
						_tmp29_ = _tmp28_;
						g_string_append (_tmp23_, _tmp29_);
						_g_free0 (_tmp29_);
					}
					_tmp30_ = state;
					_tmp31_ = _tmp30_->rom_kana_converter;
					skk_rom_kana_converter_reset (_tmp31_);
					_tmp32_ = state;
					_tmp33_ = entry;
					_tmp34_ = _tmp33_.value;
					skk_state_set_input_mode (_tmp32_, GPOINTER_TO_INT (_tmp34_));
					_tmp35_ = state;
					_tmp35_->handler_type = SKK_TYPE_NONE_STATE_HANDLER;
					result = TRUE;
					_g_free0 (command);
					return result;
				}
			}
		}
	}
	_tmp36_ = command;
	if (g_strcmp0 (_tmp36_, "next-candidate") == 0) {
		SkkState* _tmp37_;
		SkkRomKanaConverter* _tmp38_;
		const gchar* _tmp39_;
		const gchar* _tmp40_;
		gint _tmp41_;
		gint _tmp42_;
		SkkState* _tmp54_;
		_tmp37_ = state;
		_tmp38_ = _tmp37_->rom_kana_converter;
		_tmp39_ = skk_rom_kana_converter_get_output (_tmp38_);
		_tmp40_ = _tmp39_;
		_tmp41_ = strlen (_tmp40_);
		_tmp42_ = _tmp41_;
		if (_tmp42_ == 0) {
			SkkState* _tmp43_;
			SkkUnicodeString* _tmp44_;
			SkkState* _tmp53_;
			_tmp43_ = state;
			_tmp44_ = _tmp43_->surrounding_text;
			if (_tmp44_ != NULL) {
				SkkState* _tmp45_;
				GString* _tmp46_;
				SkkState* _tmp47_;
				SkkUnicodeString* _tmp48_;
				SkkState* _tmp49_;
				guint _tmp50_;
				gchar* _tmp51_ = NULL;
				gchar* _tmp52_;
				_tmp45_ = state;
				_tmp46_ = _tmp45_->output;
				_tmp47_ = state;
				_tmp48_ = _tmp47_->surrounding_text;
				_tmp49_ = state;
				_tmp50_ = _tmp49_->surrounding_end;
				_tmp51_ = skk_unicode_string_substring (_tmp48_, (glong) _tmp50_, (glong) (-1));
				_tmp52_ = _tmp51_;
				g_string_append (_tmp46_, _tmp52_);
				_g_free0 (_tmp52_);
			}
			_tmp53_ = state;
			skk_state_reset (_tmp53_);
			result = TRUE;
			_g_free0 (command);
			return result;
		}
		_tmp54_ = state;
		_tmp54_->handler_type = SKK_TYPE_SELECT_STATE_HANDLER;
		result = FALSE;
		_g_free0 (command);
		return result;
	} else {
		const gchar* _tmp55_;
		_tmp55_ = command;
		if (g_strcmp0 (_tmp55_, "commit") == 0) {
			SkkState* _tmp56_;
			GString* _tmp57_;
			SkkState* _tmp58_;
			SkkRomKanaConverter* _tmp59_;
			const gchar* _tmp60_;
			const gchar* _tmp61_;
			SkkState* _tmp62_;
			SkkUnicodeString* _tmp63_;
			SkkState* _tmp72_;
			_tmp56_ = state;
			_tmp57_ = _tmp56_->output;
			_tmp58_ = state;
			_tmp59_ = _tmp58_->rom_kana_converter;
			_tmp60_ = skk_rom_kana_converter_get_output (_tmp59_);
			_tmp61_ = _tmp60_;
			g_string_append (_tmp57_, _tmp61_);
			_tmp62_ = state;
			_tmp63_ = _tmp62_->surrounding_text;
			if (_tmp63_ != NULL) {
				SkkState* _tmp64_;
				GString* _tmp65_;
				SkkState* _tmp66_;
				SkkUnicodeString* _tmp67_;
				SkkState* _tmp68_;
				guint _tmp69_;
				gchar* _tmp70_ = NULL;
				gchar* _tmp71_;
				_tmp64_ = state;
				_tmp65_ = _tmp64_->output;
				_tmp66_ = state;
				_tmp67_ = _tmp66_->surrounding_text;
				_tmp68_ = state;
				_tmp69_ = _tmp68_->surrounding_end;
				_tmp70_ = skk_unicode_string_substring (_tmp67_, (glong) _tmp69_, (glong) (-1));
				_tmp71_ = _tmp70_;
				g_string_append (_tmp65_, _tmp71_);
				_g_free0 (_tmp71_);
			}
			_tmp72_ = state;
			skk_state_reset (_tmp72_);
			result = TRUE;
			_g_free0 (command);
			return result;
		} else {
			const gchar* _tmp73_;
			_tmp73_ = command;
			if (g_strcmp0 (_tmp73_, "commit-unhandled") == 0) {
				SkkState* _tmp74_;
				GString* _tmp75_;
				SkkState* _tmp76_;
				SkkRomKanaConverter* _tmp77_;
				const gchar* _tmp78_;
				const gchar* _tmp79_;
				SkkState* _tmp80_;
				SkkUnicodeString* _tmp81_;
				SkkState* _tmp90_;
				SkkState* _tmp91_;
				gboolean _tmp92_;
				_tmp74_ = state;
				_tmp75_ = _tmp74_->output;
				_tmp76_ = state;
				_tmp77_ = _tmp76_->rom_kana_converter;
				_tmp78_ = skk_rom_kana_converter_get_output (_tmp77_);
				_tmp79_ = _tmp78_;
				g_string_append (_tmp75_, _tmp79_);
				_tmp80_ = state;
				_tmp81_ = _tmp80_->surrounding_text;
				if (_tmp81_ != NULL) {
					SkkState* _tmp82_;
					GString* _tmp83_;
					SkkState* _tmp84_;
					SkkUnicodeString* _tmp85_;
					SkkState* _tmp86_;
					guint _tmp87_;
					gchar* _tmp88_ = NULL;
					gchar* _tmp89_;
					_tmp82_ = state;
					_tmp83_ = _tmp82_->output;
					_tmp84_ = state;
					_tmp85_ = _tmp84_->surrounding_text;
					_tmp86_ = state;
					_tmp87_ = _tmp86_->surrounding_end;
					_tmp88_ = skk_unicode_string_substring (_tmp85_, (glong) _tmp87_, (glong) (-1));
					_tmp89_ = _tmp88_;
					g_string_append (_tmp83_, _tmp89_);
					_g_free0 (_tmp89_);
				}
				_tmp90_ = state;
				skk_state_reset (_tmp90_);
				_tmp91_ = state;
				_tmp92_ = _tmp91_->egg_like_newline;
				result = _tmp92_;
				_g_free0 (command);
				return result;
			} else {
				const gchar* _tmp93_;
				_tmp93_ = command;
				if (g_strcmp0 (_tmp93_, "delete") == 0) {
					SkkState* _tmp94_;
					SkkRomKanaConverter* _tmp95_;
					gboolean _tmp96_ = FALSE;
					SkkState* _tmp120_;
					_tmp94_ = state;
					_tmp95_ = _tmp94_->okuri_rom_kana_converter;
					_tmp96_ = skk_rom_kana_converter_delete (_tmp95_);
					if (_tmp96_) {
						SkkState* _tmp97_;
						SkkRomKanaConverter* _tmp98_;
						const gchar* _tmp99_;
						const gchar* _tmp100_;
						gint _tmp101_;
						gint _tmp102_;
						_tmp97_ = state;
						_tmp98_ = _tmp97_->okuri_rom_kana_converter;
						_tmp99_ = skk_rom_kana_converter_get_preedit (_tmp98_);
						_tmp100_ = _tmp99_;
						_tmp101_ = strlen (_tmp100_);
						_tmp102_ = _tmp101_;
						if (_tmp102_ == 0) {
							SkkState* _tmp103_;
							_tmp103_ = state;
							_tmp103_->okuri = FALSE;
						}
						result = TRUE;
						_g_free0 (command);
						return result;
					} else {
						SkkState* _tmp104_;
						SkkRomKanaConverter* _tmp105_;
						gboolean _tmp106_ = FALSE;
						_tmp104_ = state;
						_tmp105_ = _tmp104_->rom_kana_converter;
						_tmp106_ = skk_rom_kana_converter_delete (_tmp105_);
						if (_tmp106_) {
							result = TRUE;
							_g_free0 (command);
							return result;
						} else {
							SkkState* _tmp107_;
							GString* _tmp108_;
							gssize _tmp109_;
							_tmp107_ = state;
							_tmp108_ = _tmp107_->output;
							_tmp109_ = _tmp108_->len;
							if (_tmp109_ > ((gssize) 0)) {
								SkkState* _tmp110_;
								GString* _tmp111_;
								SkkState* _tmp112_;
								GString* _tmp113_;
								const gchar* _tmp114_;
								SkkState* _tmp115_;
								GString* _tmp116_;
								const gchar* _tmp117_;
								gint _tmp118_ = 0;
								gint _tmp119_ = 0;
								_tmp110_ = state;
								_tmp111_ = _tmp110_->output;
								_tmp112_ = state;
								_tmp113_ = _tmp112_->output;
								_tmp114_ = _tmp113_->str;
								_tmp115_ = state;
								_tmp116_ = _tmp115_->output;
								_tmp117_ = _tmp116_->str;
								_tmp118_ = g_utf8_strlen (_tmp117_, (gssize) (-1));
								_tmp119_ = string_index_of_nth_char (_tmp114_, (glong) (_tmp118_ - 1));
								g_string_truncate (_tmp111_, (gsize) _tmp119_);
								result = TRUE;
								_g_free0 (command);
								return result;
							}
						}
					}
					_tmp120_ = state;
					_tmp120_->handler_type = SKK_TYPE_NONE_STATE_HANDLER;
					result = TRUE;
					_g_free0 (command);
					return result;
				} else {
					const gchar* _tmp121_;
					_tmp121_ = command;
					if (g_strcmp0 (_tmp121_, "complete") == 0) {
						SkkState* _tmp122_;
						GeeIterator* _tmp123_;
						SkkState* _tmp129_;
						GeeIterator* _tmp130_;
						_tmp122_ = state;
						_tmp123_ = _tmp122_->completion_iterator;
						if (_tmp123_ == NULL) {
							SkkState* _tmp124_;
							SkkState* _tmp125_;
							SkkRomKanaConverter* _tmp126_;
							const gchar* _tmp127_;
							const gchar* _tmp128_;
							_tmp124_ = state;
							_tmp125_ = state;
							_tmp126_ = _tmp125_->rom_kana_converter;
							_tmp127_ = skk_rom_kana_converter_get_output (_tmp126_);
							_tmp128_ = _tmp127_;
							skk_state_completion_start (_tmp124_, _tmp128_);
						}
						_tmp129_ = state;
						_tmp130_ = _tmp129_->completion_iterator;
						if (_tmp130_ != NULL) {
							SkkState* _tmp131_;
							GeeIterator* _tmp132_;
							gpointer _tmp133_ = NULL;
							gchar* midasi;
							SkkState* _tmp134_;
							SkkRomKanaConverter* _tmp135_;
							SkkState* _tmp136_;
							SkkRomKanaConverter* _tmp137_;
							const gchar* _tmp138_;
							SkkState* _tmp139_;
							GeeIterator* _tmp140_;
							gboolean _tmp141_ = FALSE;
							_tmp131_ = state;
							_tmp132_ = _tmp131_->completion_iterator;
							_tmp133_ = gee_iterator_get (_tmp132_);
							midasi = (gchar*) _tmp133_;
							_tmp134_ = state;
							_tmp135_ = _tmp134_->rom_kana_converter;
							skk_rom_kana_converter_reset (_tmp135_);
							_tmp136_ = state;
							_tmp137_ = _tmp136_->rom_kana_converter;
							_tmp138_ = midasi;
							skk_rom_kana_converter_set_output (_tmp137_, _tmp138_);
							_tmp139_ = state;
							_tmp140_ = _tmp139_->completion_iterator;
							_tmp141_ = gee_iterator_has_next (_tmp140_);
							if (_tmp141_) {
								SkkState* _tmp142_;
								GeeIterator* _tmp143_;
								_tmp142_ = state;
								_tmp143_ = _tmp142_->completion_iterator;
								gee_iterator_next (_tmp143_);
							}
							_g_free0 (midasi);
						}
						result = TRUE;
						_g_free0 (command);
						return result;
					} else {
						const gchar* _tmp144_;
						_tmp144_ = command;
						if (g_strcmp0 (_tmp144_, "special-midasi") == 0) {
							SkkState* _tmp145_;
							SkkRomKanaConverter* _tmp146_;
							const gchar* _tmp147_;
							const gchar* _tmp148_;
							gint _tmp149_;
							gint _tmp150_;
							_tmp145_ = state;
							_tmp146_ = _tmp145_->rom_kana_converter;
							_tmp147_ = skk_rom_kana_converter_get_output (_tmp146_);
							_tmp148_ = _tmp147_;
							_tmp149_ = strlen (_tmp148_);
							_tmp150_ = _tmp149_;
							if (_tmp150_ > 0) {
								SkkState* _tmp151_;
								SkkRomKanaConverter* _tmp152_;
								SkkKeyEvent* _tmp153_;
								gunichar _tmp154_;
								gunichar _tmp155_;
								gunichar _tmp156_ = 0U;
								SkkState* _tmp157_;
								SkkState* _tmp158_;
								SkkKeyEvent* _tmp159_ = NULL;
								_tmp151_ = state;
								_tmp152_ = _tmp151_->rom_kana_converter;
								_tmp153_ = *key;
								_tmp154_ = skk_key_event_get_code (_tmp153_);
								_tmp155_ = _tmp154_;
								_tmp156_ = g_unichar_tolower (_tmp155_);
								skk_rom_kana_converter_append (_tmp152_, _tmp156_);
								_tmp157_ = state;
								_tmp157_->handler_type = SKK_TYPE_SELECT_STATE_HANDLER;
								_tmp158_ = state;
								_tmp159_ = skk_state_where_is (_tmp158_, "next-candidate");
								_skk_key_event_unref0 (*key);
								*key = _tmp159_;
								result = FALSE;
								_g_free0 (command);
								return result;
							} else {
								SkkState* _tmp160_;
								SkkRomKanaConverter* _tmp161_;
								SkkKeyEvent* _tmp162_;
								gunichar _tmp163_;
								gunichar _tmp164_;
								_tmp160_ = state;
								_tmp161_ = _tmp160_->rom_kana_converter;
								_tmp162_ = *key;
								_tmp163_ = skk_key_event_get_code (_tmp162_);
								_tmp164_ = _tmp163_;
								skk_rom_kana_converter_append (_tmp161_, _tmp164_);
								result = TRUE;
								_g_free0 (command);
								return result;
							}
						} else {
							gboolean _tmp165_ = FALSE;
							const gchar* _tmp166_;
							gboolean _tmp169_;
							_tmp166_ = command;
							if (_tmp166_ != NULL) {
								const gchar* _tmp167_;
								gboolean _tmp168_ = FALSE;
								_tmp167_ = command;
								_tmp168_ = g_str_has_prefix (_tmp167_, "insert-kana-");
								_tmp165_ = _tmp168_;
							} else {
								_tmp165_ = FALSE;
							}
							_tmp169_ = _tmp165_;
							if (_tmp169_) {
								const gchar* _tmp170_;
								gint _tmp171_;
								gint _tmp172_;
								const gchar* _tmp173_;
								gint _tmp174_;
								gint _tmp175_;
								gchar* _tmp176_ = NULL;
								gchar* _tmp177_;
								SkkState* _tmp178_;
								SkkInputMode _tmp179_;
								SkkInputMode _tmp180_;
								gchar* _tmp181_ = NULL;
								gchar* _tmp182_;
								gchar* kana;
								SkkState* _tmp183_;
								gboolean _tmp184_;
								_tmp170_ = command;
								_tmp171_ = strlen ("insert-kana-");
								_tmp172_ = _tmp171_;
								_tmp173_ = command;
								_tmp174_ = strlen (_tmp173_);
								_tmp175_ = _tmp174_;
								_tmp176_ = string_slice (_tmp170_, (glong) _tmp172_, (glong) _tmp175_);
								_tmp177_ = _tmp176_;
								_tmp178_ = state;
								_tmp179_ = skk_state_get_input_mode (_tmp178_);
								_tmp180_ = _tmp179_;
								_tmp181_ = skk_util_convert_by_input_mode (_tmp177_, _tmp180_);
								_tmp182_ = _tmp181_;
								_g_free0 (_tmp177_);
								kana = _tmp182_;
								_tmp183_ = state;
								_tmp184_ = _tmp183_->okuri;
								if (_tmp184_) {
									SkkState* _tmp185_;
									SkkRomKanaConverter* _tmp186_;
									const gchar* _tmp187_;
									SkkState* _tmp188_;
									SkkState* _tmp189_;
									SkkKeyEvent* _tmp190_ = NULL;
									_tmp185_ = state;
									_tmp186_ = _tmp185_->okuri_rom_kana_converter;
									_tmp187_ = kana;
									skk_rom_kana_converter_set_output (_tmp186_, _tmp187_);
									_tmp188_ = state;
									_tmp188_->handler_type = SKK_TYPE_SELECT_STATE_HANDLER;
									_tmp189_ = state;
									_tmp190_ = skk_state_where_is (_tmp189_, "next-candidate");
									_skk_key_event_unref0 (*key);
									*key = _tmp190_;
									result = FALSE;
									_g_free0 (kana);
									_g_free0 (command);
									return result;
								} else {
									SkkState* _tmp191_;
									SkkRomKanaConverter* _tmp192_;
									const gchar* _tmp193_;
									_tmp191_ = state;
									_tmp192_ = _tmp191_->rom_kana_converter;
									_tmp193_ = kana;
									skk_rom_kana_converter_set_output (_tmp192_, _tmp193_);
									result = TRUE;
									_g_free0 (kana);
									_g_free0 (command);
									return result;
								}
								_g_free0 (kana);
							} else {
								const gchar* _tmp194_;
								_tmp194_ = command;
								if (g_strcmp0 (_tmp194_, "start-preedit") == 0) {
									result = TRUE;
									_g_free0 (command);
									return result;
								} else {
									const gchar* _tmp195_;
									_tmp195_ = command;
									if (g_strcmp0 (_tmp195_, "start-preedit-kana") == 0) {
										SkkState* _tmp196_;
										SkkRomKanaConverter* _tmp197_;
										const gchar* _tmp198_;
										const gchar* _tmp199_;
										gint _tmp200_;
										gint _tmp201_;
										_tmp196_ = state;
										_tmp197_ = _tmp196_->rom_kana_converter;
										_tmp198_ = skk_rom_kana_converter_get_output (_tmp197_);
										_tmp199_ = _tmp198_;
										_tmp200_ = strlen (_tmp199_);
										_tmp201_ = _tmp200_;
										if (_tmp201_ > 0) {
											SkkState* _tmp202_;
											_tmp202_ = state;
											_tmp202_->okuri = TRUE;
										}
										result = TRUE;
										_g_free0 (command);
										return result;
									} else {
										const gchar* _tmp203_;
										_tmp203_ = command;
										if (g_strcmp0 (_tmp203_, "expand-preedit") == 0) {
											gboolean _tmp204_ = FALSE;
											SkkState* _tmp205_;
											SkkUnicodeString* _tmp206_;
											gboolean _tmp212_;
											_tmp205_ = state;
											_tmp206_ = _tmp205_->surrounding_text;
											if (_tmp206_ != NULL) {
												SkkState* _tmp207_;
												guint _tmp208_;
												SkkState* _tmp209_;
												SkkUnicodeString* _tmp210_;
												gint _tmp211_;
												_tmp207_ = state;
												_tmp208_ = _tmp207_->surrounding_end;
												_tmp209_ = state;
												_tmp210_ = _tmp209_->surrounding_text;
												_tmp211_ = _tmp210_->length;
												_tmp204_ = _tmp208_ < ((guint) _tmp211_);
											} else {
												_tmp204_ = FALSE;
											}
											_tmp212_ = _tmp204_;
											if (_tmp212_) {
												SkkState* _tmp213_;
												guint _tmp214_;
												SkkState* _tmp215_;
												SkkRomKanaConverter* _tmp216_;
												SkkState* _tmp217_;
												SkkUnicodeString* _tmp218_;
												SkkState* _tmp219_;
												guint _tmp220_;
												gchar* _tmp221_ = NULL;
												gchar* _tmp222_;
												_tmp213_ = state;
												_tmp214_ = _tmp213_->surrounding_end;
												_tmp213_->surrounding_end = _tmp214_ + 1;
												_tmp215_ = state;
												_tmp216_ = _tmp215_->rom_kana_converter;
												_tmp217_ = state;
												_tmp218_ = _tmp217_->surrounding_text;
												_tmp219_ = state;
												_tmp220_ = _tmp219_->surrounding_end;
												_tmp221_ = skk_unicode_string_substring (_tmp218_, (glong) 0, (glong) _tmp220_);
												_tmp222_ = _tmp221_;
												skk_rom_kana_converter_set_output (_tmp216_, _tmp222_);
												_g_free0 (_tmp222_);
												result = TRUE;
												_g_free0 (command);
												return result;
											}
										} else {
											const gchar* _tmp223_;
											_tmp223_ = command;
											if (g_strcmp0 (_tmp223_, "shrink-preedit") == 0) {
												gboolean _tmp224_ = FALSE;
												SkkState* _tmp225_;
												SkkUnicodeString* _tmp226_;
												gboolean _tmp229_;
												_tmp225_ = state;
												_tmp226_ = _tmp225_->surrounding_text;
												if (_tmp226_ != NULL) {
													SkkState* _tmp227_;
													guint _tmp228_;
													_tmp227_ = state;
													_tmp228_ = _tmp227_->surrounding_end;
													_tmp224_ = _tmp228_ > ((guint) 0);
												} else {
													_tmp224_ = FALSE;
												}
												_tmp229_ = _tmp224_;
												if (_tmp229_) {
													SkkState* _tmp230_;
													guint _tmp231_;
													SkkState* _tmp232_;
													SkkRomKanaConverter* _tmp233_;
													SkkState* _tmp234_;
													SkkUnicodeString* _tmp235_;
													SkkState* _tmp236_;
													guint _tmp237_;
													gchar* _tmp238_ = NULL;
													gchar* _tmp239_;
													_tmp230_ = state;
													_tmp231_ = _tmp230_->surrounding_end;
													_tmp230_->surrounding_end = _tmp231_ - 1;
													_tmp232_ = state;
													_tmp233_ = _tmp232_->rom_kana_converter;
													_tmp234_ = state;
													_tmp235_ = _tmp234_->surrounding_text;
													_tmp236_ = state;
													_tmp237_ = _tmp236_->surrounding_end;
													_tmp238_ = skk_unicode_string_substring (_tmp235_, (glong) 0, (glong) _tmp237_);
													_tmp239_ = _tmp238_;
													skk_rom_kana_converter_set_output (_tmp233_, _tmp239_);
													_g_free0 (_tmp239_);
													result = TRUE;
													_g_free0 (command);
													return result;
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	_tmp241_ = *key;
	_tmp242_ = skk_key_event_get_modifiers (_tmp241_);
	_tmp243_ = _tmp242_;
	if (_tmp243_ == 0) {
		SkkKeyEvent* _tmp244_;
		gunichar _tmp245_;
		gunichar _tmp246_;
		gboolean _tmp247_ = FALSE;
		_tmp244_ = *key;
		_tmp245_ = skk_key_event_get_code (_tmp244_);
		_tmp246_ = _tmp245_;
		_tmp247_ = g_unichar_isalpha (_tmp246_);
		_tmp240_ = _tmp247_;
	} else {
		_tmp240_ = FALSE;
	}
	_tmp248_ = _tmp240_;
	if (_tmp248_) {
		gboolean _tmp249_ = FALSE;
		SkkState* _tmp250_;
		gboolean _tmp251_;
		gboolean _tmp273_;
		_tmp250_ = state;
		_tmp251_ = _tmp250_->okuri;
		if (_tmp251_) {
			_tmp249_ = TRUE;
		} else {
			gboolean _tmp252_ = FALSE;
			gboolean _tmp253_ = FALSE;
			SkkKeyEvent* _tmp254_;
			gunichar _tmp255_;
			gunichar _tmp256_;
			gboolean _tmp257_ = FALSE;
			gboolean _tmp264_;
			gboolean _tmp272_;
			_tmp254_ = *key;
			_tmp255_ = skk_key_event_get_code (_tmp254_);
			_tmp256_ = _tmp255_;
			_tmp257_ = g_unichar_isupper (_tmp256_);
			if (_tmp257_) {
				SkkState* _tmp258_;
				SkkRomKanaConverter* _tmp259_;
				const gchar* _tmp260_;
				const gchar* _tmp261_;
				gint _tmp262_;
				gint _tmp263_;
				_tmp258_ = state;
				_tmp259_ = _tmp258_->rom_kana_converter;
				_tmp260_ = skk_rom_kana_converter_get_output (_tmp259_);
				_tmp261_ = _tmp260_;
				_tmp262_ = strlen (_tmp261_);
				_tmp263_ = _tmp262_;
				_tmp253_ = _tmp263_ > 0;
			} else {
				_tmp253_ = FALSE;
			}
			_tmp264_ = _tmp253_;
			if (_tmp264_) {
				SkkState* _tmp265_;
				SkkRomKanaConverter* _tmp266_;
				SkkKeyEvent* _tmp267_;
				gunichar _tmp268_;
				gunichar _tmp269_;
				gunichar _tmp270_ = 0U;
				gboolean _tmp271_ = FALSE;
				_tmp265_ = state;
				_tmp266_ = _tmp265_->rom_kana_converter;
				_tmp267_ = *key;
				_tmp268_ = skk_key_event_get_code (_tmp267_);
				_tmp269_ = _tmp268_;
				_tmp270_ = g_unichar_tolower (_tmp269_);
				_tmp271_ = skk_rom_kana_converter_can_consume (_tmp266_, _tmp270_, TRUE, TRUE);
				_tmp252_ = !_tmp271_;
			} else {
				_tmp252_ = FALSE;
			}
			_tmp272_ = _tmp252_;
			_tmp249_ = _tmp272_;
		}
		_tmp273_ = _tmp249_;
		if (_tmp273_) {
			gboolean _tmp274_ = FALSE;
			SkkState* _tmp275_;
			gboolean _tmp276_;
			gboolean _tmp284_;
			SkkState* _tmp291_;
			SkkRomKanaConverter* _tmp292_;
			SkkState* _tmp293_;
			SkkState* _tmp294_;
			SkkRomKanaConverter* _tmp295_;
			SkkKeyEvent* _tmp296_;
			gunichar _tmp297_;
			gunichar _tmp298_;
			gunichar _tmp299_ = 0U;
			SkkState* _tmp300_;
			SkkRomKanaConverter* _tmp301_;
			const gchar* _tmp302_;
			const gchar* _tmp303_;
			gint _tmp304_;
			gint _tmp305_;
			_tmp275_ = state;
			_tmp276_ = _tmp275_->okuri;
			if (!_tmp276_) {
				SkkState* _tmp277_;
				SkkRomKanaConverter* _tmp278_;
				SkkKeyEvent* _tmp279_;
				gunichar _tmp280_;
				gunichar _tmp281_;
				gunichar _tmp282_ = 0U;
				gboolean _tmp283_ = FALSE;
				_tmp277_ = state;
				_tmp278_ = _tmp277_->rom_kana_converter;
				_tmp279_ = *key;
				_tmp280_ = skk_key_event_get_code (_tmp279_);
				_tmp281_ = _tmp280_;
				_tmp282_ = g_unichar_tolower (_tmp281_);
				_tmp283_ = skk_rom_kana_converter_can_consume (_tmp278_, _tmp282_, TRUE, FALSE);
				_tmp274_ = _tmp283_;
			} else {
				_tmp274_ = FALSE;
			}
			_tmp284_ = _tmp274_;
			if (_tmp284_) {
				SkkState* _tmp285_;
				SkkRomKanaConverter* _tmp286_;
				SkkKeyEvent* _tmp287_;
				gunichar _tmp288_;
				gunichar _tmp289_;
				gunichar _tmp290_ = 0U;
				_tmp285_ = state;
				_tmp286_ = _tmp285_->rom_kana_converter;
				_tmp287_ = *key;
				_tmp288_ = skk_key_event_get_code (_tmp287_);
				_tmp289_ = _tmp288_;
				_tmp290_ = g_unichar_tolower (_tmp289_);
				skk_rom_kana_converter_append (_tmp286_, _tmp290_);
			}
			_tmp291_ = state;
			_tmp292_ = _tmp291_->rom_kana_converter;
			skk_rom_kana_converter_output_nn_if_any (_tmp292_);
			_tmp293_ = state;
			_tmp293_->okuri = TRUE;
			_tmp294_ = state;
			_tmp295_ = _tmp294_->okuri_rom_kana_converter;
			_tmp296_ = *key;
			_tmp297_ = skk_key_event_get_code (_tmp296_);
			_tmp298_ = _tmp297_;
			_tmp299_ = g_unichar_tolower (_tmp298_);
			skk_rom_kana_converter_append (_tmp295_, _tmp299_);
			_tmp300_ = state;
			_tmp301_ = _tmp300_->okuri_rom_kana_converter;
			_tmp302_ = skk_rom_kana_converter_get_preedit (_tmp301_);
			_tmp303_ = _tmp302_;
			_tmp304_ = strlen (_tmp303_);
			_tmp305_ = _tmp304_;
			if (_tmp305_ == 0) {
				SkkState* _tmp306_;
				SkkState* _tmp307_;
				SkkKeyEvent* _tmp308_ = NULL;
				_tmp306_ = state;
				_tmp306_->handler_type = SKK_TYPE_SELECT_STATE_HANDLER;
				_tmp307_ = state;
				_tmp308_ = skk_state_where_is (_tmp307_, "next-candidate");
				_skk_key_event_unref0 (*key);
				*key = _tmp308_;
				result = FALSE;
				_g_free0 (command);
				return result;
			}
			result = TRUE;
			_g_free0 (command);
			return result;
		} else {
			SkkState* _tmp309_;
			SkkRomKanaConverter* _tmp310_;
			SkkKeyEvent* _tmp311_;
			gunichar _tmp312_;
			gunichar _tmp313_;
			gunichar _tmp314_ = 0U;
			SkkState* _tmp315_;
			SkkKeyEvent* _tmp316_;
			gboolean _tmp317_ = FALSE;
			_tmp309_ = state;
			_tmp310_ = _tmp309_->rom_kana_converter;
			_tmp311_ = *key;
			_tmp312_ = skk_key_event_get_code (_tmp311_);
			_tmp313_ = _tmp312_;
			_tmp314_ = g_unichar_tolower (_tmp313_);
			skk_rom_kana_converter_append (_tmp310_, _tmp314_);
			_tmp315_ = state;
			_tmp316_ = *key;
			_tmp317_ = skk_start_state_handler_check_auto_conversion (self, _tmp315_, _tmp316_);
			if (_tmp317_) {
				SkkState* _tmp318_;
				SkkState* _tmp319_;
				SkkKeyEvent* _tmp320_ = NULL;
				_tmp318_ = state;
				_tmp318_->handler_type = SKK_TYPE_SELECT_STATE_HANDLER;
				_tmp319_ = state;
				_tmp320_ = skk_state_where_is (_tmp319_, "next-candidate");
				_skk_key_event_unref0 (*key);
				*key = _tmp320_;
				result = FALSE;
				_g_free0 (command);
				return result;
			}
			result = TRUE;
			_g_free0 (command);
			return result;
		}
	} else {
		SkkKeyEvent* _tmp321_;
		SkkModifierType _tmp322_;
		SkkModifierType _tmp323_;
		_tmp321_ = *key;
		_tmp322_ = skk_key_event_get_modifiers (_tmp321_);
		_tmp323_ = _tmp322_;
		if (_tmp323_ == 0) {
			SkkState* _tmp324_;
			SkkRomKanaConverter* _tmp325_;
			SkkKeyEvent* _tmp326_;
			gunichar _tmp327_;
			gunichar _tmp328_;
			gunichar _tmp329_ = 0U;
			SkkState* _tmp330_;
			SkkKeyEvent* _tmp331_;
			gboolean _tmp332_ = FALSE;
			_tmp324_ = state;
			_tmp325_ = _tmp324_->rom_kana_converter;
			_tmp326_ = *key;
			_tmp327_ = skk_key_event_get_code (_tmp326_);
			_tmp328_ = _tmp327_;
			_tmp329_ = g_unichar_tolower (_tmp328_);
			skk_rom_kana_converter_append (_tmp325_, _tmp329_);
			_tmp330_ = state;
			_tmp331_ = *key;
			_tmp332_ = skk_start_state_handler_check_auto_conversion (self, _tmp330_, _tmp331_);
			if (_tmp332_) {
				SkkState* _tmp333_;
				SkkState* _tmp334_;
				SkkKeyEvent* _tmp335_ = NULL;
				_tmp333_ = state;
				_tmp333_->handler_type = SKK_TYPE_SELECT_STATE_HANDLER;
				_tmp334_ = state;
				_tmp335_ = skk_state_where_is (_tmp334_, "next-candidate");
				_skk_key_event_unref0 (*key);
				*key = _tmp335_;
				result = FALSE;
				_g_free0 (command);
				return result;
			}
			result = TRUE;
			_g_free0 (command);
			return result;
		}
	}
	result = TRUE;
	_g_free0 (command);
	return result;
}


static gchar* skk_start_state_handler_real_get_preedit (SkkStateHandler* base, SkkState* state, guint* underline_offset, guint* underline_nchars) {
	SkkStartStateHandler * self;
	guint _vala_underline_offset = 0U;
	guint _vala_underline_nchars = 0U;
	gchar* result = NULL;
	GString* _tmp0_;
	GString* builder;
	guint _tmp1_;
	GString* _tmp2_;
	SkkState* _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	SkkState* _tmp6_;
	SkkUnicodeString* _tmp7_;
	GString* _tmp18_;
	const gchar* _tmp19_;
	gchar* _tmp20_;
	self = (SkkStartStateHandler*) base;
	g_return_val_if_fail (state != NULL, NULL);
	_tmp0_ = g_string_new ("▽");
	builder = _tmp0_;
	_vala_underline_nchars = (guint) 0;
	_tmp1_ = _vala_underline_nchars;
	_vala_underline_offset = _tmp1_;
	_tmp2_ = builder;
	_tmp3_ = state;
	_tmp4_ = skk_state_get_yomi (_tmp3_);
	_tmp5_ = _tmp4_;
	g_string_append (_tmp2_, _tmp5_);
	_g_free0 (_tmp5_);
	_tmp6_ = state;
	_tmp7_ = _tmp6_->surrounding_text;
	if (_tmp7_ != NULL) {
		GString* _tmp8_;
		const gchar* _tmp9_;
		gint _tmp10_ = 0;
		GString* _tmp11_;
		SkkState* _tmp12_;
		SkkUnicodeString* _tmp13_;
		SkkState* _tmp14_;
		guint _tmp15_;
		gchar* _tmp16_ = NULL;
		gchar* _tmp17_;
		_vala_underline_offset = (guint) 1;
		_tmp8_ = builder;
		_tmp9_ = _tmp8_->str;
		_tmp10_ = g_utf8_strlen (_tmp9_, (gssize) (-1));
		_vala_underline_nchars = (guint) (_tmp10_ - 1);
		_tmp11_ = builder;
		_tmp12_ = state;
		_tmp13_ = _tmp12_->surrounding_text;
		_tmp14_ = state;
		_tmp15_ = _tmp14_->surrounding_end;
		_tmp16_ = skk_unicode_string_substring (_tmp13_, (glong) _tmp15_, (glong) (-1));
		_tmp17_ = _tmp16_;
		g_string_append (_tmp11_, _tmp17_);
		_g_free0 (_tmp17_);
	}
	_tmp18_ = builder;
	_tmp19_ = _tmp18_->str;
	_tmp20_ = g_strdup (_tmp19_);
	result = _tmp20_;
	_g_string_free0 (builder);
	if (underline_offset) {
		*underline_offset = _vala_underline_offset;
	}
	if (underline_nchars) {
		*underline_nchars = _vala_underline_nchars;
	}
	return result;
}


static gboolean skk_start_state_handler_check_auto_conversion (SkkStartStateHandler* self, SkkState* state, SkkKeyEvent* key) {
	gboolean result = FALSE;
	SkkState* _tmp0_;
	gchar** _tmp1_;
	gint _tmp1__length1;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->auto_start_henkan_keywords;
	_tmp1__length1 = _tmp0_->auto_start_henkan_keywords_length1;
	{
		gchar** keyword_collection = NULL;
		gint keyword_collection_length1 = 0;
		gint _keyword_collection_size_ = 0;
		gint keyword_it = 0;
		keyword_collection = _tmp1_;
		keyword_collection_length1 = _tmp1__length1;
		for (keyword_it = 0; keyword_it < _tmp1__length1; keyword_it = keyword_it + 1) {
			gchar* _tmp2_;
			gchar* keyword = NULL;
			_tmp2_ = g_strdup (keyword_collection[keyword_it]);
			keyword = _tmp2_;
			{
				gboolean _tmp3_ = FALSE;
				SkkState* _tmp4_;
				SkkRomKanaConverter* _tmp5_;
				const gchar* _tmp6_;
				const gchar* _tmp7_;
				gint _tmp8_;
				gint _tmp9_;
				const gchar* _tmp10_;
				gint _tmp11_;
				gint _tmp12_;
				gboolean _tmp19_;
				_tmp4_ = state;
				_tmp5_ = _tmp4_->rom_kana_converter;
				_tmp6_ = skk_rom_kana_converter_get_output (_tmp5_);
				_tmp7_ = _tmp6_;
				_tmp8_ = strlen (_tmp7_);
				_tmp9_ = _tmp8_;
				_tmp10_ = keyword;
				_tmp11_ = strlen (_tmp10_);
				_tmp12_ = _tmp11_;
				if (_tmp9_ > _tmp12_) {
					SkkState* _tmp13_;
					SkkRomKanaConverter* _tmp14_;
					const gchar* _tmp15_;
					const gchar* _tmp16_;
					const gchar* _tmp17_;
					gboolean _tmp18_ = FALSE;
					_tmp13_ = state;
					_tmp14_ = _tmp13_->rom_kana_converter;
					_tmp15_ = skk_rom_kana_converter_get_output (_tmp14_);
					_tmp16_ = _tmp15_;
					_tmp17_ = keyword;
					_tmp18_ = g_str_has_suffix (_tmp16_, _tmp17_);
					_tmp3_ = _tmp18_;
				} else {
					_tmp3_ = FALSE;
				}
				_tmp19_ = _tmp3_;
				if (_tmp19_) {
					SkkState* _tmp20_;
					const gchar* _tmp21_;
					gchar* _tmp22_;
					SkkState* _tmp23_;
					SkkRomKanaConverter* _tmp24_;
					SkkState* _tmp25_;
					SkkRomKanaConverter* _tmp26_;
					const gchar* _tmp27_;
					const gchar* _tmp28_;
					const gchar* _tmp29_;
					gint _tmp30_;
					gint _tmp31_;
					gchar* _tmp32_ = NULL;
					gchar* _tmp33_;
					SkkState* _tmp34_;
					_tmp20_ = state;
					_tmp21_ = keyword;
					_tmp22_ = g_strdup (_tmp21_);
					_g_free0 (_tmp20_->auto_start_henkan_keyword);
					_tmp20_->auto_start_henkan_keyword = _tmp22_;
					_tmp23_ = state;
					_tmp24_ = _tmp23_->rom_kana_converter;
					_tmp25_ = state;
					_tmp26_ = _tmp25_->rom_kana_converter;
					_tmp27_ = skk_rom_kana_converter_get_output (_tmp26_);
					_tmp28_ = _tmp27_;
					_tmp29_ = keyword;
					_tmp30_ = strlen (_tmp29_);
					_tmp31_ = _tmp30_;
					_tmp32_ = string_slice (_tmp28_, (glong) 0, (glong) (-_tmp31_));
					_tmp33_ = _tmp32_;
					skk_rom_kana_converter_set_output (_tmp24_, _tmp33_);
					_g_free0 (_tmp33_);
					_tmp34_ = state;
					_tmp34_->handler_type = SKK_TYPE_SELECT_STATE_HANDLER;
					result = TRUE;
					_g_free0 (keyword);
					return result;
				}
				_g_free0 (keyword);
			}
		}
	}
	result = FALSE;
	return result;
}


SkkStartStateHandler* skk_start_state_handler_construct (GType object_type) {
	SkkStartStateHandler * self = NULL;
	self = (SkkStartStateHandler*) skk_state_handler_construct (object_type);
	return self;
}


SkkStartStateHandler* skk_start_state_handler_new (void) {
	return skk_start_state_handler_construct (SKK_TYPE_START_STATE_HANDLER);
}


static void skk_start_state_handler_class_init (SkkStartStateHandlerClass * klass) {
	skk_start_state_handler_parent_class = g_type_class_peek_parent (klass);
	SKK_STATE_HANDLER_CLASS (klass)->process_key_event = skk_start_state_handler_real_process_key_event;
	SKK_STATE_HANDLER_CLASS (klass)->get_preedit = skk_start_state_handler_real_get_preedit;
}


static void skk_start_state_handler_instance_init (SkkStartStateHandler * self) {
}


GType skk_start_state_handler_get_type (void) {
	static volatile gsize skk_start_state_handler_type_id__volatile = 0;
	if (g_once_init_enter (&skk_start_state_handler_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SkkStartStateHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) skk_start_state_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SkkStartStateHandler), 0, (GInstanceInitFunc) skk_start_state_handler_instance_init, NULL };
		GType skk_start_state_handler_type_id;
		skk_start_state_handler_type_id = g_type_register_static (SKK_TYPE_STATE_HANDLER, "SkkStartStateHandler", &g_define_type_info, 0);
		g_once_init_leave (&skk_start_state_handler_type_id__volatile, skk_start_state_handler_type_id);
	}
	return skk_start_state_handler_type_id__volatile;
}


static gboolean skk_select_state_handler_real_process_key_event (SkkStateHandler* base, SkkState* state, SkkKeyEvent** key) {
	SkkSelectStateHandler * self;
	gboolean result = FALSE;
	SkkState* _tmp0_;
	SkkKeyEvent* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* command;
	const gchar* _tmp3_;
	self = (SkkSelectStateHandler*) base;
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = *key;
	_tmp2_ = skk_state_lookup_key (_tmp0_, _tmp1_);
	command = _tmp2_;
	_tmp3_ = command;
	if (g_strcmp0 (_tmp3_, "previous-candidate") == 0) {
		SkkState* _tmp4_;
		SkkCandidateList* _tmp5_;
		gboolean _tmp6_ = FALSE;
		_tmp4_ = state;
		_tmp5_ = _tmp4_->candidates;
		_tmp6_ = skk_candidate_list_previous (_tmp5_);
		if (!_tmp6_) {
			SkkState* _tmp7_;
			SkkCandidateList* _tmp8_;
			SkkState* _tmp9_;
			_tmp7_ = state;
			_tmp8_ = _tmp7_->candidates;
			skk_candidate_list_clear (_tmp8_);
			_tmp9_ = state;
			_tmp9_->handler_type = SKK_TYPE_START_STATE_HANDLER;
		}
		result = TRUE;
		_g_free0 (command);
		return result;
	} else {
		const gchar* _tmp10_;
		_tmp10_ = command;
		if (g_strcmp0 (_tmp10_, "purge-candidate") == 0) {
			SkkState* _tmp11_;
			SkkCandidateList* _tmp12_;
			SkkCandidate* _tmp13_ = NULL;
			SkkCandidate* candidate;
			SkkState* _tmp14_;
			SkkCandidate* _tmp15_;
			SkkState* _tmp16_;
			_tmp11_ = state;
			_tmp12_ = _tmp11_->candidates;
			_tmp13_ = skk_candidate_list_get (_tmp12_, -1);
			candidate = _tmp13_;
			_tmp14_ = state;
			_tmp15_ = candidate;
			skk_state_purge_candidate (_tmp14_, _tmp15_);
			_tmp16_ = state;
			skk_state_reset (_tmp16_);
			result = TRUE;
			_g_object_unref0 (candidate);
			_g_free0 (command);
			return result;
		} else {
			const gchar* _tmp17_;
			_tmp17_ = command;
			if (g_strcmp0 (_tmp17_, "next-candidate") == 0) {
				SkkState* _tmp18_;
				SkkCandidateList* _tmp19_;
				gint _tmp20_;
				gint _tmp21_;
				SkkState* _tmp60_;
				SkkState* _tmp61_;
				gchar* _tmp62_ = NULL;
				gchar* _tmp63_;
				SkkState* _tmp64_;
				gboolean _tmp65_;
				SkkState* _tmp66_;
				SkkCandidateList* _tmp67_;
				gint _tmp68_;
				gint _tmp69_;
				_tmp18_ = state;
				_tmp19_ = _tmp18_->candidates;
				_tmp20_ = skk_candidate_list_get_cursor_pos (_tmp19_);
				_tmp21_ = _tmp20_;
				if (_tmp21_ < 0) {
					gchar* midasi = NULL;
					gboolean okuri;
					SkkState* _tmp22_;
					GString* _tmp23_;
					gssize _tmp24_;
					SkkState* _tmp50_;
					const gchar* _tmp51_;
					gboolean _tmp52_;
					SkkState* _tmp53_;
					SkkCandidateList* _tmp54_;
					gint _tmp55_;
					gint _tmp56_;
					okuri = FALSE;
					_tmp22_ = state;
					_tmp23_ = _tmp22_->abbrev;
					_tmp24_ = _tmp23_->len;
					if (_tmp24_ > ((gssize) 0)) {
						SkkState* _tmp25_;
						GString* _tmp26_;
						const gchar* _tmp27_;
						gchar* _tmp28_;
						_tmp25_ = state;
						_tmp26_ = _tmp25_->abbrev;
						_tmp27_ = _tmp26_->str;
						_tmp28_ = g_strdup (_tmp27_);
						_g_free0 (midasi);
						midasi = _tmp28_;
					} else {
						GString* _tmp29_;
						GString* builder;
						SkkState* _tmp30_;
						SkkRomKanaConverter* _tmp31_;
						GString* _tmp32_;
						SkkState* _tmp33_;
						SkkRomKanaConverter* _tmp34_;
						const gchar* _tmp35_;
						const gchar* _tmp36_;
						SkkState* _tmp37_;
						gboolean _tmp38_;
						GString* _tmp47_;
						const gchar* _tmp48_;
						gchar* _tmp49_ = NULL;
						_tmp29_ = g_string_new ("");
						builder = _tmp29_;
						_tmp30_ = state;
						_tmp31_ = _tmp30_->rom_kana_converter;
						skk_rom_kana_converter_output_nn_if_any (_tmp31_);
						_tmp32_ = builder;
						_tmp33_ = state;
						_tmp34_ = _tmp33_->rom_kana_converter;
						_tmp35_ = skk_rom_kana_converter_get_output (_tmp34_);
						_tmp36_ = _tmp35_;
						g_string_append (_tmp32_, _tmp36_);
						_tmp37_ = state;
						_tmp38_ = _tmp37_->okuri;
						if (_tmp38_) {
							SkkState* _tmp39_;
							SkkRomKanaConverter* _tmp40_;
							const gchar* _tmp41_;
							const gchar* _tmp42_;
							gchar* _tmp43_ = NULL;
							gchar* prefix;
							const gchar* _tmp44_;
							_tmp39_ = state;
							_tmp40_ = _tmp39_->okuri_rom_kana_converter;
							_tmp41_ = skk_rom_kana_converter_get_output (_tmp40_);
							_tmp42_ = _tmp41_;
							_tmp43_ = skk_util_get_okurigana_prefix (_tmp42_);
							prefix = _tmp43_;
							_tmp44_ = prefix;
							if (_tmp44_ != NULL) {
								GString* _tmp45_;
								const gchar* _tmp46_;
								_tmp45_ = builder;
								_tmp46_ = prefix;
								g_string_append (_tmp45_, _tmp46_);
								okuri = TRUE;
							}
							_g_free0 (prefix);
						}
						_tmp47_ = builder;
						_tmp48_ = _tmp47_->str;
						_tmp49_ = skk_util_get_hiragana (_tmp48_);
						_g_free0 (midasi);
						midasi = _tmp49_;
						_g_string_free0 (builder);
					}
					_tmp50_ = state;
					_tmp51_ = midasi;
					_tmp52_ = okuri;
					skk_state_lookup (_tmp50_, _tmp51_, _tmp52_);
					_tmp53_ = state;
					_tmp54_ = _tmp53_->candidates;
					_tmp55_ = skk_candidate_list_get_size (_tmp54_);
					_tmp56_ = _tmp55_;
					if (_tmp56_ > 0) {
						result = TRUE;
						_g_free0 (midasi);
						_g_free0 (command);
						return result;
					}
					_g_free0 (midasi);
				} else {
					SkkState* _tmp57_;
					SkkCandidateList* _tmp58_;
					gboolean _tmp59_ = FALSE;
					_tmp57_ = state;
					_tmp58_ = _tmp57_->candidates;
					_tmp59_ = skk_candidate_list_next (_tmp58_);
					if (_tmp59_) {
						result = TRUE;
						_g_free0 (command);
						return result;
					}
				}
				_tmp60_ = state;
				_tmp61_ = state;
				_tmp62_ = skk_state_get_yomi (_tmp61_);
				_tmp63_ = _tmp62_;
				_tmp64_ = state;
				_tmp65_ = _tmp64_->okuri;
				g_signal_emit_by_name (_tmp60_, "recursive-edit-start", _tmp63_, _tmp65_);
				_g_free0 (_tmp63_);
				_tmp66_ = state;
				_tmp67_ = _tmp66_->candidates;
				_tmp68_ = skk_candidate_list_get_size (_tmp67_);
				_tmp69_ = _tmp68_;
				if (_tmp69_ == 0) {
					SkkState* _tmp70_;
					SkkCandidateList* _tmp71_;
					SkkState* _tmp72_;
					_tmp70_ = state;
					_tmp71_ = _tmp70_->candidates;
					skk_candidate_list_clear (_tmp71_);
					_tmp72_ = state;
					_tmp72_->handler_type = SKK_TYPE_START_STATE_HANDLER;
				}
				result = TRUE;
				_g_free0 (command);
				return result;
			} else {
				const gchar* _tmp73_;
				_tmp73_ = command;
				if (g_strcmp0 (_tmp73_, "abort") == 0) {
					SkkState* _tmp74_;
					SkkCandidateList* _tmp75_;
					SkkState* _tmp76_;
					SkkState* _tmp77_;
					_tmp74_ = state;
					_tmp75_ = _tmp74_->candidates;
					skk_candidate_list_clear (_tmp75_);
					_tmp76_ = state;
					skk_state_cancel_okuri (_tmp76_);
					_tmp77_ = state;
					_tmp77_->handler_type = SKK_TYPE_START_STATE_HANDLER;
					result = TRUE;
					_g_free0 (command);
					return result;
				} else {
					gchar* _tmp78_;
					gchar* surrounding_after;
					SkkState* _tmp79_;
					SkkUnicodeString* _tmp80_;
					SkkState* _tmp86_;
					SkkCandidateList* _tmp87_;
					SkkState* _tmp88_;
					GString* _tmp89_;
					const gchar* _tmp90_;
					const gchar* _tmp91_;
					_tmp78_ = g_strdup ("");
					surrounding_after = _tmp78_;
					_tmp79_ = state;
					_tmp80_ = _tmp79_->surrounding_text;
					if (_tmp80_ != NULL) {
						SkkState* _tmp81_;
						SkkUnicodeString* _tmp82_;
						SkkState* _tmp83_;
						guint _tmp84_;
						gchar* _tmp85_ = NULL;
						_tmp81_ = state;
						_tmp82_ = _tmp81_->surrounding_text;
						_tmp83_ = state;
						_tmp84_ = _tmp83_->surrounding_end;
						_tmp85_ = skk_unicode_string_substring (_tmp82_, (glong) _tmp84_, (glong) (-1));
						_g_free0 (surrounding_after);
						surrounding_after = _tmp85_;
					}
					_tmp86_ = state;
					_tmp87_ = _tmp86_->candidates;
					skk_candidate_list_select (_tmp87_, -1);
					_tmp88_ = state;
					_tmp89_ = _tmp88_->output;
					_tmp90_ = surrounding_after;
					g_string_append (_tmp89_, _tmp90_);
					_tmp91_ = command;
					if (g_strcmp0 (_tmp91_, "special-midasi") == 0) {
						SkkState* _tmp92_;
						_tmp92_ = state;
						_tmp92_->handler_type = SKK_TYPE_START_STATE_HANDLER;
						result = FALSE;
						_g_free0 (surrounding_after);
						_g_free0 (command);
						return result;
					} else {
						SkkState* _tmp93_;
						gboolean _tmp94_ = FALSE;
						gboolean _tmp95_ = FALSE;
						gboolean _tmp96_ = FALSE;
						gboolean _tmp97_ = FALSE;
						SkkKeyEvent* _tmp98_;
						SkkModifierType _tmp99_;
						SkkModifierType _tmp100_;
						gboolean _tmp104_;
						gboolean _tmp108_;
						gboolean _tmp110_;
						gboolean _tmp116_;
						_tmp93_ = state;
						skk_state_reset (_tmp93_);
						_tmp98_ = *key;
						_tmp99_ = skk_key_event_get_modifiers (_tmp98_);
						_tmp100_ = _tmp99_;
						if (_tmp100_ == 0) {
							SkkKeyEvent* _tmp101_;
							gunichar _tmp102_;
							gunichar _tmp103_;
							_tmp101_ = *key;
							_tmp102_ = skk_key_event_get_code (_tmp101_);
							_tmp103_ = _tmp102_;
							_tmp97_ = ((gunichar) 0x20) <= _tmp103_;
						} else {
							_tmp97_ = FALSE;
						}
						_tmp104_ = _tmp97_;
						if (_tmp104_) {
							SkkKeyEvent* _tmp105_;
							gunichar _tmp106_;
							gunichar _tmp107_;
							_tmp105_ = *key;
							_tmp106_ = skk_key_event_get_code (_tmp105_);
							_tmp107_ = _tmp106_;
							_tmp96_ = _tmp107_ <= ((gunichar) 0x7E);
						} else {
							_tmp96_ = FALSE;
						}
						_tmp108_ = _tmp96_;
						if (_tmp108_) {
							_tmp95_ = TRUE;
						} else {
							const gchar* _tmp109_;
							_tmp109_ = command;
							_tmp95_ = g_strcmp0 (_tmp109_, "delete") == 0;
						}
						_tmp110_ = _tmp95_;
						if (_tmp110_) {
							_tmp94_ = TRUE;
						} else {
							gboolean _tmp111_ = FALSE;
							SkkState* _tmp112_;
							gboolean _tmp113_;
							gboolean _tmp115_;
							_tmp112_ = state;
							_tmp113_ = _tmp112_->egg_like_newline;
							if (!_tmp113_) {
								const gchar* _tmp114_;
								_tmp114_ = command;
								_tmp111_ = g_strcmp0 (_tmp114_, "commit-unhandled") == 0;
							} else {
								_tmp111_ = FALSE;
							}
							_tmp115_ = _tmp111_;
							_tmp94_ = _tmp115_;
						}
						_tmp116_ = _tmp94_;
						if (_tmp116_) {
							result = FALSE;
							_g_free0 (surrounding_after);
							_g_free0 (command);
							return result;
						} else {
							result = TRUE;
							_g_free0 (surrounding_after);
							_g_free0 (command);
							return result;
						}
					}
					_g_free0 (surrounding_after);
				}
			}
		}
	}
	_g_free0 (command);
}


static gchar* skk_select_state_handler_real_get_preedit (SkkStateHandler* base, SkkState* state, guint* underline_offset, guint* underline_nchars) {
	SkkSelectStateHandler * self;
	guint _vala_underline_offset = 0U;
	guint _vala_underline_nchars = 0U;
	gchar* result = NULL;
	GString* _tmp0_;
	GString* builder;
	guint _tmp1_;
	SkkState* _tmp2_;
	SkkCandidateList* _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	SkkState* _tmp18_;
	const gchar* _tmp19_;
	GString* _tmp42_;
	const gchar* _tmp43_;
	gchar* _tmp44_;
	self = (SkkSelectStateHandler*) base;
	g_return_val_if_fail (state != NULL, NULL);
	_tmp0_ = g_string_new ("▼");
	builder = _tmp0_;
	_vala_underline_nchars = (guint) 0;
	_tmp1_ = _vala_underline_nchars;
	_vala_underline_offset = _tmp1_;
	_tmp2_ = state;
	_tmp3_ = _tmp2_->candidates;
	_tmp4_ = skk_candidate_list_get_cursor_pos (_tmp3_);
	_tmp5_ = _tmp4_;
	if (_tmp5_ >= 0) {
		SkkState* _tmp6_;
		SkkCandidateList* _tmp7_;
		SkkCandidate* _tmp8_ = NULL;
		SkkCandidate* c;
		GString* _tmp9_;
		SkkCandidate* _tmp10_;
		const gchar* _tmp11_;
		const gchar* _tmp12_;
		_tmp6_ = state;
		_tmp7_ = _tmp6_->candidates;
		_tmp8_ = skk_candidate_list_get (_tmp7_, -1);
		c = _tmp8_;
		_tmp9_ = builder;
		_tmp10_ = c;
		_tmp11_ = skk_candidate_get_output (_tmp10_);
		_tmp12_ = _tmp11_;
		g_string_append (_tmp9_, _tmp12_);
		_g_object_unref0 (c);
	} else {
		GString* _tmp13_;
		SkkState* _tmp14_;
		SkkRomKanaConverter* _tmp15_;
		const gchar* _tmp16_;
		const gchar* _tmp17_;
		_tmp13_ = builder;
		_tmp14_ = state;
		_tmp15_ = _tmp14_->rom_kana_converter;
		_tmp16_ = skk_rom_kana_converter_get_output (_tmp15_);
		_tmp17_ = _tmp16_;
		g_string_append (_tmp13_, _tmp17_);
	}
	_tmp18_ = state;
	_tmp19_ = _tmp18_->auto_start_henkan_keyword;
	if (_tmp19_ != NULL) {
		GString* _tmp20_;
		SkkState* _tmp21_;
		const gchar* _tmp22_;
		_tmp20_ = builder;
		_tmp21_ = state;
		_tmp22_ = _tmp21_->auto_start_henkan_keyword;
		g_string_append (_tmp20_, _tmp22_);
	} else {
		SkkState* _tmp23_;
		gboolean _tmp24_;
		_tmp23_ = state;
		_tmp24_ = _tmp23_->okuri;
		if (_tmp24_) {
			GString* _tmp25_;
			SkkState* _tmp26_;
			SkkRomKanaConverter* _tmp27_;
			const gchar* _tmp28_;
			const gchar* _tmp29_;
			_tmp25_ = builder;
			_tmp26_ = state;
			_tmp27_ = _tmp26_->okuri_rom_kana_converter;
			_tmp28_ = skk_rom_kana_converter_get_output (_tmp27_);
			_tmp29_ = _tmp28_;
			g_string_append (_tmp25_, _tmp29_);
		} else {
			SkkState* _tmp30_;
			SkkUnicodeString* _tmp31_;
			_tmp30_ = state;
			_tmp31_ = _tmp30_->surrounding_text;
			if (_tmp31_ != NULL) {
				GString* _tmp32_;
				const gchar* _tmp33_;
				gint _tmp34_ = 0;
				GString* _tmp35_;
				SkkState* _tmp36_;
				SkkUnicodeString* _tmp37_;
				SkkState* _tmp38_;
				guint _tmp39_;
				gchar* _tmp40_ = NULL;
				gchar* _tmp41_;
				_vala_underline_offset = (guint) 1;
				_tmp32_ = builder;
				_tmp33_ = _tmp32_->str;
				_tmp34_ = g_utf8_strlen (_tmp33_, (gssize) (-1));
				_vala_underline_nchars = (guint) (_tmp34_ - 1);
				_tmp35_ = builder;
				_tmp36_ = state;
				_tmp37_ = _tmp36_->surrounding_text;
				_tmp38_ = state;
				_tmp39_ = _tmp38_->surrounding_end;
				_tmp40_ = skk_unicode_string_substring (_tmp37_, (glong) _tmp39_, (glong) (-1));
				_tmp41_ = _tmp40_;
				g_string_append (_tmp35_, _tmp41_);
				_g_free0 (_tmp41_);
			}
		}
	}
	_tmp42_ = builder;
	_tmp43_ = _tmp42_->str;
	_tmp44_ = g_strdup (_tmp43_);
	result = _tmp44_;
	_g_string_free0 (builder);
	if (underline_offset) {
		*underline_offset = _vala_underline_offset;
	}
	if (underline_nchars) {
		*underline_nchars = _vala_underline_nchars;
	}
	return result;
}


SkkSelectStateHandler* skk_select_state_handler_construct (GType object_type) {
	SkkSelectStateHandler * self = NULL;
	self = (SkkSelectStateHandler*) skk_state_handler_construct (object_type);
	return self;
}


SkkSelectStateHandler* skk_select_state_handler_new (void) {
	return skk_select_state_handler_construct (SKK_TYPE_SELECT_STATE_HANDLER);
}


static void skk_select_state_handler_class_init (SkkSelectStateHandlerClass * klass) {
	skk_select_state_handler_parent_class = g_type_class_peek_parent (klass);
	SKK_STATE_HANDLER_CLASS (klass)->process_key_event = skk_select_state_handler_real_process_key_event;
	SKK_STATE_HANDLER_CLASS (klass)->get_preedit = skk_select_state_handler_real_get_preedit;
}


static void skk_select_state_handler_instance_init (SkkSelectStateHandler * self) {
}


GType skk_select_state_handler_get_type (void) {
	static volatile gsize skk_select_state_handler_type_id__volatile = 0;
	if (g_once_init_enter (&skk_select_state_handler_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SkkSelectStateHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) skk_select_state_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SkkSelectStateHandler), 0, (GInstanceInitFunc) skk_select_state_handler_instance_init, NULL };
		GType skk_select_state_handler_type_id;
		skk_select_state_handler_type_id = g_type_register_static (SKK_TYPE_STATE_HANDLER, "SkkSelectStateHandler", &g_define_type_info, 0);
		g_once_init_leave (&skk_select_state_handler_type_id__volatile, skk_select_state_handler_type_id);
	}
	return skk_select_state_handler_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



